@database RPC.guide

@Master RPC.texi

@Width 72


This is the AmigaGuide® file RPC.guide, produced by Makeinfo-1.55 from 
the input file RPC.texi.

   This file is translated from the Sun provided nroff-files. The
original content is Copyright Sun Microsystems, Inc.

   Texinfo conversion is Copyright 1993 Jarno Rajahalme.


@Node Main "RPC.guide"

AmiTCP/IP Remote Procedure Calls Manual
***************************************

   This document contains the original Sun RPC documents in a new
format.  All examples are as in the original ones, especially, they are
meant to be run undex UNIX. As I assume the potential readers of this
manual to be familiar with various UNIXes, I didn't put my effort in
converting the examples. So, do not expect to be able to follow the
examples literally in AmigaOS. All RPC code should work as described,
however.


 @{" Disclaimer & Copyright " Link "Disclaimer & Copyright"} 
 @{" AmiTCP-IP Notes " Link "AmiTCP-IP Notes"} 
 @{" rpcgen Programming Guide " Link "rpcgen Programming Guide"} 
 @{" Remote Procedure Call Programming Guide " Link "Remote Procedure Call Programming Guide"} 
 @{" XDR Technical Notes " Link "XDR Technical Notes"} 
 @{" XDR Protocol Specification " Link "XDR Protocol Specification"} 
 @{" Remote Procedure Calls Protocol Specification " Link "Remote Procedure Calls Protocol Specification"} 
 @{" Network File System Version 2 Protocol Specification " Link "Network File System Version 2 Protocol Specification"} 
 @{" Manual Pages " Link "Manual Pages"} 
 @{" Function Index " Link "Function Index"} 
 @{" Concept Index " Link "Concept Index"} 


@EndNode

@Node "Disclaimer & Copyright" "RPC.guide/Disclaimer & Copyright"
@Next "AmiTCP-IP Notes"
@Prev "Main"
@Toc "Main"

Disclaimer & Copyright
**********************

   Sun RPC is a product of Sun Microsystems, Inc. and is provided for
unrestricted use provided that this legend is included on all tape
media and as a part of the software program in whole or part.  Users
may copy or modify Sun RPC without charge, but are not authorized to
license or distribute it to anyone else except as part of a product or
program developed by the user.

   SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING
THE WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.

   Sun RPC is provided with no support and without any obligation on the
part of Sun Microsystems, Inc. to assist in its use, correction,
modification or enhancement.

   SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC OR
ANY PART THEREOF.

   In no event will Sun Microsystems, Inc. be liable for any lost
revenue or profits or other special, indirect and consequential
damages, even if Sun has been advised of the possibility of such
damages.

Sun Microsystems, Inc.
2550 Garcia Avenue
Mountain View, California  94043

   This version of the manual is converted from Sun provided roff-files
by Jarno Rajahalme 1993. All comments about this version should be sent
to:

     <Jarno.Rajahalme@hut.fi>


@EndNode

@Node "AmiTCP-IP Notes" "RPC.guide/AmiTCP-IP Notes"
@Next "rpcgen Programming Guide"
@Prev "Disclaimer & Copyright"
@Toc "Main"

AmiTCP/IP RPC Notes
*******************

   This chapter describes the AmiTCP/IP version of the Sun RPC 4.0.

   *Note:* Read this chapter carefully and then do the "Hello World!"
test with the provided demonstration protocols in `demo' directory.
Once you get these compiled and running you know that your setup is
complete.


 @{" About the Port to AmiTCP-IP and Amiga " Link "About the Port to AmiTCP-IP and Amiga"} 
 @{" rpcgen Notes " Link "rpcgen Notes"} 
 @{" portmap and rpcinfo " Link "portmap and rpcinfo"} 
 @{" Using the Library " Link "Using the Library"} 


@EndNode

@Node "About the Port to AmiTCP-IP and Amiga" "RPC.guide/About the Port to AmiTCP-IP and Amiga"
@Next "rpcgen Notes"
@Toc "AmiTCP-IP Notes"

About the Port to AmiTCP/IP and Amiga
=====================================


 @{" Nonsupported Features " Link "Nonsupported Features"} 
 @{" About the Floating Point Format " Link "About the Floating Point Format"} 
 @{" What Was Done to the Original SUNRPC 4.0 While Porting " Link "What Was Done to the Original SUNRPC 4.0 While Porting"} 


@EndNode

@Node "Nonsupported Features" "RPC.guide/Nonsupported Features"
@Next "About the Floating Point Format"
@Toc "About the Port to AmiTCP-IP and Amiga"

Nonsupported Features
---------------------

   Following features are not supported/modified in this version:

Secure RPC
     This is not yet supported. I might decide to support it, if it is
     requested. This means that none of the DES authentication
     functions are included in the library.

Broadcast RPC
     The current support for Broadcast RPC is limited in sense that the
     @{"portmap" Link "portmap and rpcinfo"} blocks while serving the broadcasted RPC. This means that
     the `portmap' services are not available during that time, which
     may prevent some RPC servers from functioning correctly.

`getrpcent()'
     Didn't include this, since AmiTCP/IP doesn't provide the `*ent()'
     functions in general. I might re-enable this if there is any
     demand for it.

`svcfd_create()'
     This is not included, since the library uses AmiTCP/IP socket
     descriptors. This might be added if there ever becomes a good,
     portable solution to the file vs. socket descriptor problem.


@EndNode

@Node "About the Floating Point Format" "RPC.guide/About the Floating Point Format"
@Next "What Was Done to the Original SUNRPC 4.0 While Porting"
@Prev "Nonsupported Features"
@Toc "About the Port to AmiTCP-IP and Amiga"

About the Floating Point Format
-------------------------------

   The library supports only IEEE format floating point values
(`xdr_float()' and `xdr_double()'). The FFP format *must not* be used.
Consult your compiler documentation about choosing the floating point
format (SAS/C uses IEEE by default).


@EndNode

@Node "What Was Done to the Original SUNRPC 4.0 While Porting" "RPC.guide/What Was Done to the Original SUNRPC 4.0 While Porting"
@Prev "About the Floating Point Format"
@Toc "About the Port to AmiTCP-IP and Amiga"

What Was Done to the Original SUNRPC 4.0 While Porting
------------------------------------------------------

  1. Added ANSI C prototypes to all function and function pointer
     prototypes

  2. ANSIfied the includes if possible (`sys/errno.h' -> `errno.h', for
     example).

  3. Removed dependency on select() retaining the value of the timeout
     `timeval'.

  4. Changed `read()' and `write()' calls to `recv()' and `send()',
     respectively. This prevents the usage of the real file descriptors
     (see the `svcfd_create()' in @{"Nonsupported Features" Link "Nonsupported Features"}).

  5. Added `sys/param.h' as the first include file for every `.c' file
     for concistency.

  6. Added `XDRFUN' definition to `rpc/types.h'. It is used in
     definition of every xdr-function.

  7. Changed `close()'s and `ioctl()'s on sockets to `CloseSocket()'
     and `IoctlSocket()' if `AMITCP' is defined.

  8. Changed `getpid()'s to `FindTask(NULL)' if `AMIGA' is defined.

  9. Changed socket calls no to be retried after the `EINTR' error
     return.


@EndNode

@Node "rpcgen Notes" "RPC.guide/rpcgen Notes"
@Next "portmap and rpcinfo"
@Prev "About the Port to AmiTCP-IP and Amiga"
@Toc "AmiTCP-IP Notes"

`rpcgen' Notes
==============

   The `rpcgen' included in this distibution is ported from the
TIRPC(1) `rpcgen' from Linux by Carsten Heyl
<ch@irb.informatik.uni-dortmund.de>. This version of `rpcgen' can
produce K&R/ANSI-C/C++ compatible output.  It also can generate `inetd'
compatible daemons, but this feature is not yet supported. Refer to the
manual page of the `rpcgen' for its usage.

   The `rpcgen' needs a C preprocessor to handle the macros and
comments. One suitable C preprocessor (`cpp') is included in the
distribution. It is based on an old DECUS cpp port by Fred Fish. Carsten
added a `-P' option to suppress `#line' directives, which the `cpp'
left on the output.

   See @{"rpcgen Manual Page" Link "rpcgen Manual Page"}.

   ---------- Footnotes ----------

   (1)  Transport Independent RPC


@EndNode

@Node "portmap and rpcinfo" "RPC.guide/portmap and rpcinfo"
@Next "Using the Library"
@Prev "rpcgen Notes"
@Toc "AmiTCP-IP Notes"

`portmap' and `rpcinfo'
=======================

   `portmap' is the RPC program to internet port mapper, see
@{"Port Mapper Program Protocol" Link "Port Mapper Program Protocol"}. The `portmap' must be started before any
RPC services, and it is best to include line "`run portmap'" to your
`AmiTCP:bin/startnet' script. See @{"portmap Manual Page" Link "portmap Manual Page"}.

   The `rpcinfo' can be used to view `portmap' bindings on any host.
See the manual page for the usage. See @{"rpcinfo Manual Page" Link "rpcinfo Manual Page"}.


@EndNode

@Node "Using the Library" "RPC.guide/Using the Library"
@Prev "portmap and rpcinfo"
@Toc "AmiTCP-IP Notes"

Using the Library
=================


 @{" Supported Compilers " Link "Supported Compilers"} 
 @{" Compiling the library " Link "Compiling the library"} 
 @{" Choosing the Library to Use " Link "Choosing the Library to Use"} 


@EndNode

@Node "Supported Compilers" "RPC.guide/Supported Compilers"
@Next "Compiling the library"
@Toc "Using the Library"

Supported Compilers
-------------------

   The distribution contains precompiled library for the SAS/C 6.x,
since it's the compiler I use. The library is highly portable though,
and you should have no problems compiling it with DICE, GCC etc.

   The only compiler dependent part I made there is the definition
`XDRFUN' (in `rpc/types.h'), which is defined as `__regargs' for SAS/C
and as nothing for others.

   The makefiles are written for the SAS `smake', but since it doesn't
have any fancy features, they should be quite portable as well.


@EndNode

@Node "Compiling the library" "RPC.guide/Compiling the library"
@Next "Choosing the Library to Use"
@Prev "Supported Compilers"
@Toc "Using the Library"

Compiling the library
---------------------

   The library code assumes that the `bsdsocket.library' is opened by
the caller, and the library base is in global variable named
`SocketBase'. Also the global `errno' variable must be set with the
AmiTCP/IP `SocketBaseTagList()' function (1).

   The `Smakefile' of the library can compile eight different versions
of the library, but only the `rpcr.lib' version is compiled by default,
see @{"Choosing the Library to Use" Link "Choosing the Library to Use"}. This library is installed to the
`AmiTCP:netlib' directory by default.

   ---------- Footnotes ----------

   (1)  These are standard AmiTCP/IP practices and are provided by the
`net.lib' autoinitialization routine, so normally these are no concern.


@EndNode

@Node "Choosing the Library to Use" "RPC.guide/Choosing the Library to Use"
@Prev "Compiling the library"
@Toc "Using the Library"

Choosing the Library to Use
---------------------------

   Eight different versions of the library are provided. The library is
compiled either with or without the debugging information, with near or
far data, and with register or stack arguments. Use the following table
to select the right library:

     |   Arguments   |     Data      | Debugging |
     | Stack | Reg.  | Near  |  Far  | No  | Yes | Library name
     +-------+-------+-------+-------+-----+-----+--------------
     |   x   |       |   x   |       |  x  |     | rpc.lib
     |       |   x   |   x   |       |  x  |     | rpcr.lib
     |   x   |       |       |   x   |  x  |     | rpcnb.lib
     |       |   x   |       |   x   |  x  |     | rpcnbr.lib
     |   x   |       |   x   |       |     |  x  | grpc.lib
     |       |   x   |   x   |       |     |  x  | grpcr.lib
     |   x   |       |       |   x   |     |  x  | grpcnb.lib
     |       |   x   |       |   x   |     |  x  | grpcnbr.lib

   The use of registerized arguments and near data is highly
recommended, since these options provide smaller and faster executables.

   To compile the desired version of the library, issue `smake <Library
name>' or `smake all' to compile all the versions. The makefile can
only install the default version to the `netlib:', you must move the
other libraries yourself.

   The reason why the library is not compiled with SAS/C `ARGS=BOTH' is
that there are some problems SAS/C not enforcing the function pointers
prototyped as taking stack arguments actually being assigned with the
proper (stack) entry point of a function, if there are both stack and
register versions of the function available (as is the case with the
`ARGS=BOTH' libraries).

   Second reason is that if you want to use stack arguments, an
`ARGS=STACK' library is faster than the `BOTH' equivalent.

   The dedugging info is compiled with SAS/C `FullFlush' option.


@EndNode

@Node "rpcgen Programming Guide" "RPC.guide/rpcgen Programming Guide"
@Next "Remote Procedure Call Programming Guide"
@Prev "AmiTCP-IP Notes"
@Toc "Main"

`rpcgen' Programming Guide
**************************

   This chapter documents the Sun RPC Compiler, the `rpcgen'.


 @{" The rpcgen Protocol Compiler " Link "The rpcgen Protocol Compiler"} 
 @{" Converting Local Procedures into Remote Procedures " Link "Converting Local Procedures into Remote Procedures"} 
 @{" Generating XDR Routines " Link "Generating XDR Routines"} 
 @{" The C-Preprocessor " Link "The C-Preprocessor"} 
 @{" rpcgen Programming Notes " Link "rpcgen Programming Notes"} 
 @{" RPC Language " Link "RPC Language"} 


@EndNode

@Node "The rpcgen Protocol Compiler" "RPC.guide/The rpcgen Protocol Compiler"
@Next "Converting Local Procedures into Remote Procedures"
@Toc "rpcgen Programming Guide"

The `rpcgen' Protocol Compiler
==============================

   The details of programming applications to use Remote Procedure Calls
can be overwhelming.  Perhaps most daunting is the writing of the XDR
routines necessary to convert procedure arguments and results into their
network format and vice-versa.

   Fortunately, `rpcgen' exists to help programmers write RPC
applications simply and directly.  `rpcgen' does most of the dirty
work, allowing programmers to debug the main features of their
application, instead of requiring them to spend most of their time
debugging their network interface code.

   `rpcgen' is a compiler.  It accepts a remote program interface
definition written in a language, called RPC Language, which is similar
to C.  It produces a C language output which includes stub versions of
the client routines, a server skeleton, XDR filter routines for both
parameters and results, and a header file that contains common
definitions. The client stubs interface with the RPC library and
effectively hide the network from their callers.  The server stub
similarly hides the network from the server procedures that are to be
invoked by remote clients.  `rpcgen''s output files can be compiled and
linked in the usual way.  The developer writes server procedures -- in
any language that observes Sun calling conventions -- and links them
with the server skeleton produced by `rpcgen' to get an executable
server program.  To use a remote program, a programmer writes an
ordinary main program that makes local procedure calls to the client
stubs produced by `rpcgen'.  Linking this program with `rpcgen''s stubs
creates an executable program.  (At present the main program must be
written in C).  `rpcgen' options can be used to suppress stub
generation and to specify the transport to be used by the server stub.

   Like all compilers, `rpcgen' reduces development time that would
otherwise be spent coding and debugging low-level routines.  All
compilers, including `rpcgen', do this at a small cost in efficiency
and flexibility.  However, many compilers allow escape hatches for
programmers to mix low-level code with high-level code.  `rpcgen' is no
exception.  In speed-critical applications, hand-written routines can
be linked with the `rpcgen' output without any difficulty.  Also, one
may proceed by using `rpcgen' output as a starting point, and then
rewriting it as necessary.  (If you need a discussion of RPC
programming without `rpcgen', see
@{"Remote Procedure Call Programming Guide" Link "Remote Procedure Call Programming Guide"}).


@EndNode

@Node "Converting Local Procedures into Remote Procedures" "RPC.guide/Converting Local Procedures into Remote Procedures"
@Next "Generating XDR Routines"
@Prev "The rpcgen Protocol Compiler"
@Toc "rpcgen Programming Guide"

Converting Local Procedures into Remote Procedures
==================================================

   Assume an application that runs on a single machine, one which we
want to convert to run over the network.  Here we will demonstrate such
a conversion by way of a simple example -- a program that prints a
message to the console:

     /*
      * printmsg.c: print a message on the console
      */
     #include <stdio.h>
     
     main(argc, argv)
             int argc;
             char *argv[];
     {
             char *message;
     
             if (argc < 2) {
                     fprintf(stderr, "usage: %s <message>\n", argv[0]);
                     exit(1);
             }
             message = argv[1];
     
             if (!printmessage(message)) {
                     fprintf(stderr, "%s: couldn't print your message\n",
                             argv[0]);
                     exit(1);
             }
             printf("Message Delivered!\n");
             exit(0);
     }
     /*
      * Print a message to the console.
      * Return a boolean indicating whether the message was actually printed.
      */
     printmessage(msg)
             char *msg;
     {
             FILE *f;
     
             f = fopen("/dev/console", "w");
             if (f == NULL) {
                     return (0);
             }
             fprintf(f, "%s\n", msg);
             fclose(f);
             return(1);
     }

   And then, of course:

     example% cc printmsg.c -o printmsg
     example% printmsg "Hello, there."
     Message delivered!
     example%

   If `printmessage()' was turned into a remote procedure, then it
could be called from anywhere in the network.  Ideally, one would just
like to stick a keyword like `remote' in front of a procedure to turn
it into a remote procedure.  Unfortunately, we have to live within the
constraints of the C language, since it existed long before RPC did.
But even without language support, it's not very difficult to make a
procedure remote.

   In general, it's necessary to figure out what the types are for all
procedure inputs and outputs.  In this case, we have a procedure
`printmessage()' which takes a string as input, and returns an integer
as output.  Knowing this, we can write a protocol specification in RPC
language that describes the remote version of `printmessage()'.  Here
it is:

     /*
      * msg.x: Remote message printing protocol
      */
     program MESSAGEPROG {
             version MESSAGEVERS {
                     int PRINTMESSAGE(string) = 1;
             } = 1;
     } = 99;

   Remote procedures are part of remote programs, so we actually
declared an entire remote program here which contains the single
procedure `PRINTMESSAGE'.  This procedure was declared to be in version
1 of the remote program.  No null procedure (procedure 0) is necessary
because `rpcgen' generates it automatically.

   Notice that everything is declared with all capital letters.  This is
not required, but is a good convention to follow.

   Notice also that the argument type is `string' and not `char *'.
This is because a `char *' in C is ambiguous.  Programmers usually
intend it to mean a null-terminated string of characters, but it could
also represent a pointer to a single character or a pointer to an array
of characters.  In RPC language, a null-terminated string is
unambiguously called a `string'.

   There are just two more things to write.  First, there is the remote
procedure itself.  Here's the definition of a remote procedure to
implement the `PRINTMESSAGE' procedure we declared above:

     /*
      * msg_proc.c: implementation of the remote procedure "printmessage"
      */
     #include <stdio.h>
     #include <rpc/rpc.h>    /* always needed  */
     #include "msg.h"        /* need this too: msg.h will be generated by rpcgen */
     
     /*
      * Remote verson of "printmessage"
      */
     int *
     printmessage_1(msg)
             char **msg;
     {
             static int result;  /* must be static! */
             FILE *f;
     
             f = fopen("/dev/console", "w");
             if (f == NULL) {
                     result = 0;
                     return (&result);
             }
             fprintf(f, "%s\n", *msg);
             fclose(f);
             result = 1;
             return (&result);
     }

   Notice here that the declaration of the remote procedure
`printmessage_1()' differs from that of the local procedure
`printmessage()' in three ways:

  1. It takes a pointer to a string instead of a string itself.  This
     is true of all  remote procedures:  they always take pointers to
     their arguments rather than the arguments themselves.

  2. It returns a pointer to an  integer instead of  an integer itself.
     This is also generally true of remote procedures: they always
     return a pointer to their results.

  3. It has an `_1' appended to its name.  In general, all remote
     procedures called by `rpcgen' are named by the following rule: the
     name in the program definition (here `PRINTMESSAGE') is converted
     to all lower-case letters, an underbar (`_') is appended to it, and
     finally the version number (here `1') is appended.

   The last thing to do is declare the main client program that will
call the remote procedure. Here it is:

     /*
      * rprintmsg.c: remote version of "printmsg.c"
      */
     #include <stdio.h>
     #include <rpc/rpc.h>     /* always needed  */
     #include "msg.h"         /* need this too: msg.h will be generated by rpcgen */
     
     main(argc, argv)
             int argc;
             char *argv[];
     {
             CLIENT *cl;
             int *result;
             char *server;
             char *message;
     
             if (argc < 3) {
                     fprintf(stderr, "usage: %s host message\n", argv[0]);
                     exit(1);
             }
     
             /*
              * Save values of command line arguments
              */
             server = argv[1];
             message = argv[2];
     
             /*
              * Create client "handle" used for calling MESSAGEPROG on the
              * server designated on the command line. We tell the RPC package
              * to use the "tcp" protocol when contacting the server.
              */
             cl = clnt_create(server, MESSAGEPROG, MESSAGEVERS, "tcp");
             if (cl == NULL) {
                     /*
                      * Couldn't establish connection with server.
                      * Print error message and die.
                      */
                     clnt_pcreateerror(server);
                     exit(1);
             }
     
             /*
              * Call the remote procedure "printmessage" on the server
              */
             result = printmessage_1(&message, cl);
             if (result == NULL) {
                     /*
                      * An error occurred while calling the server.
                      * Print error message and die.
                      */
                     clnt_perror(cl, server);
                     exit(1);
             }
     
             /*
              * Okay, we successfully called the remote procedure.
              */
             if (*result == 0) {
                     /*
                      * Server was unable to print our message.
                      * Print error message and die.
                      */
                     fprintf(stderr, "%s: %s couldn't print your message\n",
                             argv[0], server);
                     exit(1);
             }
     
             /*
              * The message got printed on the server's console
              */
             printf("Message delivered to %s!\n", server);
     }

   There are two things to note here:

  1. First a "client handle" is created using the RPC library routine
     `clnt_create()'.  This client handle will be passed to the stub
     routines which call the remote procedure.

  2. The remote procedure `printmessage_1()' is called exactly the same
     way as it is declared in `msg_proc.c' except for the inserted
     client handle as the second argument.

   Here's how to put all of the pieces together:

     example% rpcgen msg.x
     example% cc rprintmsg.c msg_clnt.c -o rprintmsg
     example% cc msg_proc.c msg_svc.c -o msg_server

   Two programs were compiled here: the client program `rprintmsg' and
the server program `msg_server'.  Before doing this though, `rpcgen'
was used to fill in the missing pieces.

   Here is what `rpcgen' did with the input file `msg.x':

  1. It created a header file called `msg.h' that contained `#define''s
     for `MESSAGEPROG', `MESSAGEVERS' and `PRINTMESSAGE' for use in the
     other modules.

  2. It created client `stub' routines in the `msg_clnt.c' file.  In
     this case there is only one, the `printmessage_1()' that was
     referred to from the `printmsg' client program.  The name of the
     output file for client stub routines is always formed in this way:
     if the name of the input file is `FOO.x', the client stubs output
     file is called `FOO_clnt.c'.

  3. It created the server program which calls `printmessage_1()' in
     `msg_proc.c'.  This server program is named `msg_svc.c'.  The rule
     for naming the server output file is similar to the previous one:
     for an input file called `FOO.x', the output server file is named
     `FOO_svc.c'.

   Now we're ready to have some fun.  First, copy the server to a remote
machine and run it.  For this example, the machine is called `moon'.
Server processes are run in the background, because they never exit.

     moon% msg_server &

   Then on our local machine (`sun') we can print a message on `moon's
console.

     sun% printmsg moon "Hello, moon."

   The message will get printed to `moon's console.  You can print a
message on anybody's console (including your own) with this program if
you are able to copy the server to their machine and run it.


@EndNode

@Node "Generating XDR Routines" "RPC.guide/Generating XDR Routines"
@Next "The C-Preprocessor"
@Prev "Converting Local Procedures into Remote Procedures"
@Toc "rpcgen Programming Guide"

Generating XDR Routines
=======================

   The previous example only demonstrated the automatic generation of
client and server RPC code.  `rpcgen' may also be used to generate XDR
routines, that is, the routines necessary to convert local data
structures into network format and vice-versa.  This example presents a
complete RPC service -- a remote directory listing service, which uses
`rpcgen' not only to generate stub routines, but also to generate the
XDR routines.  Here is the protocol description file:

     /*
      * dir.x: Remote directory listing protocol
      */
     const MAXNAMELEN = 255;         /* maximum length of a directory entry */
     
     typedef string nametype<MAXNAMELEN>;    /* a directory entry */
     
     typedef struct namenode *namelist;              /* a link in the listing */
     
     /*
      * A node in the directory listing
      */
     struct namenode {
             nametype name;          /* name of directory entry */
             namelist next;          /* next entry */
     };
     
     /*
      * The result of a READDIR operation.
      */
     union readdir_res switch (int errno) {
     case 0:
             namelist list;  /* no error: return directory listing */
     default:
             void;           /* error occurred: nothing else to return */
     };
     
     /*
      * The directory program definition
      */
     program DIRPROG {
             version DIRVERS {
                     readdir_res
                     READDIR(nametype) = 1;
             } = 1;
     } = 76;

   *Note:* *Types (like `readdir_res' in the example above) can be
defined using the `struct', `union' and `enum' keywords, but those
keywords should not be used in subsequent declarations of variables of
those types.  For example, if you define a union `foo', you should
declare using only `foo' and not `union foo'.  In fact, `rpcgen'
compiles RPC unions into C structures and it is an error to declare
them using the `union' keyword.*

   Running `rpcgen' on `dir.x' creates four output files.  Three are
the same as before: header file, client stub routines and server
skeleton.  The fourth are the XDR routines necessary for converting the
data types we declared into XDR format and vice-versa.  These are output
in the file `dir_xdr.c'.

   Here is the implementation of the `READDIR' procedure.

     /*
      * dir_proc.c: remote readdir implementation
      */
     #include <rpc/rpc.h>
     #include <sys/dir.h>
     #include "dir.h"
     
     extern int errno;
     extern char *malloc();
     extern char *strdup();
     
     readdir_res *
     readdir_1(dirname)
             nametype *dirname;
     {
             DIR *dirp;
             struct direct *d;
             namelist nl;
             namelist *nlp;
             static readdir_res res; /* must be static! */
     
             /*
              * Open directory
              */
             dirp = opendir(*dirname);
             if (dirp == NULL) {
                     res.errno = errno;
                     return (&res);
             }
     
             /*
              * Free previous result
              */
             xdr_free(xdr_readdir_res, &res);
     
             /*
              * Collect directory entries.
              * Memory allocated here will be freed by `xdr_free()'
              * next time `readdir_1()' is called
              */
             nlp = &res.readdir_res_u.list;
             while (d = readdir(dirp)) {
                     nl = *nlp = (namenode *) malloc(sizeof(namenode));
                     nl->name = strdup(d->d_name);
                     nlp = &nl->next;
             }
             *nlp = NULL;
     
             /*
              * Return the result
              */
             res.errno = 0;
             closedir(dirp);
             return (&res);
     }

   Finally, there is the client side program to call the server:

     /*
      * rls.c: Remote directory listing client
      */
     #include <stdio.h>
     #include <rpc/rpc.h>    /* always need this */
     #include "dir.h"                /* will be generated by rpcgen */
     
     extern int errno;
     
     main(argc, argv)
             int argc;
             char *argv[];
     {
             CLIENT *cl;
             char *server;
             char *dir;
             readdir_res *result;
             namelist nl;
     
     
             if (argc != 3) {
                     fprintf(stderr, "usage: %s host directory\n",
                       argv[0]);
                     exit(1);
             }
     
             /*
              * Remember what our command line arguments refer to
              */
             server = argv[1];
             dir = argv[2];
     
             /*
              * Create client "handle" used for calling MESSAGEPROG on the
              * server designated on the command line. We tell the RPC package
              * to use the "tcp" protocol when contacting the server.
              */
             cl = clnt_create(server, DIRPROG, DIRVERS, "tcp");
             if (cl == NULL) {
                     /*
                      * Couldn't establish connection with server.
                      * Print error message and die.
                      */
                     clnt_pcreateerror(server);
                     exit(1);
             }
     
             /*
              * Call the remote procedure readdir on the server
              */
             result = readdir_1(&dir, cl);
             if (result == NULL) {
                     /*
                      * An error occurred while calling the server.
                      * Print error message and die.
                      */
                     clnt_perror(cl, server);
                     exit(1);
             }
     
             /*
              * Okay, we successfully called the remote procedure.
              */
             if (result->errno != 0) {
                     /*
                      * A remote system error occurred.
                      * Print error message and die.
                      */
                     errno = result->errno;
                     perror(dir);
                     exit(1);
             }
     
             /*
              * Successfully got a directory listing.
              * Print it out.
              */
             for (nl = result->readdir_res_u.list; nl != NULL;
               nl = nl->next) {
                     printf("%s\n", nl->name);
             }
             exit(0);
     }

   Compile everything, and run:

     sun%  rpcgen dir.x
     sun%  cc rls.c dir_clnt.c dir_xdr.c -o rls
     sun%  cc dir_svc.c dir_proc.c dir_xdr.c -o dir_svc
     
     sun%  dir_svc &
     moon%  rls sun /usr/pub
     .
     ..
     ascii
     eqnchar
     greek
     kbd
     marg8
     tabclr
     tabs
     tabs4
     moon%

   A final note about `rpcgen': The client program and the server
procedure can be tested together as a single program by simply linking
them with each other rather than with the client and server stubs.  The
procedure calls will be executed as ordinary local procedure calls and
the program can be debugged with a local debugger such as `dbx'.  When
the program is working, the client program can be linked to the client
stub produced by `rpcgen' and the server procedures can be linked to
the server stub produced by `rpcgen'.

   *NOTE:* *If you do this, you may want to comment out calls to RPC
library routines, and have client-side routines call server routines
directly.*


@EndNode

@Node "The C-Preprocessor" "RPC.guide/The C-Preprocessor"
@Next "rpcgen Programming Notes"
@Prev "Generating XDR Routines"
@Toc "rpcgen Programming Guide"

The C-Preprocessor
==================

   The C-preprocessor is run on all input files before they are
compiled, so all the preprocessor directives are legal within a `.x'
file.  Four symbols may be defined, depending upon which output file is
getting generated. The symbols are:
`Symbol'
     Usage

`RPC_HDR'
     for header-file output

`RPC_XDR'
     for XDR routine output

`RPC_SVC'
     for server-skeleton output

`RPC_CLNT'
     for client stub output

   Also, `rpcgen' does a little preprocessing of its own. Any line that
begins with a percent sign is passed directly into the output file,
without any interpretation of the line.  Here is a simple example that
demonstrates the preprocessing features.

     /*
      * time.x: Remote time protocol
      */
     program TIMEPROG {
             version TIMEVERS {
                     unsigned int TIMEGET(void) = 1;
             } = 1;
     } = 44;
     
     #ifdef RPC_SVC
     %int *
     %timeget_1()
     %{
     %        static int thetime;
     %
     %        thetime = time(0);
     %        return (&thetime);
     %}
     #endif

   The `%' feature is not generally recommended, as there is no
guarantee that the compiler will stick the output where you intended.


@EndNode

@Node "rpcgen Programming Notes" "RPC.guide/rpcgen Programming Notes"
@Next "RPC Language"
@Prev "The C-Preprocessor"
@Toc "rpcgen Programming Guide"

`rpcgen' Programming Notes
==========================


 @{" Timeout Changes " Link "Timeout Changes"} 
 @{" Handling Broadcast on the Server Side " Link "Handling Broadcast on the Server Side"} 
 @{" Other Information Passed to Server Procedures " Link "Other Information Passed to Server Procedures"} 


@EndNode

@Node "Timeout Changes" "RPC.guide/Timeout Changes"
@Next "Handling Broadcast on the Server Side"
@Toc "rpcgen Programming Notes"

Timeout Changes
---------------

   RPC sets a default timeout of 25 seconds for RPC calls when
`clnt_create()' is used.  This timeout may be changed using
`clnt_control()'. Here is a small code fragment to demonstrate use of
`clnt_control()':

     struct timeval tv;
     CLIENT *cl;
     
     cl = clnt_create("somehost", SOMEPROG, SOMEVERS, "tcp");
     if (cl == NULL) {
             exit(1);
     }
     tv.tv_sec = 60; /* change timeout to 1 minute */
     tv.tv_usec = 0;
     clnt_control(cl, CLSET_TIMEOUT, &tv);


@EndNode

@Node "Handling Broadcast on the Server Side" "RPC.guide/Handling Broadcast on the Server Side"
@Next "Other Information Passed to Server Procedures"
@Prev "Timeout Changes"
@Toc "rpcgen Programming Notes"

Handling Broadcast on the Server Side
-------------------------------------

   When a procedure is known to be called via broadcast RPC, it is
usually wise for the server to not reply unless it can provide some
useful information to the client.  This prevents the network from
getting flooded by useless replies.

   To prevent the server from replying, a remote procedure can return
`NULL' as its result, and the server code generated by `rpcgen' will
detect this and not send out a reply.

   Here is an example of a procedure that replies only if it thinks it
is an NFS server:

     void *
     reply_if_nfsserver()
     {
             char notnull;   /* just here so we can use its address */
     
             if (access("/etc/exports", F_OK) < 0) {
                     return (NULL);  /* prevent RPC from replying */
             }
             /*
              * return non-null pointer so RPC will send out a reply
              */
             return ((void *)&notnull);
     }

   Note that if procedure returns type `void *', they must return a
non-`NULL' pointer if they want RPC to reply for them.


@EndNode

@Node "Other Information Passed to Server Procedures" "RPC.guide/Other Information Passed to Server Procedures"
@Prev "Handling Broadcast on the Server Side"
@Toc "rpcgen Programming Notes"

Other Information Passed to Server Procedures
---------------------------------------------

   Server procedures will often want to know more about an RPC call than
just its arguments.  For example, getting authentication information is
important to procedures that want to implement some level of security.
This extra information is actually supplied to the server procedure as a
second argument.  Here is an example to demonstrate its use.  What we've
done here is rewrite the previous `printmessage_1()' procedure to only
allow root users to print a message to the console.

     int *
     printmessage_1(msg, rq)
             char **msg;
             struct svc_req  *rq;
     {
             static in result;       /* Must be static */
             FILE *f;
             struct authunix_parms *aup;
     
             aup = (struct authunix_parms *)rq->rq_clntcred;
             if (aup->aup_uid != 0) {
                     result = 0;
                     return (&result);
             }
     
             /*
              * Same code as before.
              */
     }


@EndNode

@Node "RPC Language" "RPC.guide/RPC Language"
@Prev "rpcgen Programming Notes"
@Toc "rpcgen Programming Guide"

RPC Language
============

   RPC language is an extension of XDR language.  The sole extension is
the addition of the `program' type.  For a complete description of the
XDR language syntax, See @{"XDR Protocol Specification" Link "XDR Protocol Specification"}.  For a description
of the RPC extensions to the XDR language, See
@{"Remote Procedure Calls Protocol Specification" Link "Remote Procedure Calls Protocol Specification"}.

   However, XDR language is so close to C that if you know C, you know
most of it already.  We describe here the syntax of the RPC language,
showing a few examples along the way.  We also show how the various RPC
and XDR type definitions get compiled into C type definitions in the
output header file.


 @{" Definitions " Link "Definitions"} 
 @{" Structures " Link "Structures"} 
 @{" Unions " Link "Unions"} 
 @{" Enumerations " Link "Enumerations"} 
 @{" Typedef " Link "Typedef"} 
 @{" Constants " Link "Constants"} 
 @{" Programs " Link "Programs"} 
 @{" Declarations " Link "Declarations"} 
 @{" Special Cases " Link "Special Cases"} 


@EndNode

@Node "Definitions" "RPC.guide/Definitions"
@Next "Structures"
@Toc "RPC Language"

Definitions
-----------

   An RPC language file consists of a series of definitions.

         definition-list:
             definition ";"
             definition ";" definition-list

   It recognizes five types of definitions.

         definition:
             enum-definition
             struct-definition
             union-definition
             typedef-definition
             const-definition
             program-definition


@EndNode

@Node "Structures" "RPC.guide/Structures"
@Next "Unions"
@Prev "Definitions"
@Toc "RPC Language"

Structures
----------

   An XDR struct is declared almost exactly like its C counterpart.  It
looks like the following:

         struct-definition:
             "struct" struct-ident "{"
                 declaration-list
             "}"
     
         declaration-list:
             declaration ";"
             declaration ";" declaration-list

   As an example, here is an XDR structure to a two-dimensional
coordinate, and the C structure that it gets compiled into in the
output header file.

        struct coord {             struct coord {
             int x;       -->           int x;
             int y;                     int y;
        };                         };
                                   typedef struct coord coord;

   The output is identical to the input, except for the added `typedef'
at the end of the output.  This allows one to use `coord' instead of
`struct coord' when declaring items.


@EndNode

@Node "Unions" "RPC.guide/Unions"
@Next "Enumerations"
@Prev "Structures"
@Toc "RPC Language"

Unions
------

   XDR unions are discriminated unions, and look quite different from C
unions. They are more analogous to Pascal variant records than they are
to C unions.

         union-definition:
             "union" union-ident "switch" "(" declaration ")" "{"
                 case-list
             "}"
     
         case-list:
             "case" value ":" declaration ";"
             "default" ":" declaration ";"
             "case" value ":" declaration ";" case-list

   Here is an example of a type that might be returned as the result of
a "read data" operation.  If there is no error, return a block of data.
Otherwise, don't return anything.

         union read_result switch (int errno) {
         case 0:
             opaque data[1024];
         default:
             void;
         };

   It gets compiled into the following:

         struct read_result {
             int errno;
             union {
                 char data[1024];
             } read_result_u;
         };
         typedef struct read_result read_result;

   Notice that the union component of the output struct has the name as
the type name, except for the trailing `_u'.


@EndNode

@Node "Enumerations" "RPC.guide/Enumerations"
@Next "Typedef"
@Prev "Unions"
@Toc "RPC Language"

Enumerations
------------

   XDR enumerations have the same syntax as C enumerations.

         enum-definition:
             "enum" enum-ident "{"
                 enum-value-list
             "}"
     
         enum-value-list:
             enum-value
             enum-value "," enum-value-list
     
         enum-value:
             enum-value-ident
             enum-value-ident "=" value

   Here is a short example of an XDR enum, and the C enum that it gets
compiled into.

          enum colortype {      enum colortype {
               RED = 0,              RED = 0,
               GREEN = 1,   -->      GREEN = 1,
               BLUE = 2              BLUE = 2,
          };                    };
                                typedef enum colortype colortype;


@EndNode

@Node "Typedef" "RPC.guide/Typedef"
@Next "Constants"
@Prev "Enumerations"
@Toc "RPC Language"

Typedef
-------

   XDR typedefs have the same syntax as C typedefs.

         typedef-definition:
             "typedef" declaration

   Here is an example that defines a `fname_type' used for declaring
file name strings that have a maximum length of 255 characters.

     typedef string fname_type<255>; --> typedef char *fname_type;


@EndNode

@Node "Constants" "RPC.guide/Constants"
@Next "Programs"
@Prev "Typedef"
@Toc "RPC Language"

Constants
---------

   XDR constants symbolic constants that may be used wherever a integer
constant is used, for example, in array size specifications.

         const-definition:
             "const" const-ident "=" integer

   For example, the following defines a constant `DOZEN' equal to 12.

         const DOZEN = 12;  -->  #define DOZEN 12


@EndNode

@Node "Programs" "RPC.guide/Programs"
@Next "Declarations"
@Prev "Constants"
@Toc "RPC Language"

Programs
--------

   RPC programs are declared using the following syntax:

         program-definition:
             "program" program-ident "{"
                 version-list
             "}" "=" value
     
         version-list:
             version ";"
             version ";" version-list
     
         version:
             "version" version-ident "{"
                 procedure-list
             "}" "=" value
     
         procedure-list:
             procedure ";"
             procedure ";" procedure-list
     
         procedure:
             type-ident procedure-ident "(" type-ident ")" "=" value

   For example, here is the time protocol, revisited:

     /*
      * time.x: Get or set the time. Time is represented as number of seconds
      * since 0:00, January 1, 1970.
      */
     program TIMEPROG {
         version TIMEVERS {
             unsigned int TIMEGET(void) = 1;
             void TIMESET(unsigned) = 2;
         } = 1;
     } = 44;

   This file compiles into `#defines' in the output header file:

     #define TIMEPROG 44
     #define TIMEVERS 1
     #define TIMEGET 1
     #define TIMESET 2


@EndNode

@Node "Declarations" "RPC.guide/Declarations"
@Next "Special Cases"
@Prev "Programs"
@Toc "RPC Language"

Declarations
------------

   In XDR, there are only four kinds of declarations.

         declaration:
             simple-declaration
             fixed-array-declaration
             variable-array-declaration
             pointer-declaration


 @{" Simple Declarations " Link "Simple Declarations"} 
 @{" Fixed-Length Array Declarations " Link "Fixed-Length Array Declarations"} 
 @{" Variable-Length Array Declarations " Link "Variable-Length Array Declarations"} 
 @{" Pointer Declarations " Link "Pointer Declarations"} 


@EndNode

@Node "Simple Declarations" "RPC.guide/Simple Declarations"
@Next "Fixed-Length Array Declarations"
@Toc "Declarations"

Simple Declarations
...................

   Simple declarations are just like simple C declarations.

         simple-declaration:
             type-ident variable-ident

   Example:

         colortype color;    --> colortype color;


@EndNode

@Node "Fixed-Length Array Declarations" "RPC.guide/Fixed-Length Array Declarations"
@Next "Variable-Length Array Declarations"
@Prev "Simple Declarations"
@Toc "Declarations"

Fixed-Length Array Declarations
...............................

   Fixed-length array declarations are just like C array declarations:

         fixed-array-declaration:
             type-ident variable-ident "[" value "]"

   Example:

         colortype palette[8];    --> colortype palette[8];


@EndNode

@Node "Variable-Length Array Declarations" "RPC.guide/Variable-Length Array Declarations"
@Next "Pointer Declarations"
@Prev "Fixed-Length Array Declarations"
@Toc "Declarations"

Variable-Length Array Declarations
..................................

   Variable-length array declarations have no explicit syntax in C, so
XDR invents its own using angle-brackets.

     variable-array-declaration:
         type-ident variable-ident "<" value ">"
         type-ident variable-ident "<" ">"

   The maximum size is specified between the angle brackets. The size
may be omitted, indicating that the array may be of any size.

         int heights<12>;    /* at most 12 items */
         int widths<>;       /* any number of items */

   Since variable-length arrays have no explicit syntax in C, these
declarations are actually compiled into `struct's.  For example, the
`heights' declaration gets compiled into the following struct:

         struct {
             u_int heights_len;  /* # of items in array */
             int *heights_val;   /* pointer to array */
         } heights;

   Note that the number of items in the array is stored in the `_len'
component and the pointer to the array is stored in the `_val'
component. The first part of each of these component's names is the same
as the name of the declared XDR variable.


@EndNode

@Node "Pointer Declarations" "RPC.guide/Pointer Declarations"
@Prev "Variable-Length Array Declarations"
@Toc "Declarations"

Pointer Declarations
....................

   Pointer declarations are made in XDR exactly as they are in C.  You
can't really send pointers over the network, but you can use XDR
pointers for sending recursive data types such as lists and trees.  The
type is actually called `optional-data', not `pointer', in XDR language.

         pointer-declaration:
             type-ident "*" variable-ident

   Example:

         listitem *next;  -->  listitem *next;


@EndNode

@Node "Special Cases" "RPC.guide/Special Cases"
@Prev "Declarations"
@Toc "RPC Language"

Special Cases
-------------

   There are a few exceptions to the rules described above.


 @{" XDR Booleans " Link "XDR Booleans"} 
 @{" XDR Strings " Link "XDR Strings"} 
 @{" XDR Opaque Data " Link "XDR Opaque Data"} 
 @{" XDR Voids " Link "XDR Voids"} 


@EndNode

@Node "XDR Booleans" "RPC.guide/XDR Booleans"
@Next "XDR Strings"
@Toc "Special Cases"

Booleans
........

   C has no built-in boolean type. However, the RPC library does a
boolean type called `bool_t' that is either `TRUE' or `FALSE'.  Things
declared as type `bool' in XDR language are compiled into `bool_t' in
the output header file.

   Example:

         bool married;  -->  bool_t married;


@EndNode

@Node "XDR Strings" "RPC.guide/XDR Strings"
@Next "XDR Opaque Data"
@Prev "XDR Booleans"
@Toc "Special Cases"

Strings
.......

   C has no built-in string type, but instead uses the null-terminated
`char *' convention.  In XDR language, strings are declared using the
`string' keyword, and compiled into `char *'s in the output header
file. The maximum size contained in the angle brackets specifies the
maximum number of characters allowed in the strings (not counting the
`NULL' character). The maximum size may be left off, indicating a
string of arbitrary length.

   Examples:

         string name<32>;    -->  char *name;
         string longname<>;  -->  char *longname;


@EndNode

@Node "XDR Opaque Data" "RPC.guide/XDR Opaque Data"
@Next "XDR Voids"
@Prev "XDR Strings"
@Toc "Special Cases"

Opaque Data
...........

   Opaque data is used in RPC and XDR to describe untyped data, that is,
just sequences of arbitrary bytes.  It may be declared either as a fixed
or variable length array.

   Examples:

         opaque diskblock[512];  -->  char diskblock[512];
     
         opaque filedata<1024>;  -->  struct {
                                         u_int filedata_len;
                                         char *filedata_val;
                                      } filedata;


@EndNode

@Node "XDR Voids" "RPC.guide/XDR Voids"
@Prev "XDR Opaque Data"
@Toc "Special Cases"

Voids
.....

   In a void declaration, the variable is not named.  The declaration is
just `void' and nothing else.  Void declarations can only occur in two
places: union definitions and program definitions (as the argument or
result of a remote procedure).


@EndNode

@Node "Remote Procedure Call Programming Guide" "RPC.guide/Remote Procedure Call Programming Guide"
@Next "XDR Technical Notes"
@Prev "rpcgen Programming Guide"
@Toc "Main"

Remote Procedure Call Programming Guide
***************************************


 @{" Introduction to RPC Programming Guide " Link "Introduction to RPC Programming Guide"} 
 @{" Layers of RPC " Link "Layers of RPC"} 
 @{" Higher Layers of RPC " Link "Higher Layers of RPC"} 
 @{" Lowest Layer of RPC " Link "Lowest Layer of RPC"} 
 @{" Other RPC Features " Link "Other RPC Features"} 
 @{" More Examples " Link "More Examples"} 


@EndNode

@Node "Introduction to RPC Programming Guide" "RPC.guide/Introduction to RPC Programming Guide"
@Next "Layers of RPC"
@Toc "Remote Procedure Call Programming Guide"

Introduction to RPC Programming Guide
=====================================

   This document assumes a working knowledge of network theory.  It is
intended for programmers who wish to write network applications using
remote procedure calls (explained below), and who want to understand the
RPC mechanisms usually hidden by the `rpcgen' protocol compiler.
`rpcgen' is described in detail in the previous chapter, the
@{"rpcgen Programming Guide" Link "rpcgen Programming Guide"}.  *Note:* *Before attempting to write a
network application, or to convert an existing non-network application
to run over the network, you may want to understand the material in
this chapter.  However, for most applications, you can circumvent the
need to cope with the details presented here by using `rpcgen'.
@{"Generating XDR Routines" Link "Generating XDR Routines"} contains the complete source for a working RPC
service -- a remote directory listing service which uses `rpcgen' to
generate XDR routines as well as client and server stubs.*

   What are remote procedure calls?  Simply put, they are the high-level
communications paradigm used in the operating system.  RPC presumes the
existence of low-level networking mechanisms (such as TCP/IP and
UDP/IP), and upon them it implements a logical client to server
communications system designed specifically for the support of network
applications.  With RPC, the client makes a procedure call to send a
data packet to the server.  When the packet arrives, the server calls a
dispatch routine, performs whatever service is requested, sends back the
reply, and the procedure call returns to the client.


@EndNode

@Node "Layers of RPC" "RPC.guide/Layers of RPC"
@Next "Higher Layers of RPC"
@Prev "Introduction to RPC Programming Guide"
@Toc "Remote Procedure Call Programming Guide"

Layers of RPC
=============

   The RPC interface can be seen as being divided into three layers.
(1)


 @{" The Highest Layer " Link "The Highest Layer"} 
 @{" The Middle Layer " Link "The Middle Layer"} 
 @{" The Lowest Layer " Link "The Lowest Layer"} 
 @{" The RPC Paradigm " Link "The RPC Paradigm"} 

   ---------- Footnotes ----------

   (1)  For a complete specification of the routines in the remote
procedure call Library, see the `rpc(3N)' manual page.


@EndNode

@Node "The Highest Layer" "RPC.guide/The Highest Layer"
@Next "The Middle Layer"
@Toc "Layers of RPC"

The Highest Layer
-----------------

   The highest layer is totally transparent to the operating system,
machine and network upon which is is run.  It's probably best to think
of this level as a way of *using* RPC, rather than as a *part of* RPC
proper.  Programmers who write RPC routines should (almost) always make
this layer available to others by way of a simple C front end that
entirely hides the networking.

   To illustrate, at this level a program can simply make a call to
`rnusers()', a C routine which returns the number of users on a remote
machine.  The user is not explicitly aware of using RPC -- they simply
call a procedure, just as they would call `malloc()'.


@EndNode

@Node "The Middle Layer" "RPC.guide/The Middle Layer"
@Next "The Lowest Layer"
@Prev "The Highest Layer"
@Toc "Layers of RPC"

The Middle Layer
----------------

   The middle layer is really "RPC proper."  Here, the user doesn't need
to consider details about sockets, the UNIX system, or other low-level
implementation mechanisms.  They simply make remote procedure calls to
routines on other machines.  The selling point here is simplicity.  It's
this layer that allows RPC to pass the "hello world" test -- simple
things should be simple.  The middle-layer routines are used for most
applications.

   RPC calls are made with the system routines `registerrpc()'
`callrpc()' and `svc_run()'.  The first two of these are the most
fundamental: `registerrpc()' obtains a unique system-wide
procedure-identification number, and `callrpc()' actually executes a
remote procedure call.  At the middle level, a call to `rnusers()' is
implemented by way of these two routines.

   The middle layer is unfortunately rarely used in serious programming
due to its inflexibility (simplicity).  It does not allow timeout
specifications or the choice of transport.  It allows no UNIX process
control or flexibility in case of errors.  It doesn't support multiple
kinds of call authentication.  The programmer rarely needs all these
kinds of control, but one or two of them is often necessary.


@EndNode

@Node "The Lowest Layer" "RPC.guide/The Lowest Layer"
@Next "The RPC Paradigm"
@Prev "The Middle Layer"
@Toc "Layers of RPC"

The Lowest Layer
----------------

   The lowest layer does allow these details to be controlled by the
programmer, and for that reason it is often necessary.  Programs written
at this level are also most efficient, but this is rarely a real issue
-- since RPC clients and servers rarely generate heavy network loads.

   Although this document only discusses the interface to C, remote
procedure calls can be made from any language.  Even though this
document discusses RPC when it is used to communicate between processes
on different machines, it works just as well for communication between
different processes on the same machine.


@EndNode

@Node "The RPC Paradigm" "RPC.guide/The RPC Paradigm"
@Prev "The Lowest Layer"
@Toc "Layers of RPC"

The RPC Paradigm
----------------

   Here is a diagram of the RPC paradigm:

                              .
      Machine A               .                     Machine B
                              .
       client |               .      service :
      program |               .       daemon :
              |               .              :
              V  callrpc()    .              :
              ------------------------------>|
              :  function     .              |
              :               .      execute |
              :               .      request |
              :               .              V   call
              :               .              ----------->|
              :               .              :  service  |
              :               .              :           | service
              :               .              :           | executes
              :               .              :  return   V
              :               .              |<-----------
              :               .      request |  answer
              :               .    completed |
              :   return      .              V
              |<------------------------------
              |   reply       .              :
      program |               .              :
     continues|               .              :
              V               .              V
                              .

   *Figure 1:* Network Communication with the Remote Procedure Call


@EndNode

@Node "Higher Layers of RPC" "RPC.guide/Higher Layers of RPC"
@Next "Lowest Layer of RPC"
@Prev "Layers of RPC"
@Toc "Remote Procedure Call Programming Guide"

Higher Layers of RPC
====================


 @{" Highest Layer " Link "Highest Layer"} 
 @{" Intermediate Layer " Link "Intermediate Layer"} 
 @{" Assigning Program Numbers " Link "Assigning Program Numbers"} 
 @{" Passing Arbitrary Data Types " Link "Passing Arbitrary Data Types"} 


@EndNode

@Node "Highest Layer" "RPC.guide/Highest Layer"
@Next "Intermediate Layer"
@Toc "Higher Layers of RPC"

Highest Layer
-------------

   Imagine you're writing a program that needs to know how many users
are logged into a remote machine.  You can do this by calling the RPC
library routine `rnusers()' as illustrated below:

     #include <stdio.h>
     
     main(argc, argv)
         int argc;
         char **argv;
     {
         int num;
     
         if (argc != 2) {
             fprintf(stderr, "usage: rnusers hostname\n");
             exit(1);
         }
         if ((num = rnusers(argv[1])) < 0) {
             fprintf(stderr, "error: rnusers\n");
             exit(-1);
         }
         printf("%d users on %s\n", num, argv[1]);
         exit(0);
     }

   RPC library routines such as `rnusers()' are in the RPC services
library `librpcsvc.a' Thus, the program above should be compiled with:

     % cc program.c -lrpcsvc

   `rnusers()', like the other RPC library routines, is documented in
section 3R of the `System Interface Manual for the Sun Workstation',
the same section which documents the standard Sun RPC services.  See
the `intro(3R)' manual page for an explanation of the documentation
strategy for these services and their RPC protocols.

   Here are some of the RPC service library routines available to the C
programmer:

`Routine'
     Description

`rnusers()'
     Return number of users on remote machine

`rusers()'
     Return information about users on remote machine

`havedisk()'
     Determine if remote machine has disk

`rstats()'
     Get performance data from remote kernel

`rwall()'
     Write to specified remote machines

`yppasswd()'
     Update user password in Yellow Pages

   *Table 1* RPC Service Library Routines

   Other RPC services -- for example `ether()' `mount()' `rquota()' and
`spray()'  -- are not available to the C programmer as library
routines.  They do, however, have RPC program numbers so they can be
invoked with `callrpc()' which will be discussed in the next section.
Most of them also have compilable `rpcgen' protocol description files.
(The `rpcgen' protocol compiler radically simplifies the process of
developing network applications.  see @{"rpcgen Programming Guide" Link "rpcgen Programming Guide"} for
detailed information about `rpcgen' and `rpcgen' protocol description
files).


@EndNode

@Node "Intermediate Layer" "RPC.guide/Intermediate Layer"
@Next "Assigning Program Numbers"
@Prev "Highest Layer"
@Toc "Higher Layers of RPC"

Intermediate Layer
------------------

   The simplest interface, which explicitly makes RPC calls, uses the
functions `callrpc()' and `registerrpc()' Using this method, the number
of remote users can be gotten as follows:

     #include <stdio.h>
     #include <rpc/rpc.h>
     #include <utmp.h>
     #include <rpcsvc/rusers.h>
     
     main(argc, argv)
         int argc;
         char **argv;
     {
         unsigned long nusers;
         int stat;
     
         if (argc != 2) {
             fprintf(stderr, "usage: nusers hostname\n");
             exit(-1);
         }
         if (stat = callrpc(argv[1],
           RUSERSPROG, RUSERSVERS, RUSERSPROC_NUM,
           xdr_void, 0, xdr_u_long, &nusers) != 0) {
             clnt_perrno(stat);
             exit(1);
         }
         printf("%d users on %s\n", nusers, argv[1]);
         exit(0);
     }

   Each RPC procedure is uniquely defined by a program number, version
number, and procedure number.  The program number specifies a group of
related remote procedures, each of which has a different procedure
number.  Each program also has a version number, so when a minor change
is made to a remote service (adding a new procedure, for example), a new
program number doesn't have to be assigned.  When you want to call a
procedure to find the number of remote users, you look up the
appropriate program, version and procedure numbers in a manual, just as
you look up the name of a memory allocator when you want to allocate
memory.

   The simplest way of making remote procedure calls is with the the RPC
library routine `callrpc()' It has eight parameters.  The first is the
name of the remote server machine.  The next three parameters are the
program, version, and procedure numbers -- together they identify the
procedure to be called.  The fifth and sixth parameters are an XDR
filter and an argument to be encoded and passed to the remote procedure.
The final two parameters are a filter for decoding the results returned
by the remote procedure and a pointer to the place where the procedure's
results are to be stored.  Multiple arguments and results are handled by
embedding them in structures.  If `callrpc()' completes successfully,
it returns zero; else it returns a nonzero value.  The return codes (of
type cast into an integer) are found in `<rpc/clnt.h>'.

   Since data types may be represented differently on different
machines, `callrpc()' needs both the type of the RPC argument, as well
as a pointer to the argument itself (and similarly for the result).  For
`RUSERSPROC_NUM', the return value is an `unsigned long' so `callrpc()'
has `xdr_u_long()' as its first return parameter, which says that the
result is of type `unsigned long' and `&nusers' as its second return
parameter, which is a pointer to where the long result will be placed.
Since `RUSERSPROC_NUM' takes no argument, the argument parameter of
`callrpc()' is `xdr_void()'.

   After trying several times to deliver a message, if `callrpc()' gets
no answer, it returns with an error code.  The delivery mechanism is
UDP, which stands for User Datagram Protocol.  Methods for adjusting
the number of retries or for using a different protocol require you to
use the lower layer of the RPC library, discussed later in this
document.  The remote server procedure corresponding to the above might
look like this:

     char *
     nuser(indata)
         char *indata;
     {
         unsigned long nusers;
     
         /*
          * Code here to compute the number of users
          * and place result in variable nusers.
          */
         return((char *)&nusers);
     }

   It takes one argument, which is a pointer to the input of the remote
procedure call (ignored in our example), and it returns a pointer to the
result.  In the current version of C, character pointers are the generic
pointers, so both the input argument and the return value are cast to
`char *'.

   Normally, a server registers all of the RPC calls it plans to handle,
and then goes into an infinite loop waiting to service requests.  In
this example, there is only a single procedure to register, so the main
body of the server would look like this:

     #include <stdio.h>
     #include <rpc/rpc.h>
     #include <utmp.h>
     #include <rpcsvc/rusers.h>
     
     char *nuser();
     
     main()
     {
         registerrpc(RUSERSPROG, RUSERSVERS, RUSERSPROC_NUM,
             nuser, xdr_void, xdr_u_long);
         svc_run();      /* Never returns */
         fprintf(stderr, "Error: svc_run returned!\n");
         exit(1);
     }

   The `registerrpc()' routine registers a C procedure as corresponding
to a given RPC procedure number.  The first three parameters,
`RUSERPROG', `RUSERSVERS', and `RUSERSPROC_NUM' are the program,
version, and procedure numbers of the remote procedure to be
registered; `nuser()' is the name of the local procedure that
implements the remote procedure; and `xdr_void()' and `xdr_u_long()'
are the XDR filters for the remote procedure's arguments and results,
respectively.  (Multiple arguments or multiple results are passed as
structures).

   Only the UDP transport mechanism can use `registerrpc()' thus, it is
always safe in conjunction with calls generated by `callrpc()'.

   *Warning: the UDP transport mechanism can only deal with arguments
and results less than 8K bytes in length.*

   After registering the local procedure, the server program's main
procedure calls `svc_run()', the RPC library's remote procedure
dispatcher.  It is this function that calls the remote procedures in
response to RPC call messages.  Note that the dispatcher takes care of
decoding remote procedure arguments and encoding results, using the XDR
filters specified when the remote procedure was registered.


@EndNode

@Node "Assigning Program Numbers" "RPC.guide/Assigning Program Numbers"
@Next "Passing Arbitrary Data Types"
@Prev "Intermediate Layer"
@Toc "Higher Layers of RPC"

Assigning Program Numbers
-------------------------

   Program numbers are assigned in groups of `0x20000000' according to
the following chart:

            0x0 - 0x1fffffff Defined by Sun
     0x20000000 - 0x3fffffff Defined by user
     0x40000000 - 0x5fffffff Transient
     0x60000000 - 0x7fffffff Reserved
     0x80000000 - 0x9fffffff Reserved
     0xa0000000 - 0xbfffffff Reserved
     0xc0000000 - 0xdfffffff Reserved
     0xe0000000 - 0xffffffff Reserved

   Sun Microsystems administers the first group of numbers, which
should be identical for all Sun customers.  If a customer develops an
application that might be of general interest, that application should
be given an assigned number in the first range.  The second group of
numbers is reserved for specific customer applications.  This range is
intended primarily for debugging new programs.  The third group is
reserved for applications that generate program numbers dynamically.
The final groups are reserved for future use, and should not be used.

   To register a protocol specification, send a request by network mail
to `rpc@sun' or write to:

     RPC Administrator
     Sun Microsystems
     2550 Garcia Ave.
     Mountain View, CA 94043

   Please include a compilable `rpcgen' `.x' file describing your
protocol.  You will be given a unique program number in return.

   The RPC program numbers and protocol specifications of standard Sun
RPC services can be found in the include files in
`/usr/include/rpcsvc'.  These services, however, constitute only a
small subset of those which have been registered.  The complete list of
registered programs, as of the time when this manual was printed, is:

     100000  PMAPPROG            portmapper
     100001  RSTATPROG           remote stats
     100002  RUSERSPROG          remote users
     100003  NFSPROG             nfs
     100004  YPPROG              Yellow Pages
     100005  MOUNTPROG           mount demon
     100006  DBXPROG             remote dbx
     100007  YPBINDPROG          yp binder
     100008  WALLPROG            shutdown msg
     100009  YPPASSWDPROG        yppasswd server
     100010  ETHERSTATPROG       ether stats
     100011  RQUOTAPROG          disk quotas
     100012  SPRAYPROG           spray packets
     100013  IBM3270PROG         3270 mapper
     100014  IBMRJEPROG          RJE mapper
     100015  SELNSVCPROG         selection service
     100016  RDATABASEPROG       remote database access
     100017  REXECPROG           remote execution
     100018  ALICEPROG           Alice Office Automation
     100019  SCHEDPROG           scheduling service
     100020  LOCKPROG            local lock manager
     100021  NETLOCKPROG         network lock manager
     100022  X25PROG             x.25 inr protocol
     100023  STATMON1PROG        status monitor 1
     100024  STATMON2PROG        status monitor 2
     100025  SELNLIBPROG         selection library
     100026  BOOTPARAMPROG       boot parameters service
     100027  MAZEPROG            mazewars game
     100028  YPUPDATEPROG        yp update
     100029  KEYSERVEPROG        key server
     100030  SECURECMDPROG       secure login
     100031  NETFWDIPROG         nfs net forwarder init
     100032  NETFWDTPROG         nfs net forwarder trans
     100033  SUNLINKMAP_PROG     sunlink MAP
     100034  NETMONPROG          network monitor
     100035  DBASEPROG           lightweight database
     100036  PWDAUTHPROG         password authorization
     100037  TFSPROG             translucent file svc
     100038  NSEPROG             nse server
     100039  NSE_ACTIVATE_PROG   nse activate daemon
     
     150001  PCNFSDPROG          pc passwd authorization
     
     200000  PYRAMIDLOCKINGPROG  Pyramid-locking
     200001  PYRAMIDSYS5         Pyramid-sys5
     200002  CADDS_IMAGE         CV cadds_image
     
     300001  ADT_RFLOCKPROG      ADT file locking

   *Table 2:* RPC Registered Programs


@EndNode

@Node "Passing Arbitrary Data Types" "RPC.guide/Passing Arbitrary Data Types"
@Prev "Assigning Program Numbers"
@Toc "Higher Layers of RPC"

Passing Arbitrary Data Types
----------------------------

   In the previous example, the RPC call passes a single `unsigned
long' RPC can handle arbitrary data structures, regardless of different
machines' byte orders or structure layout conventions, by always
converting them to a network standard called "External Data
Representation" (XDR) before sending them over the wire.  The process of
converting from a particular machine representation to XDR format is
called *serializing*, and the reverse process is called
*deserializing*.  The type field parameters of `callrpc()' and
`registerrpc()' can be a built-in procedure like `xdr_u_long()' in the
previous example, or a user supplied one.  XDR has these built-in type
routines:

`xdr_int()'
`xdr_u_int()'
`xdr_enum()'
`xdr_long()'
`xdr_u_long()'
`xdr_bool()'
`xdr_short()'
`xdr_u_short()'
`xdr_wrapstring()'
`xdr_char()'
`xdr_u_char()'
   Note that the routine `xdr_string()' exists, but cannot be used with
`callrpc()' and `registerrpc()', which only pass two parameters to
their XDR routines.  `xdr_wrapstring()' has only two parameters, and is
thus OK.  It calls `xdr_string()'.

   As an example of a user-defined type routine, if you wanted to send
the structure

     struct simple {
         int a;
         short b;
     } simple;

   then you would call `callrpc()' as

     callrpc(hostname, PROGNUM, VERSNUM, PROCNUM,
             xdr_simple, &simple ...);

   where `xdr_simple()' is written as:

     #include <rpc/rpc.h>
     
     xdr_simple(xdrsp, simplep)
         XDR *xdrsp;
         struct simple *simplep;
     {
         if (!xdr_int(xdrsp, &simplep->a))
             return (0);
         if (!xdr_short(xdrsp, &simplep->b))
             return (0);
         return (1);
     }

   An XDR routine returns nonzero (true in the sense of C) if it
completes successfully, and zero otherwise.  A complete description of
XDR is in the @{"XDR Protocol Specification" Link "XDR Protocol Specification"}, only few implementation
examples are given here.

   In addition to the built-in primitives, there are also the
prefabricated building blocks:

`xdr_array()'
`xdr_bytes()'
`xdr_reference()'
`xdr_vector()'
`xdr_union()'
`xdr_pointer()'
`xdr_string()'
`xdr_opaque()'
   To send a variable array of integers, you might package them up as a
structure like this

     struct varintarr {
         int *data;
         int arrlnth;
     } arr;

   and make an RPC call such as

     callrpc(hostname, PROGNUM, VERSNUM, PROCNUM,
             xdr_varintarr, &arr...);

   with `xdr_varintarr()' defined as:

     xdr_varintarr(xdrsp, arrp)
         XDR *xdrsp;
         struct varintarr *arrp;
     {
         return (xdr_array(xdrsp, &arrp->data, &arrp->arrlnth,
             MAXLEN, sizeof(int), xdr_int));
     }

   This routine takes as parameters the XDR handle, a pointer to the
array, a pointer to the size of the array, the maximum allowable array
size, the size of each array element, and an XDR routine for handling
each array element.

   If the size of the array is known in advance, one can use
`xdr_vector()', which serializes fixed-length arrays.

     int intarr[SIZE];
     
     xdr_intarr(xdrsp, intarr)
         XDR *xdrsp;
         int intarr[];
     {
         int i;
     
         return (xdr_vector(xdrsp, intarr, SIZE, sizeof(int),
             xdr_int));
     }

   XDR always converts quantities to 4-byte multiples when serializing.
Thus, if either of the examples above involved characters instead of
integers, each character would occupy 32 bits.  That is the reason for
the XDR routine `xdr_bytes()' which is like `xdr_array()' except that
it packs characters; `xdr_bytes()' has four parameters, similar to the
first four parameters of `xdr_array()'.  For null-terminated strings,
there is also the `xdr_string()' routine, which is the same as
`xdr_bytes()' without the length parameter.  On serializing it gets the
string length from `strlen()', and on deserializing it creates a
null-terminated string.

   Here is a final example that calls the previously written
`xdr_simple()' as well as the built-in functions `xdr_string()' and
`xdr_reference()', which chases pointers:

     struct finalexample {
         char *string;
         struct simple *simplep;
     } finalexample;
     
     xdr_finalexample(xdrsp, finalp)
         XDR *xdrsp;
         struct finalexample *finalp;
     {
     
         if (!xdr_string(xdrsp, &finalp->string, MAXSTRLEN))
             return (0);
         if (!xdr_reference(xdrsp, &finalp->simplep,
           sizeof(struct simple), xdr_simple);
             return (0);
         return (1);
     }

   Note that we could as easily call `xdr_simple()' here instead of
`xdr_reference()'.


@EndNode

@Node "Lowest Layer of RPC" "RPC.guide/Lowest Layer of RPC"
@Next "Other RPC Features"
@Prev "Higher Layers of RPC"
@Toc "Remote Procedure Call Programming Guide"

Lowest Layer of RPC
===================

   In the examples given so far, RPC takes care of many details
automatically for you.  In this section, we'll show you how you can
change the defaults by using lower layers of the RPC library.  It is
assumed that you are familiar with sockets and the system calls for
dealing with them.


 @{" More on the Server Side " Link "More on the Server Side"} 
 @{" Memory Allocation with XDR " Link "Memory Allocation with XDR"} 
 @{" The Calling Side " Link "The Calling Side"} 

   There are several occasions when you may need to use lower layers of
RPC.  First, you may need to use TCP, since the higher layer uses UDP,
which restricts RPC calls to 8K bytes of data.  Using TCP permits calls
to send long streams of data.  For an example, see the @{"TCP" Link "TCP"}.  Second,
you may want to allocate and free memory while serializing or
deserializing with XDR routines.  There is no call at the higher level
to let you free memory explicitly.  For more explanation, see the
@{"Memory Allocation with XDR" Link "Memory Allocation with XDR"}.

   Third, you may need to perform authentication on either the client or
server side, by supplying credentials or verifying them.  See the
explanation in the @{"Authentication" Link "Authentication"}.


@EndNode

@Node "More on the Server Side" "RPC.guide/More on the Server Side"
@Next "Memory Allocation with XDR"
@Toc "Lowest Layer of RPC"

More on the Server Side
-----------------------

   The server for the `nusers()' program shown below does the same
thing as the one using `registerrpc()' above, but is written using a
lower layer of the RPC package:

     #include <stdio.h>
     #include <rpc/rpc.h>
     #include <utmp.h>
     #include <rpcsvc/rusers.h>
     
     main()
     {
         SVCXPRT *transp;
         int nuser();
     
         transp = svcudp_create(RPC_ANYSOCK);
         if (transp == NULL){
             fprintf(stderr, "can't create an RPC server\n");
             exit(1);
         }
         pmap_unset(RUSERSPROG, RUSERSVERS);
         if (!svc_register(transp, RUSERSPROG, RUSERSVERS,
                   nuser, IPPROTO_UDP)) {
             fprintf(stderr, "can't register RUSER service\n");
             exit(1);
         }
         svc_run();  /* Never returns */
         fprintf(stderr, "should never reach this point\n");
     }
     
     nuser(rqstp, transp)
         struct svc_req *rqstp;
         SVCXPRT *transp;
     {
         unsigned long nusers;
     
         switch (rqstp->rq_proc) {
         case NULLPROC:
             if (!svc_sendreply(transp, xdr_void, 0))
                 fprintf(stderr, "can't reply to RPC call\n");
             return;
         case RUSERSPROC_NUM:
             /*
              * Code here to compute the number of users
              * and assign it to the variable `nusers'
              */
             if (!svc_sendreply(transp, xdr_u_long, &nusers))
                 fprintf(stderr, "can't reply to RPC call\n");
             return;
         default:
             svcerr_noproc(transp);
             return;
         }
     }

   First, the server gets a transport handle, which is used for
receiving and replying to RPC messages.  `registerrpc()' uses
`svcudp_create()' to get a UDP handle.  If you require a more reliable
protocol, call `svctcp_create()' instead.  If the argument to
`svcudp_create()' is `RPC_ANYSOCK' the RPC library creates a socket on
which to receive and reply to RPC calls.  Otherwise, `svcudp_create()'
expects its argument to be a valid socket number.  If you specify your
own socket, it can be bound or unbound.  If it is bound to a port by
the user, the port numbers of `svcudp_create()' and `clnttcp_create()'
(the low-level client routine) must match.

   If the user specifies the `RPC_ANYSOCK' argument, the RPC library
routines will open sockets.  Otherwise they will expect the user to do
so.  The routines `svcudp_create()' and `clntudp_create()' will cause
the RPC library routines to `bind()' their socket if it is not bound
already.

   A service may choose to register its port number with the local
portmapper service.  This is done is done by specifying a non-zero
protocol number in `svc_register()'.  Incidently, a client can discover
the server's port number by consulting the portmapper on their server's
machine.  This can be done automatically by specifying a zero port
number in `clntudp_create()' or `clnttcp_create()'.

   After creating an `SVCXPRT', the next step is to call `pmap_unset()'
so that if the `nusers()' server crashed earlier, any previous trace of
it is erased before restarting.  More precisely, `pmap_unset()' erases
the entry for `RUSERSPROG' from the port mapper's tables.

   Finally, we associate the program number for `nusers()' with the
procedure `nuser()'.  The final argument to `svc_register()' is
normally the protocol being used, which, in this case, is `IPPROTO_UDP'
Notice that unlike `registerrpc()', there are no XDR routines involved
in the registration process.  Also, registration is done on the
program, rather than procedure, level.

   The user routine `nuser()' must call and dispatch the appropriate
XDR routines based on the procedure number.  Note that two things are
handled by `nuser()' that `registerrpc()' handles automatically.  The
first is that procedure `NULLPROC' (currently zero) returns with no
results.  This can be used as a simple test for detecting if a remote
program is running.  Second, there is a check for invalid procedure
numbers.  If one is detected, `svcerr_noproc()' is called to handle the
error.

   The user service routine serializes the results and returns them to
the RPC caller via `svc_sendreply()' Its first parameter is the
`SVCXPRT' handle, the second is the XDR routine, and the third is a
pointer to the data to be returned.  Not illustrated above is how a
server handles an RPC program that receives data.  As an example, we can
add a procedure `RUSERSPROC_BOOL' which has an argument `nusers()', and
returns `TRUE' or `FALSE' depending on whether there are nusers logged
on.  It would look like this:

     case RUSERSPROC_BOOL: {
         int bool;
         unsigned nuserquery;
     
         if (!svc_getargs(transp, xdr_u_int, &nuserquery) {
             svcerr_decode(transp);
             return;
         }
         /*
          * Code to set `nusers' = number of users
          */
         if (nuserquery == nusers)
             bool = TRUE;
         else
             bool = FALSE;
         if (!svc_sendreply(transp, xdr_bool, &bool)) {
              fprintf(stderr, "can't reply to RPC call\n");
              return (1);
         }
         return;
     }

   The relevant routine is `svc_getargs()' which takes an `SVCXPRT'
handle, the XDR routine, and a pointer to where the input is to be
placed as arguments.


@EndNode

@Node "Memory Allocation with XDR" "RPC.guide/Memory Allocation with XDR"
@Next "The Calling Side"
@Prev "More on the Server Side"
@Toc "Lowest Layer of RPC"

Memory Allocation with XDR
--------------------------

   XDR routines not only do input and output, they also do memory
allocation.  This is why the second parameter of `xdr_array()' is a
pointer to an array, rather than the array itself.  If it is `NULL',
then `xdr_array()' allocates space for the array and returns a pointer
to it, putting the size of the array in the third argument.  As an
example, consider the following XDR routine `xdr_chararr1()' which
deals with a fixed array of bytes with length `SIZE'.

     xdr_chararr1(xdrsp, chararr)
         XDR *xdrsp;
         char chararr[];
     {
         char *p;
         int len;
     
         p = chararr;
         len = SIZE;
         return (xdr_bytes(xdrsp, &p, &len, SIZE));
     }

   If space has already been allocated in `chararr', it can be called
from a server like this:

     char chararr[SIZE];
     
     svc_getargs(transp, xdr_chararr1, chararr);

   If you want XDR to do the allocation, you would have to rewrite this
routine in the following way:

     xdr_chararr2(xdrsp, chararrp)
         XDR *xdrsp;
         char **chararrp;
     {
         int len;
     
         len = SIZE;
         return (xdr_bytes(xdrsp, charrarrp, &len, SIZE));
     }

   Then the RPC call might look like this:

     char *arrptr;
     
     arrptr = NULL;
     svc_getargs(transp, xdr_chararr2, &arrptr);
     /*
      * Use the result here
      */
     svc_freeargs(transp, xdr_chararr2, &arrptr);

   Note that, after being used, the character array can be freed with
`svc_freeargs()'. `svc_freeargs()' will not attempt to free any memory
if the variable indicating it is NULL.  For example, in the the routine
`xdr_finalexample()', given earlier, if `finalp->string' was `NULL',
then it would not be freed.  The same is true for `finalp->simplep'.

   To summarize, each XDR routine is responsible for serializing,
deserializing, and freeing memory.  When an XDR routine is called from
`callrpc()' the serializing part is used.  When called from
`svc_getargs()' the deserializer is used.  And when called from
`svc_freeargs()' the memory deallocator is used.  When building simple
examples like those in this section, a user doesn't have to worry about
the three modes.  see @{"XDR Technical Notes" Link "XDR Technical Notes"} for examples of more
sophisticated XDR routines that determine which of the three modes they
are in and adjust their behavior accordingly.


@EndNode

@Node "The Calling Side" "RPC.guide/The Calling Side"
@Prev "Memory Allocation with XDR"
@Toc "Lowest Layer of RPC"

The Calling Side
----------------

   When you use `callrpc()' you have no control over the RPC delivery
mechanism or the socket used to transport the data.  To illustrate the
layer of RPC that lets you adjust these parameters, consider the
following code to call the `nusers' service:

     #include <stdio.h>
     #include <rpc/rpc.h>
     #include <utmp.h>
     #include <rpcsvc/rusers.h>
     #include <sys/socket.h>
     #include <sys/time.h>
     #include <netdb.h>
     
     main(argc, argv)
         int argc;
         char **argv;
     {
         struct hostent *hp;
         struct timeval pertry_timeout, total_timeout;
         struct sockaddr_in server_addr;
         int sock = RPC_ANYSOCK;
         register CLIENT *client;
         enum clnt_stat clnt_stat;
         unsigned long nusers;
     
         if (argc != 2) {
             fprintf(stderr, "usage: nusers hostname\n");
             exit(-1);
         }
         if ((hp = gethostbyname(argv[1])) == NULL) {
             fprintf(stderr, "can't get addr for %s\n",argv[1]);
             exit(-1);
         }
         pertry_timeout.tv_sec = 3;
         pertry_timeout.tv_usec = 0;
         bcopy(hp->h_addr, (caddr_t)&server_addr.sin_addr,
             hp->h_length);
         server_addr.sin_family = AF_INET;
         server_addr.sin_port =  0;
         if ((client = clntudp_create(&server_addr, RUSERSPROG,
           RUSERSVERS, pertry_timeout, &sock)) == NULL) {
             clnt_pcreateerror("clntudp_create");
             exit(-1);
         }
         total_timeout.tv_sec = 20;
         total_timeout.tv_usec = 0;
         clnt_stat = clnt_call(client, RUSERSPROC_NUM, xdr_void,
             0, xdr_u_long, &nusers, total_timeout);
         if (clnt_stat != RPC_SUCCESS) {
             clnt_perror(client, "rpc");
             exit(-1);
         }
         clnt_destroy(client);
         close(sock);
         exit(0);
     }

   The low-level version of `callrpc()' is `clnt_call()' which takes a
`CLIENT' pointer rather than a host name.  The parameters to
`clnt_call()' are a `CLIENT' pointer, the procedure number, the XDR
routine for serializing the argument, a pointer to the argument, the
XDR routine for deserializing the return value, a pointer to where the
return value will be placed, and the time in seconds to wait for a
reply.

   The `CLIENT' pointer is encoded with the transport mechanism.
`callrpc()' uses UDP, thus it calls `clntudp_create()' to get a
`CLIENT' pointer.  To get TCP (Transmission Control Protocol), you
would use `clnttcp_create()'.

   The parameters to `clntudp_create()' are the server address, the
program number, the version number, a timeout value (between tries), and
a pointer to a socket.  The final argument to `clnt_call()' is the
total time to wait for a response.  Thus, the number of tries is the
`clnt_call()' timeout divided by the `clntudp_create()' timeout.

   Note that the `clnt_destroy()' call always deallocates the space
associated with the `CLIENT' handle.  It closes the socket associated
with the `CLIENT' handle, however, only if the RPC library opened it.
It the socket was opened by the user, it stays open.  This makes it
possible, in cases where there are multiple client handles using the
same socket, to destroy one handle without closing the socket that
other handles are using.

   To make a stream connection, the call to `clntudp_create()' is
replaced with a call to `clnttcp_create()'.

     clnttcp_create(&server_addr, prognum, versnum, &sock,
                    inputsize, outputsize);

   There is no timeout argument; instead, the receive and send buffer
sizes must be specified.  When the `clnttcp_create()' call is made, a
TCP connection is established.  All RPC calls using that `CLIENT'
handle would use this connection.  The server side of an RPC call using
TCP has `svcudp_create()' replaced by `svctcp_create()'.

     transp = svctcp_create(RPC_ANYSOCK, 0, 0);

   The last two arguments to `svctcp_create()' are send and receive
sizes respectively.  If `0' is specified for either of these, the system
chooses a reasonable default.


@EndNode

@Node "Other RPC Features" "RPC.guide/Other RPC Features"
@Next "More Examples"
@Prev "Lowest Layer of RPC"
@Toc "Remote Procedure Call Programming Guide"

Other RPC Features
==================

   This section discusses some other aspects of RPC that are
occasionally useful.


 @{" Select on the Server Side " Link "Select on the Server Side"} 
 @{" Broadcast RPC " Link "Broadcast RPC"} 
 @{" RPC Batching " Link "RPC Batching"} 
 @{" RPC Authentication " Link "RPC Authentication"} 
 @{" Using Inetd " Link "Using Inetd"} 


@EndNode

@Node "Select on the Server Side" "RPC.guide/Select on the Server Side"
@Next "Broadcast RPC"
@Toc "Other RPC Features"

Select on the Server Side
-------------------------

   Suppose a process is processing RPC requests while performing some
other activity.  If the other activity involves periodically updating a
data structure, the process can set an alarm signal before calling
`svc_run()' But if the other activity involves waiting on a a file
descriptor, the `svc_run()' call won't work.  The code for `svc_run()'
is as follows:

     void
     svc_run()
     {
         fd_set readfds;
         int dtbsz = getdtablesize();
     
         for (;;) {
             readfds = svc_fds;
             switch (select(dtbsz, &readfds, NULL,NULL,NULL)) {
     
             case -1:
                 if (errno == EINTR)
                     continue;
                 perror("select");
                 return;
             case 0:
                 break;
             default:
                 svc_getreqset(&readfds);
             }
         }
     }

   You can bypass `svc_run()' and call `svc_getreqset()' yourself.  All
you need to know are the file descriptors of the socket(s) associated
with the programs you are waiting on.  Thus you can have your own
`select()' that waits on both the RPC socket, and your own descriptors.
Note that `svc_fds' is a bit mask of all the file descriptors that RPC
is using for services.  It can change everytime that *any* RPC library
routine is called, because descriptors are constantly being opened and
closed, for example for TCP connections.


@EndNode

@Node "Broadcast RPC" "RPC.guide/Broadcast RPC"
@Next "RPC Batching"
@Prev "Select on the Server Side"
@Toc "Other RPC Features"

Broadcast RPC
-------------

   The `portmapper' is a daemon that converts RPC program numbers into
DARPA protocol port numbers; see the `portmap' man page.  You can't do
broadcast RPC without the portmapper.  Here are the main differences
between broadcast RPC and normal RPC calls:

  1. Normal RPC expects one answer, whereas broadcast RPC expects many
     answers (one or more answer from each responding machine).

  2. Broadcast RPC can only be supported by packet-oriented
     (connectionless) transport protocols like UPD/IP.

  3. The implementation of broadcast RPC treats all unsuccessful
     responses as garbage by filtering them out.  Thus, if there is a
     version mismatch between the broadcaster and a remote service, the
     user of broadcast RPC never knows.

  4. All broadcast messages are sent to the portmap port.  Thus, only
     services that register themselves with their portmapper are
     accessible via the broadcast RPC mechanism.

  5. Broadcast requests are limited in size to the MTU (Maximum Transfer
     Unit) of the local network.  For Ethernet, the MTU is 1500 bytes.


 @{" Broadcast RPC Synopsis " Link "Broadcast RPC Synopsis"} 


@EndNode

@Node "Broadcast RPC Synopsis" "RPC.guide/Broadcast RPC Synopsis"
@Toc "Broadcast RPC"

Broadcast RPC Synopsis
......................

     #include <rpc/pmap_clnt.h>
         . . .
     enum clnt_stat  clnt_stat;
         . . .
     clnt_stat = clnt_broadcast(prognum, versnum, procnum,
       inproc, in, outproc, out, eachresult)
         u_long    prognum;        /* program number */
         u_long    versnum;        /* version number */
         u_long    procnum;        /* procedure number */
         xdrproc_t inproc;         /* xdr routine for args */
         caddr_t   in;             /* pointer to args */
         xdrproc_t outproc;        /* xdr routine for results */
         caddr_t   out;            /* pointer to results */
         bool_t    (*eachresult)();/* call with each result gotten */

   The procedure `eachresult()' is called each time a valid result is
obtained.  It returns a boolean that indicates whether or not the user
wants more responses.

     bool_t done;
         . . .
     done = eachresult(resultsp, raddr)
         caddr_t resultsp;
         struct sockaddr_in *raddr; /* Addr of responding machine */

   If `done' is `TRUE', then broadcasting stops and `clnt_broadcast()'
returns successfully.  Otherwise, the routine waits for another
response.  The request is rebroadcast after a few seconds of waiting.
If no responses come back, the routine returns with `RPC_TIMEDOUT'.


@EndNode

@Node "RPC Batching" "RPC.guide/RPC Batching"
@Next "RPC Authentication"
@Prev "Broadcast RPC"
@Toc "Other RPC Features"

Batching
--------

   The RPC architecture is designed so that clients send a call message,
and wait for servers to reply that the call succeeded.  This implies
that clients do not compute while servers are processing a call.  This
is inefficient if the client does not want or need an acknowledgement
for every message sent.  It is possible for clients to continue
computing while waiting for a response, using RPC batch facilities.

   RPC messages can be placed in a "pipeline" of calls to a desired
server; this is called batching.  Batching assumes that:

  1. each RPC call in the pipeline requires no response from the
     server, and the server does not send a response message; and

  2. the pipeline of calls is transported on a reliable byte stream
     transport such as TCP/IP.

   Since the server does not respond to every call, the client can
generate new calls in parallel with the server executing previous calls.
Furthermore, the TCP/IP implementation can buffer up many call messages,
and send them to the server in one `send()' system call.  This
overlapped execution greatly decreases the interprocess communication
overhead of the client and server processes, and the total elapsed time
of a series of calls.

   Since the batched calls are buffered, the client should eventually
do a nonbatched call in order to flush the pipeline.

   A contrived example of batching follows.  Assume a string rendering
service (like a window system) has two similar calls: one renders a
string and returns void results, while the other renders a string and
remains silent.  The service (using the TCP/IP transport) may look like:

     #include <stdio.h>
     #include <rpc/rpc.h>
     #include <suntool/windows.h>
     
     void windowdispatch();
     
     main()
     {
         SVCXPRT *transp;
     
         transp = svctcp_create(RPC_ANYSOCK, 0, 0);
         if (transp == NULL){
             fprintf(stderr, "can't create an RPC server\n");
             exit(1);
         }
         pmap_unset(WINDOWPROG, WINDOWVERS);
         if (!svc_register(transp, WINDOWPROG, WINDOWVERS,
           windowdispatch, IPPROTO_TCP)) {
             fprintf(stderr, "can't register WINDOW service\n");
             exit(1);
         }
         svc_run();  /* Never returns */
         fprintf(stderr, "should never reach this point\n");
     }
     
     void
     windowdispatch(rqstp, transp)
         struct svc_req *rqstp;
         SVCXPRT *transp;
     {
         char *s = NULL;
     
         switch (rqstp->rq_proc) {
         case NULLPROC:
             if (!svc_sendreply(transp, xdr_void, 0))
                 fprintf(stderr, "can't reply to RPC call\n");
             return;
         case RENDERSTRING:
             if (!svc_getargs(transp, xdr_wrapstring, &s)) {
                 fprintf(stderr, "can't decode arguments\n");
                 /*
                  * Tell caller he screwed up
                  */
                 svcerr_decode(transp);
                 break;
             }
             /*
              * Code here to render the string `s'
              */
             if (!svc_sendreply(transp, xdr_void, NULL))
                 fprintf(stderr, "can't reply to RPC call\n");
             break;
         case RENDERSTRING_BATCHED:
             if (!svc_getargs(transp, xdr_wrapstring, &s)) {
                 fprintf(stderr, "can't decode arguments\n");
                 /*
                  * We are silent in the face of protocol errors
                  */
                 break;
             }
             /*
              * Code here to render string s, but send no reply!
              */
             break;
         default:
             svcerr_noproc(transp);
             return;
         }
         /*
          * Now free string allocated while decoding arguments
          */
         svc_freeargs(transp, xdr_wrapstring, &s);
     }

   Of course the service could have one procedure that takes the string
and a boolean to indicate whether or not the procedure should respond.

   In order for a client to take advantage of batching, the client must
perform RPC calls on a TCP-based transport and the actual calls must
have the following attributes:

  1. the result's XDR routine must be zero `NULL'), and

  2. the RPC call's timeout must be zero.

   Here is an example of a client that uses batching to render a bunch
of strings; the batching is flushed when the client gets a null string
(EOF):

     #include <stdio.h>
     #include <rpc/rpc.h>
     #include <sys/socket.h>
     #include <sys/time.h>
     #include <netdb.h>
     #include <suntool/windows.h>
     
     main(argc, argv)
         int argc;
         char **argv;
     {
         struct hostent *hp;
         struct timeval pertry_timeout, total_timeout;
         struct sockaddr_in server_addr;
         int sock = RPC_ANYSOCK;
         register CLIENT *client;
         enum clnt_stat clnt_stat;
         char buf[1000], *s = buf;
     
         if ((client = clnttcp_create(&server_addr,
           WINDOWPROG, WINDOWVERS, &sock, 0, 0)) == NULL) {
             perror("clnttcp_create");
             exit(-1);
         }
         total_timeout.tv_sec = 0;
         total_timeout.tv_usec = 0;
         while (scanf("%s", s) != EOF) {
             clnt_stat = clnt_call(client, RENDERSTRING_BATCHED,
                 xdr_wrapstring, &s, NULL, NULL, total_timeout);
             if (clnt_stat != RPC_SUCCESS) {
                 clnt_perror(client, "batched rpc");
                 exit(-1);
             }
         }
     
         /* Now flush the pipeline */
     
         total_timeout.tv_sec = 20;
         clnt_stat = clnt_call(client, NULLPROC, xdr_void, NULL,
             xdr_void, NULL, total_timeout);
         if (clnt_stat != RPC_SUCCESS) {
             clnt_perror(client, "rpc");
             exit(-1);
         }
         clnt_destroy(client);
         exit(0);
     }

   Since the server sends no message, the clients cannot be notified of
any of the failures that may occur.  Therefore, clients are on their own
when it comes to handling errors.

   The above example was completed to render all of the (2000) lines in
the file `/etc/termcap'.  The rendering service did nothing but throw
the lines away.  The example was run in the following four
configurations:

  1. machine to itself, regular RPC;

  2. machine to itself, batched RPC;

  3. machine to another, regular RPC; and

  4. machine to another, batched RPC.

   The results are as follows:

  1. 50 seconds;

  2. 16 seconds;

  3. 52 seconds;

  4. 10 seconds.

   Running `fscanf()' on `/etc/termcap' only requires six seconds.
These timings show the advantage of protocols that allow for overlapped
execution, though these protocols are often hard to design.


@EndNode

@Node "RPC Authentication" "RPC.guide/RPC Authentication"
@Next "Using Inetd"
@Prev "RPC Batching"
@Toc "Other RPC Features"

Authentication
--------------

   In the examples presented so far, the caller never identified itself
to the server, and the server never required an ID from the caller.
Clearly, some network services, such as a network filesystem, require
stronger security than what has been presented so far.

   In reality, every RPC call is authenticated by the RPC package on the
server, and similarly, the RPC client package generates and sends
authentication parameters.  Just as different transports (TCP/IP or
UDP/IP) can be used when creating RPC clients and servers, different
forms of authentication can be associated with RPC clients; the default
authentication type used as a default is type `none'.

   The authentication subsystem of the RPC package is open ended.  That
is, numerous types of authentication are easy to support.


 @{" UNIX Authentication " Link "UNIX Authentication"} 
 @{" DES Authentication " Link "DES Authentication"} 


@EndNode

@Node "UNIX Authentication" "RPC.guide/UNIX Authentication"
@Next "DES Authentication"
@Toc "RPC Authentication"

UNIX Authentication
...................

The Client Side
...............

   When a caller creates a new RPC client handle as in:

     clnt = clntudp_create(address, prognum, versnum,
                   wait, sockp)

   the appropriate transport instance defaults the associate
authentication handle to be

     clnt->cl_auth = authnone_create();

   The RPC client can choose to use `UNIX' style authentication by
setting `clnt->cl_auth' after creating the RPC client handle:

     clnt->cl_auth = authunix_create_default();

   This causes each RPC call associated with `clnt' to carry with it
the following authentication credentials structure:

     /*
      * UNIX style credentials.
      */
     struct authunix_parms {
         u_long  aup_time;       /* credentials creation time */
         char    *aup_machname;  /* host name where client is */
         int     aup_uid;        /* client's UNIX effective uid */
         int     aup_gid;        /* client's current group id */
         u_int   aup_len;        /* element length of aup_gids */
         int     *aup_gids;      /* array of groups user is in */
     };

   These fields are set by `authunix_create_default()' by invoking the
appropriate system calls.  Since the RPC user created this new style of
authentication, the user is responsible for destroying it with:

     auth_destroy(clnt->cl_auth);

   This should be done in all cases, to conserve memory.

The Server Side
...............

   Service implementors have a harder time dealing with authentication
issues since the RPC package passes the service dispatch routine a
request that has an arbitrary authentication style associated with it.
Consider the fields of a request handle passed to a service dispatch
routine:

     /*
      * An RPC Service request
      */
     struct svc_req {
         u_long    rq_prog;      /* service program number */
         u_long    rq_vers;      /* service protocol vers num */
         u_long    rq_proc;      /* desired procedure number */
         struct opaque_auth rq_cred; /* raw credentials from wire */
         caddr_t   rq_clntcred;  /* credentials (read only) */
     };

   The `rq_cred' is mostly opaque, except for one field of interest:
the style or flavor of authentication credentials:

     /*
      * Authentication info.  Mostly opaque to the programmer.
      */
     struct opaque_auth {
         enum_t  oa_flavor;  /* style of credentials */
         caddr_t oa_base;    /* address of more auth stuff */
         u_int   oa_length;  /* not to exceed MAX_AUTH_BYTES */
     };

   The RPC package guarantees the following to the service dispatch
routine:

  1. That the request's `rq_cred' is well formed.  Thus the service
     implementor may inspect the request's `rq_cred.oa_flavor' to
     determine which style of authentication the caller used.  The
     service implementor may also wish to inspect the other fields of
     `rq_cred' if the style is not one of the styles supported by the
     RPC package.

  2. That the request's `rq_clntcred' field is either `NULL' or points
     to a well formed structure that corresponds to a supported style
     of authentication credentials.  Remember that only `UNIX' style is
     currently supported, so (currently) `rq_clntcred' could be cast to
     a pointer to an `authunix_parms' structure.  If `rq_clntcred' is
     `NULL', the service implementor may wish to inspect the other
     (opaque) fields of `rq_cred' in case the service knows about a new
     type of authentication that the RPC package does not know about.

   Our remote users service example can be extended so that it computes
results for all users except UID 16:

     nuser(rqstp, transp)
         struct svc_req *rqstp;
         SVCXPRT *transp;
     {
         struct authunix_parms *unix_cred;
         int uid;
         unsigned long nusers;
     
         /*
          * We don't care about authentication for null proc
          */
         if (rqstp->rq_proc == NULLPROC) {
             if (!svc_sendreply(transp, xdr_void, 0)) {
                 fprintf(stderr, "can't reply to RPC call\n");
                 return (1);
              }
              return;
         }
         /*
          * Now get the uid
          */
         switch (rqstp->rq_cred.oa_flavor) {
         case AUTH_UNIX:
             unix_cred =
                 (struct authunix_parms *)rqstp->rq_clntcred;
             uid = unix_cred->aup_uid;
             break;
         case AUTH_NULL:
         default:
             svcerr_weakauth(transp);
             return;
         }
         switch (rqstp->rq_proc) {
         case RUSERSPROC_NUM:
             /*
              * Make sure caller is allowed to call this proc
              */
             if (uid == 16) {
                 svcerr_systemerr(transp);
                 return;
             }
             /*
              * Code here to compute the number of users
              * and assign it to the variable `nusers'
              */
             if (!svc_sendreply(transp, xdr_u_long, &nusers)) {
                 fprintf(stderr, "can't reply to RPC call\n");
                 return (1);
             }
             return;
         default:
             svcerr_noproc(transp);
             return;
         }
     }

   A few things should be noted here.  First, it is customary not to
check the authentication parameters associated with the `NULLPROC'
(procedure number zero).  Second, if the authentication parameter's type
is not suitable for your service, you should call `svcerr_weakauth()'.
And finally, the service protocol itself should return status for
access denied; in the case of our example, the protocol does not have
such a status, so we call the service primitive `svcerr_systemerr()'
instead.

   The last point underscores the relation between the RPC
authentication package and the services; RPC deals only with
*authentication* and not with individual services' *access control*.
The services themselves must implement their own access control
policies and reflect these policies as return statuses in their
protocols.


@EndNode

@Node "DES Authentication" "RPC.guide/DES Authentication"
@Prev "UNIX Authentication"
@Toc "RPC Authentication"

DES Authentication
..................

   UNIX authentication is quite easy to defeat.  Instead of using
`authunix_create_default()', one can call `authunix_create()' and then
modify the RPC authentication handle it returns by filling in whatever
user ID and hostname they wish the server to think they have.  DES
authentication is thus recommended for people who want more security
than UNIX authentication offers.

   The details of the DES authentication protocol are complicated and
are not explained here.  see
@{"Remote Procedure Calls Protocol Specification" Link "Remote Procedure Calls Protocol Specification"} for the details.

   In order for DES authentication to work, the `keyserv(8c)' daemon
must be running on both the server and client machines.  The users on
these machines need public keys assigned by the network administrator in
the `publickey' database.  And, they need to have decrypted their
secret keys using their login password.  This automatically happens when
one logs in using `login', or can be done manually using `keylogin'.
The `Network Services' explains more how to setup secure networking.

Client Side
...........

   If a client wishes to use DES authentication, it must set its
authentication handle appropriately.  Here is an example:

     cl->cl_auth =
         authdes_create(servername, 60, &server_addr, NULL);

   The first argument is the network name or "netname" of the owner of
the server process.  Typically, server processes are root processes and
their netname can be derived using the following call:

     char servername[MAXNETNAMELEN];
     
     host2netname(servername, rhostname, NULL);

   Here, `rhostname' is the hostname of the machine the server process
is running on.  `host2netname()' fills in `servername' to contain this
root process's netname.  If the server process was run by a regular
user, one could use the call `user2netname()' instead.  Here is an
example for a server process with the same user ID as the client:

     char servername[MAXNETNAMELEN];
     
     user2netname(servername, getuid(), NULL);

   The last argument to both of these calls, `user2netname()' and
`host2netname()', is the name of the naming domain where the server is
located.  The `NULL' used here means "use the local domain name."

   The second argument to `authdes_create()' is a lifetime for the
credential.  Here it is set to sixty seconds.  What that means is that
the credential will expire 60 seconds from now.  If some mischievous
user tries to reuse the credential, the server RPC subsystem will
recognize that it has expired and not grant any requests.  If the same
mischievous user tries to reuse the credential within the sixty second
lifetime, he will still be rejected because the server RPC subsystem
remembers which credentials it has already seen in the near past, and
will not grant requests to duplicates.

   The third argument to `authdes_create()' is the address of the host
to synchronize with.  In order for DES authentication to work, the
server and client must agree upon the time.  Here we pass the address of
the server itself, so the client and server will both be using the same
time: the server's time.  The argument can be `NULL', which means
"don't bother synchronizing." You should only do this if you are sure
the client and server are already synchronized.

   The final argument to `authdes_create()' is the address of a DES
encryption key to use for encrypting timestamps and data.  If this
argument is `NULL', as it is in this example, a random key will be
chosen.  The client may find out the encryption key being used by
consulting the `ah_key' field of the authentication handle.

Server Side
...........

   The server side is a lot simpler than the client side.  Here is the
previous example rewritten to use `AUTH_DES' instead of `AUTH_UNIX':

     #include <sys/time.h>
     #include <rpc/auth_des.h>
         . . .
         . . .
     nuser(rqstp, transp)
         struct svc_req *rqstp;
         SVCXPRT *transp;
     {
         struct authdes_cred *des_cred;
         int uid;
         int gid;
         int gidlen;
         int gidlist[10];
         /*
          * We don't care about authentication for null proc
          */
     
         if (rqstp->rq_proc == NULLPROC) {
             /* same as before */
         }
     
         /*
          * now get the uid
          */
         switch (rqstp->rq_cred.oa_flavor) {
         case AUTH_DES:
             des_cred =
                 (struct authdes_cred *) rqstp->rq_clntcred;
             if (! netname2user(des_cred->adc_fullname.name,
                 &uid, &gid, &gidlen, gidlist))
             {
                 fprintf(stderr, "unknown user: %s\n",
                     des_cred->adc_fullname.name);
                 svcerr_systemerr(transp);
                 return;
             }
             break;
         case AUTH_NULL:
         default:
             svcerr_weakauth(transp);
             return;
         }
     
         /*
          * The rest is the same as before
          */

   Note the use of the routine `netname2user()', the inverse of
`user2netname()': it takes a network ID and converts to a unix ID.
`netname2user()' also supplies the group IDs which we don't use in this
example, but which may be useful to other UNIX programs.


@EndNode

@Node "Using Inetd" "RPC.guide/Using Inetd"
@Prev "RPC Authentication"
@Toc "Other RPC Features"

Using Inetd
-----------

   An RPC server can be started from `inetd'. The only difference from
the usual code is that the service creation routine should be called in
the following form:

     transp = svcudp_create(0);     /* For UDP */
     transp = svctcp_create(0,0,0); /* For listener TCP sockets */
     transp = svcfd_create(0,0,0);  /* For connected TCP sockets */

   since `inet' passes a socket as file descriptor 0.  Also,
`svc_register()' should be called as

     svc_register(transp, PROGNUM, VERSNUM, service, 0);

   with the final flag as 0, since the program would already be
registered by `inetd'.  Remember that if you want to exit from the
server process and return control to `inetd' you need to explicitly
exit, since `svc_run()' never returns.

   The format of entries in `/etc/inetd.conf' for RPC services is in
one of the following two forms:

     p_name/version dgram  rpc/udp wait/nowait user server args
     p_name/version stream rpc/tcp wait/nowait user server args

   where `p_name' is the symbolic name of the program as it appears in
the `rpc' data base, `server' is the program implementing the server,
and `program' and `version' are the program and version numbers of the
service.  For more information, see `inetd.conf(5)'.

   If the same program handles multiple versions, then the version
number can be a range, as in this example:

     rstatd/1-2 dgram rpc/udp wait root /usr/etc/rpc.rstatd


@EndNode

@Node "More Examples" "RPC.guide/More Examples"
@Prev "Other RPC Features"
@Toc "Remote Procedure Call Programming Guide"

More Examples
=============


 @{" Versions " Link "Versions"} 
 @{" TCP " Link "TCP"} 
 @{" Callback Procedures " Link "Callback Procedures"} 


@EndNode

@Node "Versions" "RPC.guide/Versions"
@Next "TCP"
@Toc "More Examples"

Versions
--------

   By convention, the first version number of program `PROG' is
`PROGVERS_ORIG' and the most recent version is `PROGVERS' Suppose there
is a new version of the `user' program that returns an `unsigned short'
rather than a `long'.  If we name this version `RUSERSVERS_SHORT' then
a server that wants to support both versions would do a double register.

     if (!svc_register(transp, RUSERSPROG, RUSERSVERS_ORIG,
       nuser, IPPROTO_TCP)) {
         fprintf(stderr, "can't register RUSER service\n");
         exit(1);
     }
     if (!svc_register(transp, RUSERSPROG, RUSERSVERS_SHORT,
       nuser, IPPROTO_TCP)) {
         fprintf(stderr, "can't register RUSER service\n");
         exit(1);
     }

   Both versions can be handled by the same C procedure:

     nuser(rqstp, transp)
         struct svc_req *rqstp;
         SVCXPRT *transp;
     {
         unsigned long nusers;
         unsigned short nusers2;
     
         switch (rqstp->rq_proc) {
         case NULLPROC:
             if (!svc_sendreply(transp, xdr_void, 0)) {
                 fprintf(stderr, "can't reply to RPC call\n");
                 return (1);
             }
             return;
         case RUSERSPROC_NUM:
             /*
              * Code here to compute the number of users
              * and assign it to the variable `nusers'
              */
             nusers2 = nusers;
             switch (rqstp->rq_vers) {
             case RUSERSVERS_ORIG:
                 if (!svc_sendreply(transp, xdr_u_long,
                 &nusers)) {
                     fprintf(stderr,"can't reply to RPC call\n");
                 }
                 break;
             case RUSERSVERS_SHORT:
                 if (!svc_sendreply(transp, xdr_u_short,
                 &nusers2)) {
                     fprintf(stderr,"can't reply to RPC call\n");
                 }
                 break;
             }
         default:
             svcerr_noproc(transp);
             return;
         }
     }


@EndNode

@Node "TCP" "RPC.guide/TCP"
@Next "Callback Procedures"
@Prev "Versions"
@Toc "More Examples"

TCP
---

   Here is an example that is essentially `rcp'.  The initiator of the
RPC *snd* call takes its standard input and sends it to the server
*rcv*, which prints it on standard output.  The RPC call uses TCP.
This also illustrates an XDR procedure that behaves differently on
serialization than on deserialization.

     /*
      * The xdr routine:
      *      on decode, read from wire, write onto fp
      *      on encode, read from fp, write onto wire
      */
     #include <stdio.h>
     #include <rpc/rpc.h>
     
     xdr_rcp(xdrs, fp)
         XDR *xdrs;
         FILE *fp;
     {
         unsigned long size;
         char buf[BUFSIZ], *p;
     
         if (xdrs->x_op == XDR_FREE)/* nothing to free */
             return 1;
         while (1) {
             if (xdrs->x_op == XDR_ENCODE) {
                 if ((size = fread(buf, sizeof(char), BUFSIZ,
                   fp)) == 0 && ferror(fp)) {
                     fprintf(stderr, "can't fread\n");
                     return (1);
                 }
             }
             p = buf;
             if (!xdr_bytes(xdrs, &p, &size, BUFSIZ))
                 return 0;
             if (size == 0)
                 return 1;
             if (xdrs->x_op == XDR_DECODE) {
                 if (fwrite(buf, sizeof(char), size,
                   fp) != size) {
                     fprintf(stderr, "can't fwrite\n");
                     return (1);
                 }
             }
         }
     }

     /*
      * The sender routines
      */
     #include <stdio.h>
     #include <netdb.h>
     #include <rpc/rpc.h>
     #include <sys/socket.h>
     #include <sys/time.h>
     
     main(argc, argv)
         int argc;
         char **argv;
     {
         int xdr_rcp();
         int err;
     
         if (argc < 2) {
             fprintf(stderr, "usage: %s servername\n", argv[0]);
             exit(-1);
         }
         if ((err = callrpctcp(argv[1], RCPPROG, RCPPROC,
           RCPVERS, xdr_rcp, stdin, xdr_void, 0) != 0)) {
             clnt_perrno(err);
             fprintf(stderr, "can't make RPC call\n");
             exit(1);
         }
         exit(0);
     }
     
     callrpctcp(host, prognum, procnum, versnum,
                inproc, in, outproc, out)
         char *host, *in, *out;
         xdrproc_t inproc, outproc;
     {
         struct sockaddr_in server_addr;
         int socket = RPC_ANYSOCK;
         enum clnt_stat clnt_stat;
         struct hostent *hp;
         register CLIENT *client;
         struct timeval total_timeout;
     
         if ((hp = gethostbyname(host)) == NULL) {
             fprintf(stderr, "can't get addr for '%s'\n", host);
             return (-1);
         }
         bcopy(hp->h_addr, (caddr_t)&server_addr.sin_addr,
             hp->h_length);
         server_addr.sin_family = AF_INET;
         server_addr.sin_port =  0;
         if ((client = clnttcp_create(&server_addr, prognum,
           versnum, &socket, BUFSIZ, BUFSIZ)) == NULL) {
             perror("rpctcp_create");
             return (-1);
         }
         total_timeout.tv_sec = 20;
         total_timeout.tv_usec = 0;
         clnt_stat = clnt_call(client, procnum,
             inproc, in, outproc, out, total_timeout);
         clnt_destroy(client);
         return (int)clnt_stat;
     }

     /*
      * The receiving routines
      */
     #include <stdio.h>
     #include <rpc/rpc.h>
     
     main()
     {
         register SVCXPRT *transp;
          int rcp_service(), xdr_rcp();
     
         if ((transp = svctcp_create(RPC_ANYSOCK,
           BUFSIZ, BUFSIZ)) == NULL) {
             fprintf("svctcp_create: error\n");
             exit(1);
         }
         pmap_unset(RCPPROG, RCPVERS);
         if (!svc_register(transp,
           RCPPROG, RCPVERS, rcp_service, IPPROTO_TCP)) {
             fprintf(stderr, "svc_register: error\n");
             exit(1);
         }
         svc_run();  /* never returns */
         fprintf(stderr, "svc_run should never return\n");
     }
     
     rcp_service(rqstp, transp)
         register struct svc_req *rqstp;
         register SVCXPRT *transp;
     {
         switch (rqstp->rq_proc) {
         case NULLPROC:
             if (svc_sendreply(transp, xdr_void, 0) == 0) {
                 fprintf(stderr, "err: rcp_service");
                 return (1);
             }
             return;
         case RCPPROC_FP:
             if (!svc_getargs(transp, xdr_rcp, stdout)) {
                 svcerr_decode(transp);
                 return;
             }
             if (!svc_sendreply(transp, xdr_void, 0)) {
                 fprintf(stderr, "can't reply\n");
                 return;
             }
             return (0);
         default:
             svcerr_noproc(transp);
             return;
         }
     }


@EndNode

@Node "Callback Procedures" "RPC.guide/Callback Procedures"
@Prev "TCP"
@Toc "More Examples"

Callback Procedures
-------------------

   Occasionally, it is useful to have a server become a client, and
make an RPC call back to the process which is its client.  An example
is remote debugging, where the client is a window system program, and
the server is a debugger running on the remote machine.  Most of the
time, the user clicks a mouse button at the debugging window, which
converts this to a debugger command, and then makes an RPC call to the
server (where the debugger is actually running), telling it to execute
that command.  However, when the debugger hits a breakpoint, the roles
are reversed, and the debugger wants to make an rpc call to the window
program, so that it can inform the user that a breakpoint has been
reached.

   In order to do an RPC callback, you need a program number to make the
RPC call on.  Since this will be a dynamically generated program number,
it should be in the transient range, `0x40000000 - 0x5fffffff'.  The
routine `gettransient()' returns a valid program number in the
transient range, and registers it with the portmapper.  It only talks to
the portmapper running on the same machine as the `gettransient()'
routine itself.  The call to `pmap_set()' is a test and set operation,
in that it indivisibly tests whether a program number has already been
registered, and if it has not, then reserves it.  On return, the
`sockp' argument will contain a socket that can be used as the argument
to an `svcudp_create()' or `svctcp_create()' call.

     #include <stdio.h>
     #include <rpc/rpc.h>
     #include <sys/socket.h>
     
     gettransient(proto, vers, sockp)
         int proto, vers, *sockp;
     {
         static int prognum = 0x40000000;
         int s, len, socktype;
         struct sockaddr_in addr;
     
         switch(proto) {
             case IPPROTO_UDP:
                 socktype = SOCK_DGRAM;
                 break;
             case IPPROTO_TCP:
                 socktype = SOCK_STREAM;
                 break;
             default:
                 fprintf(stderr, "unknown protocol type\n");
                 return 0;
         }
         if (*sockp == RPC_ANYSOCK) {
             if ((s = socket(AF_INET, socktype, 0)) < 0) {
                 perror("socket");
                 return (0);
             }
             *sockp = s;
         }
         else
             s = *sockp;
         addr.sin_addr.s_addr = 0;
         addr.sin_family = AF_INET;
         addr.sin_port = 0;
         len = sizeof(addr);
         /*
          * may be already bound, so don't check for error
          */
         bind(s, &addr, len);
         if (getsockname(s, &addr, &len)< 0) {
             perror("getsockname");
             return (0);
         }
         while (!pmap_set(prognum++, vers, proto,
             ntohs(addr.sin_port))) continue;
         return (prognum-1);
     }

   *Note:* *The call to `ntohs()' is necessary to ensure that the port
number in `addr.sin_port', which is in *network* byte order, is passed
in *host* byte order (as `pmap_set()' expects).  See the
`byteorder(3N)' man page for more details on the conversion of network
addresses from network to host byte order.*

   The following pair of programs illustrate how to use the
`gettransient()' routine.  The client makes an RPC call to the server,
passing it a transient program number.  Then the client waits around to
receive a callback from the server at that program number.  The server
registers the program `EXAMPLEPROG' so that it can receive the RPC call
informing it of the callback program number.  Then at some random time
(on receiving an `ALRM' signal in this example), it sends a callback
RPC call, using the program number it received earlier.

     /*
      * client
      */
     #include <stdio.h>
     #include <rpc/rpc.h>
     
     int callback();
     char hostname[256];
     
     main()
     {
         int x, ans, s;
         SVCXPRT *xprt;
     
         gethostname(hostname, sizeof(hostname));
         s = RPC_ANYSOCK;
         x = gettransient(IPPROTO_UDP, 1, &s);
         fprintf(stderr, "client gets prognum %d\n", x);
         if ((xprt = svcudp_create(s)) == NULL) {
           fprintf(stderr, "rpc_server: svcudp_create\n");
             exit(1);
         }
         /* protocol is 0 - gettransient does registering
          */
         (void)svc_register(xprt, x, 1, callback, 0);
         ans = callrpc(hostname, EXAMPLEPROG, EXAMPLEVERS,
             EXAMPLEPROC_CALLBACK, xdr_int, &x, xdr_void, 0);
         if ((enum clnt_stat) ans != RPC_SUCCESS) {
             fprintf(stderr, "call: ");
             clnt_perrno(ans);
             fprintf(stderr, "\n");
         }
         svc_run();
         fprintf(stderr, "Error: svc_run shouldn't return\n");
     }
     
     callback(rqstp, transp)
         register struct svc_req *rqstp;
         register SVCXPRT *transp;
     {
         switch (rqstp->rq_proc) {
             case 0:
                 if (!svc_sendreply(transp, xdr_void, 0)) {
                     fprintf(stderr, "err: exampleprog\n");
                     return (1);
                 }
                 return (0);
             case 1:
                 if (!svc_getargs(transp, xdr_void, 0)) {
                     svcerr_decode(transp);
                     return (1);
                 }
                 fprintf(stderr, "client got callback\n");
                 if (!svc_sendreply(transp, xdr_void, 0)) {
                     fprintf(stderr, "err: exampleprog");
                     return (1);
                 }
         }
     }

     /*
      * server
      */
     #include <stdio.h>
     #include <rpc/rpc.h>
     #include <sys/signal.h>
     
     char *getnewprog();
     char hostname[256];
     int docallback();
     int pnum;       /* program number for callback routine */
     
     main()
     {
         gethostname(hostname, sizeof(hostname));
         registerrpc(EXAMPLEPROG, EXAMPLEVERS,
           EXAMPLEPROC_CALLBACK, getnewprog, xdr_int, xdr_void);
         fprintf(stderr, "server going into svc_run\n");
         signal(SIGALRM, docallback);
         alarm(10);
         svc_run();
         fprintf(stderr, "Error: svc_run shouldn't return\n");
     }
     
     char *
     getnewprog(pnump)
         char *pnump;
     {
         pnum = *(int *)pnump;
         return NULL;
     }
     
     docallback()
     {
         int ans;
     
         ans = callrpc(hostname, pnum, 1, 1, xdr_void, 0,
             xdr_void, 0);
         if (ans != 0) {
             fprintf(stderr, "server: ");
             clnt_perrno(ans);
             fprintf(stderr, "\n");
         }
     }


@EndNode

@Node "XDR Technical Notes" "RPC.guide/XDR Technical Notes"
@Next "XDR Protocol Specification"
@Prev "Remote Procedure Call Programming Guide"
@Toc "Main"

XDR Technical Notes
*******************

   This chapter contains technical notes on Sun's implementation of the
External Data Representation (XDR) standard, a set of library routines
that allow a C programmer to describe arbitrary data structures in a
machine-independent fashion.  For a formal specification of the XDR
standard, See @{"XDR Protocol Specification" Link "XDR Protocol Specification"}.


 @{" Overview " Link "Overview"} 
 @{" Justification " Link "Justification"} 
 @{" A Canonical Standard " Link "A Canonical Standard"} 
 @{" The XDR Library " Link "The XDR Library"} 
 @{" XDR Library Primitives " Link "XDR Library Primitives"} 
 @{" Advanced Topics " Link "Advanced Topics"} 


@EndNode

@Node "Overview" "RPC.guide/Overview"
@Next "Justification"
@Toc "XDR Technical Notes"

Overview
========

   This chapter contains technical notes on Sun's implementation of the
External Data Representation ("XDR") standard, a set of library
routines that allow a C programmer to describe arbitrary data structures
in a machine-independent fashion.  For a formal specification of the XDR
standard, See @{"XDR Protocol Specification" Link "XDR Protocol Specification"}.  XDR is the backbone of Sun's
Remote Procedure Call package, in the sense that data for remote
procedure calls is transmitted using the standard.  XDR library routines
should be used to transmit data that is accessed (read or written) by
more than one type of machine (1).

   This chapter contains a short tutorial overview of the XDR library
routines, a guide to accessing currently available XDR streams, and
information on defining new streams and data types.  XDR was designed to
work across different languages, operating systems, and machine
architectures.  Most users (particularly RPC users) will only need the
information in the @{"Number Filters" Link "Number Filters"}, @{"Floating Point Filters" Link "Floating Point Filters"}, and
@{"Enumeration Filters" Link "Enumeration Filters"}.  Programmers wishing to implement RPC and XDR on
new machines will be interested in the rest of the chapter, as well as
the @{"XDR Protocol Specification" Link "XDR Protocol Specification"}, which will be their primary reference.

   *Note:* * `rpcgen' can be used to write XDR routines even in cases
where no RPC calls are being made.*

   On Sun systems, C programs that want to use XDR routines must include
the file `<rpc/rpc.h>', which contains all the necessary interfaces to
the XDR system.  Since the C library `libc.a' contains all the XDR
routines, compile as normal:

     example% cc program.c

   ---------- Footnotes ----------

   (1)  For a compete specification of the system External Data
Representation routines, see the `xdr(3N)' manual page.


@EndNode

@Node "Justification" "RPC.guide/Justification"
@Next "A Canonical Standard"
@Prev "Overview"
@Toc "XDR Technical Notes"

Justification
=============

   Consider the following two programs, `writer':

     #include <stdio.h>
     
     main()                  /* writer.c */
     {
             long i;
     
             for (i = 0; i < 8; i++) {
                     if (fwrite((char *)&i, sizeof(i), 1, stdout) != 1) {
                             fprintf(stderr, "failed!\n");
                             exit(1);
                     }
             }
             exit(0);
     }

   and `reader':

     #include <stdio.h>
     
     main()                  /* reader.c */
     {
             long i, j;
     
             for (j = 0; j < 8; j++) {
                     if (fread((char *)&i, sizeof (i), 1, stdin) != 1) {
                             fprintf(stderr, "failed!\n");
                             exit(1);
                     }
                     printf("%ld ", i);
             }
             printf("\n");
             exit(0);
     }

   The two programs appear to be portable, because

  a. they pass `lint' checking, and

  b. they exhibit the same behavior when executed on two different
     hardware architectures, a Sun and a VAX.

   Piping the output of the `writer' program to the `reader' program
gives identical results on a Sun or a VAX.

     sun% writer | reader
     0 1 2 3 4 5 6 7
     sun%
     
     vax% writer | reader
     0 1 2 3 4 5 6 7
     vax%

   With the advent of local area networks and 4.2BSD came the concept of
"network pipes" -- a process produces data on one machine, and a second
process consumes data on another machine.  A network pipe can be
constructed with `writer' and `reader'.  Here are the results if the
first produces data on a Sun, and the second consumes data on a VAX.

     sun% writer | rsh vax reader
     0 16777216 33554432 50331648 67108864 83886080 100663296 117440512
     sun%

   Identical results can be obtained by executing `writer' on the VAX
and `reader' on the Sun.  These results occur because the byte ordering
of long integers differs between the VAX and the Sun, even though word
size is the same.  Note that 16777216 is 2^24 -- when four bytes are
reversed, the 1 winds up in the 24th bit.

   Whenever data is shared by two or more machine types, there is a need
for portable data.  Programs can be made data-portable by replacing the
`read()' and `write()' calls with calls to an XDR library routine
`xdr_long()', a filter that knows the standard representation of a long
integer in its external form.  Here are the revised versions of
`writer':

     #include <stdio.h>
     #include <rpc/rpc.h>    /* xdr is a sub-library of rpc */
     
     main()          /* writer.c */
     {
             XDR xdrs;
             long i;
     
             xdrstdio_create(&xdrs, stdout, XDR_ENCODE);
             for (i = 0; i < 8; i++) {
                     if (!xdr_long(&xdrs, &i)) {
                             fprintf(stderr, "failed!\n");
                             exit(1);
                     }
             }
             exit(0);
     }

   and `reader':

     #include <stdio.h>
     #include <rpc/rpc.h>    /* xdr is a sub-library of rpc */
     
     main()          /* reader.c */
     {
             XDR xdrs;
             long i, j;
     
             xdrstdio_create(&xdrs, stdin, XDR_DECODE);
             for (j = 0; j < 8; j++) {
                     if (!xdr_long(&xdrs, &i)) {
                             fprintf(stderr, "failed!\n");
                             exit(1);
                     }
                     printf("%ld ", i);
             }
             printf("\n");
             exit(0);
     }

   The new programs were executed on a Sun, on a VAX, and from a Sun to
a VAX; the results are shown below.

     sun% writer | reader
     0 1 2 3 4 5 6 7
     sun%
     
     vax% writer | reader
     0 1 2 3 4 5 6 7
     vax%
     
     sun% writer | rsh vax reader
     0 1 2 3 4 5 6 7
     sun%

   *Note:* *Integers are just the tip of the portable-data iceberg.
Arbitrary data structures present portability problems, particularly
with respect to alignment and pointers.  Alignment on word boundaries
may cause the size of a structure to vary from machine to machine.  And
pointers, which are very convenient to use, have no meaning outside the
machine where they are defined.*


@EndNode

@Node "A Canonical Standard" "RPC.guide/A Canonical Standard"
@Next "The XDR Library"
@Prev "Justification"
@Toc "XDR Technical Notes"

A Canonical Standard
====================

   XDR's approach to standardizing data representations is *canonical*.
That is, XDR defines a single byte order (Big Endian), a single
floating-point representation (IEEE), and so on.  Any program running
on any machine can use XDR to create portable data by translating its
local representation to the XDR standard representations; similarly,
any program running on any machine can read portable data by
translating the XDR standard representaions to its local equivalents.
The single standard completely decouples programs that create or send
portable data from those that use or receive portable data.  The advent
of a new machine or a new language has no effect upon the community of
existing portable data creators and users.  A new machine joins this
community by being "taught" how to convert the standard representations
and its local representations; the local representations of other
machines are irrelevant.  Conversely, to existing programs running on
other machines, the local representations of the new machine are also
irrelevant; such programs can immediately read portable data produced
by the new machine because such data conforms to the canonical
standards that they already understand.

   There are strong precedents for XDR's canonical approach.  For
example, TCP/IP, UDP/IP, XNS, Ethernet, and, indeed, all protocols
below layer five of the ISO model, are canonical protocols.  The
advantage of any canonical approach is simplicity; in the case of XDR,
a single set of conversion routines is written once and is never
touched again.  The canonical approach has a disadvantage, but it is
unimportant in real-world data transfer applications.  Suppose two
Little-Endian machines are transferring integers according to the XDR
standard.  The sending machine converts the integers from Little-Endian
byte order to XDR (Big-Endian) byte order; the receiving machine
performs the reverse conversion.  Because both machines observe the
same byte order, their conversions are unnecessary.  The point,
however, is not necessity, but cost as compared to the alternative.

   The time spent converting to and from a canonical representation is
insignificant, especially in networking applications.  Most of the time
required to prepare a data structure for transfer is not spent in
conversion but in traversing the elements of the data structure.  To
transmit a tree, for example, each leaf must be visited and each element
in a leaf record must be copied to a buffer and aligned there; storage
for the leaf may have to be deallocated as well.  Similarly, to receive
a tree, storage must be allocated for each leaf, data must be moved from
the buffer to the leaf and properly aligned, and pointers must be
constructed to link the leaves together.  Every machine pays the cost of
traversing and copying data structures whether or not conversion is
required.  In networking applications, communications overhead -- the
time required to move the data down through the sender's protocol
layers, across the network and up through the receiver's protocol layers
-- dwarfs conversion overhead.


@EndNode

@Node "The XDR Library" "RPC.guide/The XDR Library"
@Next "XDR Library Primitives"
@Prev "A Canonical Standard"
@Toc "XDR Technical Notes"

The XDR Library
===============

   The XDR library not only solves data portability problems, it also
allows you to write and read arbitrary C constructs in a consistent,
specified, well-documented manner.  Thus, it can make sense to use the
library even when the data is not shared among machines on a network.

   The XDR library has filter routines for strings (null-terminated
arrays of bytes), structures, unions, and arrays, to name a few.  Using
more primitive routines, you can write your own specific XDR routines to
describe arbitrary data structures, including elements of arrays, arms
of unions, or objects pointed at from other structures.  The structures
themselves may contain arrays of arbitrary elements, or pointers to
other structures.

   Let's examine the two programs more closely.  There is a family of
XDR stream creation routines in which each member treats the stream of
bits differently.  In our example, data is manipulated using standard
I/O routines, so we use `xdrstdio_create()'.

   The parameters to XDR stream creation routines vary according to
their function.  In our example, `xdrstdio_create()' takes a pointer to
an XDR structure that it initializes, a pointer to a `FILE' that the
input or output is performed on, and the operation.  The operation may
be `XDR_ENCODE' for serializing in the `writer' program, or
`XDR_DECODE' for deserializing in the `reader' program.

   Note: RPC users never need to create XDR streams; the RPC system
itself creates these streams, which are then passed to the users.

   The `xdr_long()' primitive is characteristic of most XDR library
primitives and all client XDR routines.  First, the routine returns
`FALSE' (`0') if it fails, and `TRUE' (`1') if it succeeds.  Second,
for each data type, `xxx', there is an associated XDR routine of the
form:

     xdr_xxx(xdrs, xp)
             XDR *xdrs;
             xxx *xp;
     {
     }

   In our case, `xxx' is long, and the corresponding XDR routine is a
primitive, `xdr_long()'.  The client could also define an arbitrary
structure `xxx' in which case the client would also supply the routine
`xdr_xxx()', describing each field by calling XDR routines of the
appropriate type.  In all cases the first parameter, `xdrs' can be
treated as an opaque handle, and passed to the primitive routines.

   XDR routines are direction independent; that is, the same routines
are called to serialize or deserialize data.  This feature is critical
to software engineering of portable data.  The idea is to call the same
routine for either operation -- this almost guarantees that serialized
data can also be deserialized.  One routine is used by both producer and
consumer of networked data.  This is implemented by always passing the
address of an object rather than the object itself -- only in the case
of deserialization is the object modified.  This feature is not shown in
our trivial example, but its value becomes obvious when nontrivial data
structures are passed among machines.  If needed, the user can obtain
the direction of the XDR operation.  See the @{"XDR Operation Directions" Link "XDR Operation Directions"}
for details.

   Let's look at a slightly more complicated example.  Assume that a
person's gross assets and liabilities are to be exchanged among
processes.  Also assume that these values are important enough to
warrant their own data type:

     struct gnumbers {
             long g_assets;
             long g_liabilities;
     };

   The corresponding XDR routine describing this structure would be:

     bool_t                  /* TRUE is success, FALSE is failure */
     xdr_gnumbers(xdrs, gp)
             XDR *xdrs;
             struct gnumbers *gp;
     {
             if (xdr_long(xdrs, &gp->g_assets) &&
                 xdr_long(xdrs, &gp->g_liabilities))
                     return(TRUE);
             return(FALSE);
     }

   Note that the parameter `xdrs' is never inspected or modified; it is
only passed on to the subcomponent routines.  It is imperative to
inspect the return value of each XDR routine call, and to give up
immediately and return `FALSE' if the subroutine fails.

   This example also shows that the type `bool_t' is declared as an
integer whose only values are `TRUE' (1) and `FALSE' (0).  This
document uses the following definitions:

     #define bool_t  int
     #define TRUE    1
     #define FALSE   0

   Keeping these conventions in mind, `xdr_gnumbers()' can be rewritten
as follows:

     xdr_gnumbers(xdrs, gp)
             XDR *xdrs;
             struct gnumbers *gp;
     {
             return(xdr_long(xdrs, &gp->g_assets) &&
                     xdr_long(xdrs, &gp->g_liabilities));
     }

   This document uses both coding styles.


@EndNode

@Node "XDR Library Primitives" "RPC.guide/XDR Library Primitives"
@Next "Advanced Topics"
@Prev "The XDR Library"
@Toc "XDR Technical Notes"

XDR Library Primitives
======================

   This section gives a synopsis of each XDR primitive.  It starts with
basic data types and moves on to constructed data types.  Finally, XDR
utilities are discussed.  The interface to these primitives and
utilities is defined in the include file `<rpc/xdr.h>', automatically
included by `<rpc/rpc.h>'.


 @{" Number Filters " Link "Number Filters"} 
 @{" Floating Point Filters " Link "Floating Point Filters"} 
 @{" Enumeration Filters " Link "Enumeration Filters"} 
 @{" No Data " Link "No Data"} 
 @{" Constructed Data Type Filters " Link "Constructed Data Type Filters"} 
 @{" Non-filter Primitives " Link "Non-filter Primitives"} 
 @{" XDR Operation Directions " Link "XDR Operation Directions"} 
 @{" XDR Stream Access " Link "XDR Stream Access"} 
 @{" XDR Stream Implementation " Link "XDR Stream Implementation"} 


@EndNode

@Node "Number Filters" "RPC.guide/Number Filters"
@Next "Floating Point Filters"
@Toc "XDR Library Primitives"

Number Filters
--------------

   The XDR library provides primitives to translate between numbers and
their corresponding external representations.  Primitives cover the set
of numbers in:

     [signed, unsigned] * [short, int, long]

   Specifically, the eight primitives are:

     bool_t xdr_char(xdrs, cp)
             XDR *xdrs;
             char *cp;
     
     bool_t xdr_u_char(xdrs, ucp)
             XDR *xdrs;
             unsigned char *ucp;
     
     bool_t xdr_int(xdrs, ip)
             XDR *xdrs;
             int *ip;
     
     bool_t xdr_u_int(xdrs, up)
             XDR *xdrs;
             unsigned *up;
     
     bool_t xdr_long(xdrs, lip)
             XDR *xdrs;
             long *lip;
     
     bool_t xdr_u_long(xdrs, lup)
             XDR *xdrs;
             u_long *lup;
     
     bool_t xdr_short(xdrs, sip)
             XDR *xdrs;
             short *sip;
     
     bool_t xdr_u_short(xdrs, sup)
             XDR *xdrs;
             u_short *sup;

   The first parameter, `xdrs', is an XDR stream handle.  The second
parameter is the address of the number that provides data to the stream
or receives data from it.  All routines return `TRUE' if they complete
successfully, and `FALSE' otherwise.


@EndNode

@Node "Floating Point Filters" "RPC.guide/Floating Point Filters"
@Next "Enumeration Filters"
@Prev "Number Filters"
@Toc "XDR Library Primitives"

Floating Point Filters
----------------------

   The XDR library also provides primitive routines for C's floating
point types:

     bool_t xdr_float(xdrs, fp)
             XDR *xdrs;
             float *fp;
     
     bool_t xdr_double(xdrs, dp)
             XDR *xdrs;
             double *dp;

   The first parameter, `xdrs' is an XDR stream handle.  The second
parameter is the address of the floating point number that provides data
to the stream or receives data from it.  Both routines return `TRUE' if
they complete successfully, and `FALSE' otherwise.

   Note: Since the numbers are represented in IEEE floating point,
routines may fail when decoding a valid IEEE representation into a
machine-specific representation, or vice-versa.


@EndNode

@Node "Enumeration Filters" "RPC.guide/Enumeration Filters"
@Next "No Data"
@Prev "Floating Point Filters"
@Toc "XDR Library Primitives"

Enumeration Filters
-------------------

   The XDR library provides a primitive for generic enumerations.  The
primitive assumes that a C `enum' has the same representation inside
the machine as a C integer.  The boolean type is an important instance
of the `enum'.  The external representation of a boolean is always
`TRUE' (1) or `FALSE' (0).

     #define bool_t  int
     #define FALSE   0
     #define TRUE    1
     
     #define enum_t int
     
     bool_t xdr_enum(xdrs, ep)
             XDR *xdrs;
             enum_t *ep;
     
     bool_t xdr_bool(xdrs, bp)
             XDR *xdrs;
             bool_t *bp;

   The second parameters `ep' and `bp' are addresses of the associated
type that provides data to, or receives data from, the stream `xdrs'.


@EndNode

@Node "No Data" "RPC.guide/No Data"
@Next "Constructed Data Type Filters"
@Prev "Enumeration Filters"
@Toc "XDR Library Primitives"

No Data
-------

   Occasionally, an XDR routine must be supplied to the RPC system, even
when no data is passed or required.  The library provides such a
routine:

     bool_t xdr_void();  /* always returns TRUE */


@EndNode

@Node "Constructed Data Type Filters" "RPC.guide/Constructed Data Type Filters"
@Next "Non-filter Primitives"
@Prev "No Data"
@Toc "XDR Library Primitives"

Constructed Data Type Filters
-----------------------------

   Constructed or compound data type primitives require more parameters
and perform more complicated functions then the primitives discussed
above.  This section includes primitives for strings, arrays, unions,
and pointers to structures.

   Constructed data type primitives may use memory management.  In many
cases, memory is allocated when deserializing data with `XDR_DECODE'
Therefore, the XDR package must provide means to deallocate memory.
This is done by an XDR operation, `XDR_FREE' To review, the three XDR
directional operations are `XDR_ENCODE', `XDR_DECODE' and `XDR_FREE'.


 @{" Strings " Link "Strings"} 
 @{" Byte Arrays " Link "Byte Arrays"} 
 @{" Arrays " Link "Arrays"} 
 @{" XDR Examples " Link "XDR Examples"} 
 @{" Opaque Data " Link "Opaque Data"} 
 @{" Fixed Sized Arrays " Link "Fixed Sized Arrays"} 
 @{" Discriminated Unions " Link "Discriminated Unions"} 
 @{" Pointers " Link "Pointers"} 


@EndNode

@Node "Strings" "RPC.guide/Strings"
@Next "Byte Arrays"
@Toc "Constructed Data Type Filters"

Strings
.......

   In C, a string is defined as a sequence of bytes terminated by a null
byte, which is not considered when calculating string length.  However,
when a string is passed or manipulated, a pointer to it is employed.
Therefore, the XDR library defines a string to be a `char *' and not a
sequence of characters.  The external representation of a string is
drastically different from its internal representation.  Externally,
strings are represented as sequences of ASCII characters, while
internally, they are represented with character pointers.  Conversion
between the two representations is accomplished with the routine
`xdr_string()':

     bool_t xdr_string(xdrs, sp, maxlength)
             XDR *xdrs;
             char **sp;
             u_int maxlength;

   The first parameter `xdrs' is the XDR stream handle.  The second
parameter `sp' is a pointer to a string (type `char **').  The third
parameter `maxlength' specifies the maximum number of bytes allowed
during encoding or decoding.  Its value is usually specified by a
protocol.  For example, a protocol specification may say that a file
name may be no longer than 255 characters.

   The routine returns `FALSE' if the number of characters exceeds
`maxlength', and `TRUE' if it doesn't.  *Keep* `maxlength' small.  If
it is too big you can blow the heap, since `xdr_string()' will call
`malloc()' for space.

   The behavior of `xdr_string()' is similar to the behavior of other
routines discussed in this section.  The direction `XDR_ENCODE' is
easiest to understand.  The parameter `sp' points to a string of a
certain length; if the string does not exceed `maxlength', the bytes
are serialized.

   The effect of deserializing a string is subtle.  First the length of
the incoming string is determined; it must not exceed `maxlength'.
Next `sp' is dereferenced; if the the value is `NULL', then a string of
the appropriate length is allocated and `*sp' is set to this string.
If the original value of `*sp' is non-null, then the XDR package
assumes that a target area has been allocated, which can hold strings
no longer than `maxlength'.  In either case, the string is decoded into
the target area.  The routine then appends a null character to the
string.

   In the `XDR_FREE' operation, the string is obtained by dereferencing
`sp'.  If the string is not `NULL', it is freed and `*sp' is set to
`NULL'.  In this operation, `xdr_string()' ignores the `maxlength'
parameter.


@EndNode

@Node "Byte Arrays" "RPC.guide/Byte Arrays"
@Next "Arrays"
@Prev "Strings"
@Toc "Constructed Data Type Filters"

Byte Arrays
...........

   Often variable-length arrays of bytes are preferable to strings.
Byte arrays differ from strings in the following three ways:

  1. the length of the array (the byte count) is explicitly located in
     an unsigned integer,

  2. the byte sequence is not terminated by a null character, and

  3. the external representation of the bytes is the same as their
     internal representation.

   The primitive `xdr_bytes()' converts between the internal and
external representations of byte arrays:

     bool_t xdr_bytes(xdrs, bpp, lp, maxlength)
         XDR *xdrs;
         char **bpp;
         u_int *lp;
         u_int maxlength;

   The usage of the first, second and fourth parameters are identical to
the first, second and third parameters of `xdr_string()', respectively.
The length of the byte area is obtained by dereferencing `lp' when
serializing; `*lp' is set to the byte length when deserializing.


@EndNode

@Node "Arrays" "RPC.guide/Arrays"
@Next "XDR Examples"
@Prev "Byte Arrays"
@Toc "Constructed Data Type Filters"

Arrays
......

   The XDR library package provides a primitive for handling arrays of
arbitrary elements.  The `xdr_bytes()' routine treats a subset of
generic arrays, in which the size of array elements is known to be 1,
and the external description of each element is built-in.  The generic
array primitive, `xdr_array()', requires parameters identical to those
of `xdr_bytes()' plus two more: the size of array elements, and an XDR
routine to handle each of the elements.  This routine is called to
encode or decode each element of the array.

     bool_t
     xdr_array(xdrs, ap, lp, maxlength, elementsiz, xdr_element)
         XDR *xdrs;
         char **ap;
         u_int *lp;
         u_int maxlength;
         u_int elementsiz;
         bool_t (*xdr_element)();

   The parameter `ap' is the address of the pointer to the array.  If
`*ap' is `NULL' when the array is being deserialized, XDR allocates an
array of the appropriate size and sets `*ap' to that array.  The
element count of the array is obtained from `*lp' when the array is
serialized; `*lp' is set to the array length when the array is
deserialized.  The parameter `maxlength' is the maximum number of
elements that the array is allowed to have; `elementsiz' is the byte
size of each element of the array (the C function `sizeof()' can be
used to obtain this value).  The `xdr_element()' routine is called to
serialize, deserialize, or free each element of the array.


@EndNode

@Node "XDR Examples" "RPC.guide/XDR Examples"
@Next "Opaque Data"
@Prev "Arrays"
@Toc "Constructed Data Type Filters"

XDR Examples
............

   Before defining more constructed data types, it is appropriate to
present three examples.

Example A: Network User
.......................

   A user on a networked machine can be identified by

  a. the machine name, such as `krypton': see the `gethostname()' man
     page;

  b. the user's UID: see the `geteuid()' man page; and

  c. the group numbers to which the user belongs: see the `getgroups()'
     man page.

   A structure with this information and its associated XDR routine
could be coded like this:

     struct netuser {
         char    *nu_machinename;
         int     nu_uid;
         u_int   nu_glen;
         int     *nu_gids;
     };
     #define NLEN 255    /* machine names < 256 chars */
     #define NGRPS 20    /* user can't be in > 20 groups */
     
     bool_t
     xdr_netuser(xdrs, nup)
         XDR *xdrs;
         struct netuser *nup;
     {
         return(xdr_string(xdrs, &nup->nu_machinename, NLEN) &&
             xdr_int(xdrs, &nup->nu_uid) &&
             xdr_array(xdrs, &nup->nu_gids, &nup->nu_glen,
             NGRPS, sizeof (int), xdr_int));
     }

Example B: Party of Network Users
.................................

   A party of network users could be implemented as an array of
`netuser' structure.  The declaration and its associated XDR routines
are as follows:

     struct party {
         u_int p_len;
         struct netuser *p_nusers;
     };
     #define PLEN 500    /* max number of users in a party */
     
     bool_t
     xdr_party(xdrs, pp)
         XDR *xdrs;
         struct party *pp;
     {
         return(xdr_array(xdrs, &pp->p_nusers, &pp->p_len, PLEN,
             sizeof (struct netuser), xdr_netuser));
     }

Example C: History of Commands
..............................

   The well-known parameters to `main()', `argc' and `argv' can be
combined into a structure.  An array of these structures can make up a
history of commands.  The declarations and XDR routines might look like:

     struct cmd {
         u_int c_argc;
         char **c_argv;
     };
     #define ALEN 1000   /* args cannot be > 1000 chars */
     #define NARGC 100   /* commands cannot have > 100 args */
     
     struct history {
         u_int h_len;
         struct cmd *h_cmds;
     };
     #define NCMDS 75    /* history is no more than 75 commands */
     
     bool_t
     xdr_wrap_string(xdrs, sp)
         XDR *xdrs;
         char **sp;
     {
         return(xdr_string(xdrs, sp, ALEN));
     }
     
     bool_t
     xdr_cmd(xdrs, cp)
         XDR *xdrs;
         struct cmd *cp;
     {
         return(xdr_array(xdrs, &cp->c_argv, &cp->c_argc, NARGC,
             sizeof (char *), xdr_wrap_string));
     }
     
     bool_t
     xdr_history(xdrs, hp)
         XDR *xdrs;
         struct history *hp;
     {
         return(xdr_array(xdrs, &hp->h_cmds, &hp->h_len, NCMDS,
             sizeof (struct cmd), xdr_cmd));
     }

   The most confusing part of this example is that the routine
`xdr_wrap_string()' is needed to package the `xdr_string()' routine,
because the implementation of `xdr_array()' only passes two parameters
to the array element description routine; `xdr_wrap_string()' supplies
the third parameter to `xdr_string()'.

   By now the recursive nature of the XDR library should be obvious.
Let's continue with more constructed data types.


@EndNode

@Node "Opaque Data" "RPC.guide/Opaque Data"
@Next "Fixed Sized Arrays"
@Prev "XDR Examples"
@Toc "Constructed Data Type Filters"

Opaque Data
...........

   In some protocols, handles are passed from a server to client.  The
client passes the handle back to the server at some later time.  Handles
are never inspected by clients; they are obtained and submitted.  That
is to say, handles are opaque.  The `xdr_opaque()' primitive is used
for describing fixed sized, opaque bytes.

     bool_t xdr_opaque(xdrs, p, len)
         XDR *xdrs;
         char *p;
         u_int len;

   The parameter `p' is the location of the bytes; `len' is the number
of bytes in the opaque object.  By definition, the actual data
contained in the opaque object are not machine portable.


@EndNode

@Node "Fixed Sized Arrays" "RPC.guide/Fixed Sized Arrays"
@Next "Discriminated Unions"
@Prev "Opaque Data"
@Toc "Constructed Data Type Filters"

Fixed Sized Arrays
..................

   The XDR library provides a primitive, `xdr_vector()', for
fixed-length arrays.

     #define NLEN 255    /* machine names must be < 256 chars */
     #define NGRPS 20    /* user belongs to exactly 20 groups */
     
     struct netuser {
         char *nu_machinename;
         int nu_uid;
         int nu_gids[NGRPS];
     };
     
     bool_t
     xdr_netuser(xdrs, nup)
         XDR *xdrs;
         struct netuser *nup;
     {
         int i;
     
         if (!xdr_string(xdrs, &nup->nu_machinename, NLEN))
             return(FALSE);
         if (!xdr_int(xdrs, &nup->nu_uid))
             return(FALSE);
         if (!xdr_vector(xdrs, nup->nu_gids, NGRPS, sizeof(int),
             xdr_int)) {
                 return(FALSE);
         }
         return(TRUE);
     }


@EndNode

@Node "Discriminated Unions" "RPC.guide/Discriminated Unions"
@Next "Pointers"
@Prev "Fixed Sized Arrays"
@Toc "Constructed Data Type Filters"

Discriminated Unions
....................

   The XDR library supports discriminated unions.  A discriminated
union is a C union and an `enum_t' value that selects an "arm" of the
union.

     struct xdr_discrim {
         enum_t value;
         bool_t (*proc)();
     };
     
     bool_t xdr_union(xdrs, dscmp, unp, arms, defaultarm)
         XDR *xdrs;
         enum_t *dscmp;
         char *unp;
         struct xdr_discrim *arms;
         bool_t (*defaultarm)();  /* may equal NULL */

   First the routine translates the discriminant of the union located at
`*dscmp'.  The discriminant is always an `enum_t'.  Next the union
located at `*unp' is translated.  The parameter `arms' is a pointer to
an array of `xdr_discrim' structures.  Each structure contains an
ordered pair of *[value,proc]*.  If the union's discriminant is equal
to the associated *value*, then the *proc* is called to translate the
union.  The end of the `xdr_discrim' structure array is denoted by a
routine of value `NULL' (`0').  If the discriminant is not found in the
`arms' array, then the `defaultarm' procedure is called if it is
non-null; otherwise the routine returns `FALSE'.

Example D: Union
................

   Suppose the type of a union may be integer, character pointer (a
string), or a `gnumbers' structure.  Also, assume the union and its
current type are declared in a structure.  The declaration is:

     enum utype { INTEGER=1, STRING=2, GNUMBERS=3 };
     
     struct u_tag {
         enum utype utype;   /* the union's discriminant */
         union {
             int ival;
             char *pval;
             struct gnumbers gn;
         } uval;
     };

   The following constructs and XDR procedure (de)serialize the
discriminated union:

     struct xdr_discrim u_tag_arms[4] = {
         { INTEGER, xdr_int },
         { GNUMBERS, xdr_gnumbers }
         { STRING, xdr_wrap_string },
         { __dontcare__, NULL }
         /* always terminate arms with a NULL xdr_proc */
     }
     
     bool_t
     xdr_u_tag(xdrs, utp)
         XDR *xdrs;
         struct u_tag *utp;
     {
         return(xdr_union(xdrs, &utp->utype, &utp->uval,
             u_tag_arms, NULL));
     }

   The routine `xdr_gnumbers()' was presented above in @{"The XDR Library" Link "The XDR Library"}.
`xdr_wrap_string()' was presented in example C.  The default `arm'
parameter to `xdr_union()' (the last parameter) is `NULL' in this
example.  Therefore the value of the union's discriminant may legally
take on only values listed in the `u_tag_arms' array.  This example
also demonstrates that the elements of the arm's array do not need to
be sorted.

   It is worth pointing out that the values of the discriminant may be
sparse, though in this example they are not.  It is always good practice
to assign explicitly integer values to each element of the
discriminant's type.  This practice both documents the external
representation of the discriminant and guarantees that different C
compilers emit identical discriminant values.

   Exercise: Implement `xdr_union()' using the other primitives in this
section.


@EndNode

@Node "Pointers" "RPC.guide/Pointers"
@Prev "Discriminated Unions"
@Toc "Constructed Data Type Filters"

Pointers
........

   In C it is often convenient to put pointers to another structure
within a structure.  The `xdr_reference()' primitive makes it easy to
serialize, deserialize, and free these referenced structures.

     bool_t xdr_reference(xdrs, pp, size, proc)
         XDR *xdrs;
         char **pp;
         u_int ssize;
         bool_t (*proc)();

   Parameter `pp' is the address of the pointer to the structure;
parameter `ssize' is the size in bytes of the structure (use the C
function `sizeof()' to obtain this value); and `proc' is the XDR
routine that describes the structure.  When decoding data, storage is
allocated if `*pp' is `NULL'.

   There is no need for a primitive `xdr_struct()' to describe
structures within structures, because pointers are always sufficient.

   Exercise: Implement `xdr_reference()' using `xdr_array()'.  Warning:
`xdr_reference()' and `xdr_array()' are NOT interchangeable external
representations of data.

Example E: Pointers
...................

   Suppose there is a structure containing a person's name and a
pointer to a `gnumbers' structure containing the person's gross assets
and liabilities.  The construct is:

     struct pgn {
         char *name;
         struct gnumbers *gnp;
     };

   The corresponding XDR routine for this structure is:

     bool_t
     xdr_pgn(xdrs, pp)
         XDR *xdrs;
         struct pgn *pp;
     {
         if (xdr_string(xdrs, &pp->name, NLEN) &&
           xdr_reference(xdrs, &pp->gnp,
           sizeof(struct gnumbers), xdr_gnumbers))
             return(TRUE);
         return(FALSE);
     }

Pointer Semantics and XDR
.........................

   In many applications, C programmers attach double meaning to the
values of a pointer.  Typically the value `NULL' (or zero) means data is
not needed, yet some application-specific interpretation applies.  In
essence, the C programmer is encoding a discriminated union efficiently
by overloading the interpretation of the value of a pointer.  For
instance, in example E a `NULL' pointer value for `gnp' could indicate
that the person's assets and liabilities are unknown.  That is, the
pointer value encodes two things: whether or not the data is known; and
if it is known, where it is located in memory.  Linked lists are an
extreme example of the use of application-specific pointer
interpretation.

   The primitive `xdr_reference()' cannot and does not attach any
special meaning to a null-value pointer during serialization.  That is,
passing an address of a pointer whose value is `NULL' to
`xdr_reference()' when serialing data will most likely cause a memory
fault and, on the UNIX system, a core dump.

   `xdr_pointer()' correctly handles `NULL' pointers.  For more
information about its use, see the @{"Linked Lists" Link "Linked Lists"}.

Exercise:
.........

   After reading the @{"Linked Lists" Link "Linked Lists"}, return here and extend example E so
that it can correctly deal with `NULL' pointer values.

Exercise:
.........

   Using the `xdr_union()', `xdr_reference()' and `xdr_void()'
primitives, implement a generic pointer handling primitive that
implicitly deals with `NULL' pointers.  That is, implement
`xdr_pointer()'.


@EndNode

@Node "Non-filter Primitives" "RPC.guide/Non-filter Primitives"
@Next "XDR Operation Directions"
@Prev "Constructed Data Type Filters"
@Toc "XDR Library Primitives"

Non-filter Primitives
---------------------

   XDR streams can be manipulated with the primitives discussed in this
section.

     u_int xdr_getpos(xdrs)
         XDR *xdrs;
     
     bool_t xdr_setpos(xdrs, pos)
         XDR *xdrs;
         u_int pos;
     
     xdr_destroy(xdrs)
         XDR *xdrs;

   The routine `xdr_getpos()' returns an unsigned integer that
describes the current position in the data stream.  Warning: In some
XDR streams, the returned value of `xdr_getpos()' is meaningless; the
routine returns a -1 in this case (though -1 should be a legitimate
value).

   The routine `xdr_setpos()' sets a stream position to `pos'.
Warning: In some XDR streams, setting a position is impossible; in such
cases, `xdr_setpos()' will return `FALSE'.  This routine will also fail
if the requested position is out-of-bounds.  The definition of bounds
varies from stream to stream.

   The `xdr_destroy()' primitive destroys the XDR stream.  Usage of the
stream after calling this routine is undefined.


@EndNode

@Node "XDR Operation Directions" "RPC.guide/XDR Operation Directions"
@Next "XDR Stream Access"
@Prev "Non-filter Primitives"
@Toc "XDR Library Primitives"

XDR Operation Directions
------------------------

   At times you may wish to optimize XDR routines by taking advantage of
the direction of the operation -- `XDR_ENCODE', `XDR_DECODE' or
`XDR_FREE'.  The value `xdrs->x_op' always contains the direction of
the XDR operation.  Programmers are not encouraged to take advantage of
this information.  Therefore, no example is presented here.  However,
an example in the @{"Linked Lists" Link "Linked Lists"}, demonstrates the usefulness of the
`xdrs->x_op' field.


@EndNode

@Node "XDR Stream Access" "RPC.guide/XDR Stream Access"
@Next "XDR Stream Implementation"
@Prev "XDR Operation Directions"
@Toc "XDR Library Primitives"

XDR Stream Access
-----------------

   An XDR stream is obtained by calling the appropriate creation
routine.  These creation routines take arguments that are tailored to
the specific properties of the stream.

   Streams currently exist for (de)serialization of data to or from
standard I/O `FILE' streams, TCP/IP connections and UNIX files, and
memory.


 @{" Standard I-O Streams " Link "Standard I-O Streams"} 
 @{" Memory Streams " Link "Memory Streams"} 
 @{" Record (TCP-IP) Streams " Link "Record (TCP-IP) Streams"} 


@EndNode

@Node "Standard I-O Streams" "RPC.guide/Standard I-O Streams"
@Next "Memory Streams"
@Toc "XDR Stream Access"

Standard I/O Streams
....................

   XDR streams can be interfaced to standard I/O using the
`xdrstdio_create()' routine as follows:

     #include <stdio.h>
     #include <rpc/rpc.h>    /* xdr streams part of rpc */
     
     void
     xdrstdio_create(xdrs, fp, x_op)
         XDR *xdrs;
         FILE *fp;
         enum xdr_op x_op;

   The routine `xdrstdio_create()' initializes an XDR stream pointed to
by `xdrs'.  The XDR stream interfaces to the standard I/O library.
Parameter `fp' is an open file, and `x_op' is an XDR direction.


@EndNode

@Node "Memory Streams" "RPC.guide/Memory Streams"
@Next "Record (TCP-IP) Streams"
@Prev "Standard I-O Streams"
@Toc "XDR Stream Access"

Memory Streams
..............

   Memory streams allow the streaming of data into or out of a specified
area of memory:

     #include <rpc/rpc.h>
     
     void
     xdrmem_create(xdrs, addr, len, x_op)
         XDR *xdrs;
         char *addr;
         u_int len;
         enum xdr_op x_op;

   The routine `xdrmem_create()' initializes an XDR stream in local
memory.  The memory is pointed to by parameter `addr'; parameter `len'
is the length in bytes of the memory.  The parameters `xdrs' and `x_op'
are identical to the corresponding parameters of `xdrstdio_create()'.
Currently, the UDP/IP implementation of RPC uses `xdrmem_create()'.
Complete call or result messages are built in memory before calling the
`sendto()' system routine.


@EndNode

@Node "Record (TCP-IP) Streams" "RPC.guide/Record (TCP-IP) Streams"
@Prev "Memory Streams"
@Toc "XDR Stream Access"

Record (TCP/IP) Streams
.......................

   A record stream is an XDR stream built on top of a record marking
standard that is built on top of the UNIX file or 4.2 BSD connection
interface.

     #include <rpc/rpc.h>    /* xdr streams part of rpc */
     
     xdrrec_create(xdrs,
       sendsize, recvsize, iohandle, readproc, writeproc)
         XDR *xdrs;
         u_int sendsize, recvsize;
         char *iohandle;
         int (*readproc)(), (*writeproc)();

   The routine `xdrrec_create()' provides an XDR stream interface that
allows for a bidirectional, arbitrarily long sequence of records.  The
contents of the records are meant to be data in XDR form.  The stream's
primary use is for interfacing RPC to TCP connections.  However, it can
be used to stream data into or out of normal UNIX files.

   The parameter `xdrs' is similar to the corresponding parameter
described above.  The stream does its own data buffering similar to that
of standard I/O.  The parameters `sendsize' and `recvsize' determine
the size in bytes of the output and input buffers, respectively; if
their values are zero (`0'), then predetermined defaults are used.
When a buffer needs to be filled or flushed, the routine `readproc()'
or `writeproc()' is called, respectively.  The usage and behavior of
these routines are similar to the UNIX system calls `read()' and
`write()'.  However, the first parameter to each of these routines is
the opaque parameter `iohandle'.  The other two parameters `buf' and
`nbytes') and the results (byte count) are identical to the system
routines.  If `xxx' is `readproc()' or `writeproc()', then it has the
following form:

     /*
      * returns the actual number of bytes transferred.
      * -1 is an error
      */
     int
     xxx(iohandle, buf, len)
         char *iohandle;
         char *buf;
         int nbytes;

   The XDR stream provides means for delimiting records in the byte
stream.  The implementation details of delimiting records in a stream
are discussed in the @{"Advanced Topics" Link "Advanced Topics"}.  The primitives that are specific
to record streams are as follows:

     bool_t
     xdrrec_endofrecord(xdrs, flushnow)
         XDR *xdrs;
         bool_t flushnow;
     
     bool_t
     xdrrec_skiprecord(xdrs)
         XDR *xdrs;
     
     bool_t
     xdrrec_eof(xdrs)
         XDR *xdrs;

   The routine `xdrrec_endofrecord()' causes the current outgoing data
to be marked as a record.  If the parameter `flushnow' is `TRUE', then
the stream's `writeproc' will be called; otherwise, `writeproc' will be
called when the output buffer has been filled.

   The routine `xdrrec_skiprecord()' causes an input stream's position
to be moved past the current record boundary and onto the beginning of
the next record in the stream.

   If there is no more data in the stream's input buffer, then the
routine `xdrrec_eof()' returns `TRUE'.  That is not to say that there
is no more data in the underlying file descriptor.


@EndNode

@Node "XDR Stream Implementation" "RPC.guide/XDR Stream Implementation"
@Prev "XDR Stream Access"
@Toc "XDR Library Primitives"

XDR Stream Implementation
-------------------------

   This section provides the abstract data types needed to implement new
instances of XDR streams.


 @{" The XDR Object " Link "The XDR Object"} 


@EndNode

@Node "The XDR Object" "RPC.guide/The XDR Object"
@Toc "XDR Stream Implementation"

The XDR Object
..............

   The following structure defines the interface to an XDR stream:

     enum xdr_op { XDR_ENCODE=0, XDR_DECODE=1, XDR_FREE=2 };
     
     typedef struct {
         enum xdr_op x_op;            /* operation; fast added param */
         struct xdr_ops {
             bool_t  (*x_getlong)();  /* get long from stream */
             bool_t  (*x_putlong)();  /* put long to stream */
             bool_t  (*x_getbytes)(); /* get bytes from stream */
             bool_t  (*x_putbytes)(); /* put bytes to stream */
             u_int   (*x_getpostn)(); /* return stream offset */
             bool_t  (*x_setpostn)(); /* reposition offset */
             caddr_t (*x_inline)();   /* ptr to buffered data */
             VOID    (*x_destroy)();  /* free private area */
         } *x_ops;
         caddr_t     x_public;        /* users' data */
         caddr_t     x_private;       /* pointer to private data */
         caddr_t     x_base;          /* private for position info */
         int         x_handy;         /* extra private word */
     } XDR;

   The `x_op' field is the current operation being performed on the
stream.  This field is important to the XDR primitives, but should not
affect a stream's implementation.  That is, a stream's implementation
should not depend on this value.  The fields `x_private', `x_base', and
`x_handy' are private to the particular stream's implementation.  The
field `x_public' is for the XDR client and should never be used by the
XDR stream implementations or the XDR primitives.  `x_getpostn()',
`x_setpostn()' and `x_destroy()' are macros for accessing operations.
The operation `x_inline()' takes two parameters: an `XDR *', and an
unsigned integer, which is a byte count.  The routine returns a pointer
to a piece of the stream's internal buffer.  The caller can then use the
buffer segment for any purpose.  From the stream's point of view, the
bytes in the buffer segment have been consumed or put.  The routine may
return `NULL' if it cannot return a buffer segment of the requested
size.  (The `x_inline()' routine is for cycle squeezers.  Use of the
resulting buffer is not data-portable.  Users are encouraged not to use
this feature.)

   The operations `x_getbytes()' and `x_putbytes()' blindly get and put
sequences of bytes from or to the underlying stream; they return `TRUE'
if they are successful, and `FALSE' otherwise.  The routines have
identical parameters (replace `xxx'):

     bool_t
     xxxbytes(xdrs, buf, bytecount)
             XDR *xdrs;
             char *buf;
             u_int bytecount;

   The operations `x_getlong()' and `x_putlong()' receive and put long
numbers from and to the data stream.  It is the responsibility of these
routines to translate the numbers between the machine representation
and the (standard) external representation.  The UNIX primitives
`htonl()' and `ntohl()' can be helpful in accomplishing this.  The
higher-level XDR implementation assumes that signed and unsigned long
integers contain the same number of bits, and that nonnegative integers
have the same bit representations as unsigned integers.  The routines
return `TRUE' if they succeed, and `FALSE' otherwise.  They have
identical parameters:

     bool_t
     xxxlong(xdrs, lp)
             XDR *xdrs;
             long *lp;

   Implementors of new XDR streams must make an XDR structure (with new
operation routines) available to clients, using some kind of create
routine.


@EndNode

@Node "Advanced Topics" "RPC.guide/Advanced Topics"
@Prev "XDR Library Primitives"
@Toc "XDR Technical Notes"

Advanced Topics
===============

   This section describes techniques for passing data structures that
are not covered in the preceding sections.  Such structures include
linked lists (of arbitrary lengths).  Unlike the simpler examples
covered in the earlier sections, the following examples are written
using both the XDR C library routines and the XDR data description
language.  The @{"XDR Protocol Specification" Link "XDR Protocol Specification"} describes this language in
complete detail.


 @{" Linked Lists " Link "Linked Lists"} 


@EndNode

@Node "Linked Lists" "RPC.guide/Linked Lists"
@Toc "Advanced Topics"

Linked Lists
------------

   The last example in the @{"Pointers" Link "Pointers"} topic earlier in this chapter
presented a C data structure and its associated XDR routines for a
individual's gross assets and liabilities.  The example is duplicated
below:

     struct gnumbers {
             long g_assets;
             long g_liabilities;
     };
     
     bool_t
     xdr_gnumbers(xdrs, gp)
             XDR *xdrs;
             struct gnumbers *gp;
     {
             if (xdr_long(xdrs, &(gp->g_assets)))
                     return(xdr_long(xdrs, &(gp->g_liabilities)));
             return(FALSE);
     }

   Now assume that we wish to implement a linked list of such
information.  A data structure could be constructed as follows:

     struct gnumbers_node {
             struct gnumbers gn_numbers;
             struct gnumbers_node *gn_next;
     };
     
     typedef struct gnumbers_node *gnumbers_list;

   The head of the linked list can be thought of as the data object;
that is, the head is not merely a convenient shorthand for a structure.
Similarly the `gn_next' field is used to indicate whether or not the
object has terminated.  Unfortunately, if the object continues, the
`gn_next' field is also the address of where it continues. The link
addresses carry no useful information when the object is serialized.

   The XDR data description of this linked list is described by the
recursive declaration of `gnumbers_list':

     struct gnumbers {
             int g_assets;
             int g_liabilities;
     };
     
     struct gnumbers_node {
             gnumbers gn_numbers;
             gnumbers_node *gn_next;
     };

   In this description, the boolean indicates whether there is more data
following it. If the boolean is `FALSE', then it is the last data field
of the structure. If it is `TRUE', then it is followed by a gnumbers
structure and (recursively) by a `gnumbers_list'.  Note that the C
declaration has no boolean explicitly declared in it (though the
`gn_next' field implicitly carries the information), while the XDR data
description has no pointer explicitly declared in it.

   Hints for writing the XDR routines for a `gnumbers_list' follow
easily from the XDR description above. Note how the primitive
`xdr_pointer()' is used to implement the XDR union above.

     bool_t
     xdr_gnumbers_node(xdrs, gn)
             XDR *xdrs;
             gnumbers_node *gn;
     {
             return(xdr_gnumbers(xdrs, &gn->gn_numbers) &&
                     xdr_gnumbers_list(xdrs, &gp->gn_next));
     }
     
     bool_t
     xdr_gnumbers_list(xdrs, gnp)
             XDR *xdrs;
             gnumbers_list *gnp;
     {
             return(xdr_pointer(xdrs, gnp,
                     sizeof(struct gnumbers_node),
                     xdr_gnumbers_node));
     }

   The unfortunate side effect of XDR'ing a list with these routines is
that the C stack grows linearly with respect to the number of node in
the list.  This is due to the recursion. The following routine collapses
the above two mutually recursive into a single, non-recursive one.

     bool_t
     xdr_gnumbers_list(xdrs, gnp)
             XDR *xdrs;
             gnumbers_list *gnp;
     {
             bool_t more_data;
             gnumbers_list *nextp;
     
             for (;;) {
                     more_data = (*gnp != NULL);
                     if (!xdr_bool(xdrs, &more_data)) {
                             return(FALSE);
                     }
                     if (! more_data) {
                             break;
                     }
                     if (xdrs->x_op == XDR_FREE) {
                             nextp = &(*gnp)->gn_next;
                     }
                     if (!xdr_reference(xdrs, gnp,
                             sizeof(struct gnumbers_node), xdr_gnumbers)) {
     
                     return(FALSE);
                     }
                     gnp = (xdrs->x_op == XDR_FREE) ?
                             nextp : &(*gnp)->gn_next;
             }
             *gnp = NULL;
             return(TRUE);
     }

   The first task is to find out whether there is more data or not, so
that this boolean information can be serialized. Notice that this
statement is unnecessary in the `XDR_DECODE' case, since the value of
`more_data' is not known until we deserialize it in the next statement.

   The next statement XDR's the more_data field of the XDR union.  Then
if there is truly no more data, we set this last pointer to `NULL' to
indicate the end of the list, and return `TRUE' because we are done.
Note that setting the pointer to `NULL' is only important in the
`XDR_DECODE' case, since it is already `NULL' in the `XDR_ENCODE' and
`XDR_FREE' cases.

   Next, if the direction is `XDR_FREE', the value of `nextp' is set to
indicate the location of the next pointer in the list.  We do this now
because we need to dereference gnp to find the location of the next
item in the list, and after the next statement the storage pointed to
by `gnp' will be freed up and no be longer valid.  We can't do this for
all directions though, because in the `XDR_DECODE' direction the value
of `gnp' won't be set until the next statement.

   Next, we XDR the data in the node using the primitive
`xdr_reference()'.  `xdr_reference()' is like `xdr_pointer()' which we
used before, but it does not send over the boolean indicating whether
there is more data.  We use it instead of `xdr_pointer()' because we
have already XDR'd this information ourselves. Notice that the xdr
routine passed is not the same type as an element in the list. The
routine passed is `xdr_gnumbers()', for XDR'ing gnumbers, but each
element in the list is actually of type `gnumbers_node'.  We don't pass
`xdr_gnumbers_node()' because it is recursive, and instead use
`xdr_gnumbers()' which XDR's all of the non-recursive part.  Note that
this trick will work only if the `gn_numbers' field is the first item
in each element, so that their addresses are identical when passed to
`xdr_reference()'.

   Finally, we update `gnp' to point to the next item in the list. If
the direction is `XDR_FREE', we set it to the previously saved value,
otherwise we can dereference `gnp' to get the proper value.  Though
harder to understand than the recursive version, this non-recursive
routine is far less likely to blow the C stack.  It will also run more
efficiently since a lot of procedure call overhead has been removed.
Most lists are small though (in the hundreds of items or less) and the
recursive version should be sufficient for them.


@EndNode

@Node "XDR Protocol Specification" "RPC.guide/XDR Protocol Specification"
@Next "Remote Procedure Calls Protocol Specification"
@Prev "XDR Technical Notes"
@Toc "Main"

External Data Representation Standard: Protocol Specification
*************************************************************

   This chapter specifies a protocol that Sun Microsystems, Inc., and
others are using.  It has been designated RFC1014 by the ARPA Network
Information Center.


 @{" Introduction to XDR " Link "Introduction to XDR"} 
 @{" XDR Data Types " Link "XDR Data Types"} 
 @{" Discussion " Link "Discussion"} 
 @{" The XDR Language Specification " Link "The XDR Language Specification"} 
 @{" An Example of an XDR Data Description " Link "An Example of an XDR Data Description"} 
 @{" XDR References " Link "XDR References"} 


@EndNode

@Node "Introduction to XDR" "RPC.guide/Introduction to XDR"
@Next "XDR Data Types"
@Toc "XDR Protocol Specification"

Introduction to XDR
===================

   XDR is a standard for the description and encoding of data.  It is
useful for transferring data between different computer architectures,
and has been used to communicate data between such diverse machines as
the Sun Workstation, VAX, IBM-PC, and Cray.  XDR fits into the ISO
presentation layer, and is roughly analogous in purpose to X.409, ISO
Abstract Syntax Notation.  The major difference between these two is
that XDR uses implicit typing, while X.409 uses explicit typing.

   XDR uses a language to describe data formats.  The language can only
be used only to describe data; it is not a programming language.  This
language allows one to describe intricate data formats in a concise
manner. The alternative of using graphical representations (itself an
informal language) quickly becomes incomprehensible when faced with
complexity.  The XDR language itself is similar to the C language [1],
just as Courier [4] is similar to Mesa. Protocols such as Sun RPC
(Remote Procedure Call) and the NFS (Network File System) use XDR to
describe the format of their data.

   The XDR standard makes the following assumption: that bytes (or
octets) are portable, where a byte is defined to be 8 bits of data.  A
given hardware device should encode the bytes onto the various media in
such a way that other hardware devices may decode the bytes without
loss of meaning.  For example, the Ethernet standard suggests that
bytes be encoded in "little-endian" style [2], or least significant bit
first.


 @{" Basic Block Size " Link "Basic Block Size"} 


@EndNode

@Node "Basic Block Size" "RPC.guide/Basic Block Size"
@Toc "Introduction to XDR"

Basic Block Size
----------------

   The representation of all items requires a multiple of four bytes
(or 32 bits) of data.  The bytes are numbered 0 through n-1.  The bytes
are read or written to some byte stream such that byte m always precedes
byte m+1.  If the n bytes needed to contain the data are not a multiple
of four, then the n bytes are followed by enough (0 to 3) residual zero
bytes, r, to make the total byte count a multiple of 4.

   We include the familiar graphic box notation for illustration and
comparison.  In most illustrations, each box (delimited by a plus sign
at the 4 corners and vertical bars and dashes) depicts a byte.  Ellipses
(...) between boxes show zero or more additional bytes where required.

     A Block
     
     +--------+--------+...+--------+--------+...+--------+
     | byte 0 | byte 1 |...|byte n-1|    0   |...|    0   |
     +--------+--------+...+--------+--------+...+--------+
     |<-----------n bytes---------->|<------r bytes------>|
     |<-----------n+r (where (n+r) mod 4 = 0)>----------->|


@EndNode

@Node "XDR Data Types" "RPC.guide/XDR Data Types"
@Next "Discussion"
@Prev "Introduction to XDR"
@Toc "XDR Protocol Specification"

XDR Data Types
==============

   Each of the sections that follow describes a data type defined in the
XDR standard, shows how it is declared in the language, and includes a
graphic illustration of its encoding.


 @{" Integer " Link "Integer"} 
 @{" Unsigned Integer " Link "Unsigned Integer"} 
 @{" Enumeration " Link "Enumeration"} 
 @{" Boolean " Link "Boolean"} 
 @{" Hyper Integer and Unsigned Hyper Integer " Link "Hyper Integer and Unsigned Hyper Integer"} 
 @{" Floating-point " Link "Floating-point"} 
 @{" Double-precision Floating-point " Link "Double-precision Floating-point"} 
 @{" Fixed-length Opaque Data " Link "Fixed-length Opaque Data"} 
 @{" Variable-length Opaque Data " Link "Variable-length Opaque Data"} 
 @{" String " Link "String"} 
 @{" Fixed-length Array " Link "Fixed-length Array"} 
 @{" Variable-length Array " Link "Variable-length Array"} 
 @{" Structure " Link "Structure"} 
 @{" Discriminated Union " Link "Discriminated Union"} 
 @{" Void " Link "Void"} 
 @{" Constant " Link "Constant"} 
 @{" Typedef (type definition) " Link "Typedef (type definition)"} 
 @{" Optional-data " Link "Optional-data"} 
 @{" Areas for Future Enhancement " Link "Areas for Future Enhancement"} 

   For each data type in the language we show a general paradigm
declaration.  Note that angle brackets (`<' and `>') denote variable
length sequences of data and square brackets (`[' and `]') denote
fixed-length sequences of data.  `n', `m' and `r' denote integers.  For
the full language specification and more formal definitions of terms
such as "identifier" and "declaration", refer to
@{"The XDR Language Specification" Link "The XDR Language Specification"}.

   For some data types, more specific examples are included.  A more
extensive example of a data description is in
@{"An Example of an XDR Data Description" Link "An Example of an XDR Data Description"}.


@EndNode

@Node "Integer" "RPC.guide/Integer"
@Next "Unsigned Integer"
@Toc "XDR Data Types"

Integer
-------

   An XDR signed integer is a 32-bit datum that encodes an integer in
the range [-2147483648,2147483647].  The integer is represented in two's
complement notation.  The most and least significant bytes are 0 and 3,
respectively.  Integers are declared as follows:

     Integer
     
     (MSB)                   (LSB)
     +-------+-------+-------+-------+
     |byte 0 |byte 1 |byte 2 |byte 3 |
     +-------+-------+-------+-------+
     <------------32 bits------------>


@EndNode

@Node "Unsigned Integer" "RPC.guide/Unsigned Integer"
@Next "Enumeration"
@Prev "Integer"
@Toc "XDR Data Types"

Unsigned Integer
----------------

   An XDR unsigned integer is a 32-bit datum that encodes a nonnegative
integer in the range [0,4294967295].  It is represented by an unsigned
binary number whose most and least significant bytes are 0 and 3,
respectively.  An unsigned integer is declared as follows:

     Unsigned Integer
     
     (MSB)                   (LSB)
     +-------+-------+-------+-------+
     |byte 0 |byte 1 |byte 2 |byte 3 |
     +-------+-------+-------+-------+
     <------------32 bits------------>


@EndNode

@Node "Enumeration" "RPC.guide/Enumeration"
@Next "Boolean"
@Prev "Unsigned Integer"
@Toc "XDR Data Types"

Enumeration
-----------

   Enumerations have the same representation as signed integers.
Enumerations are handy for describing subsets of the integers.
Enumerated data is declared as follows:

     enum { name-identifier = constant, ... } identifier;

   For example, the three colors red, yellow, and blue could be
described by an enumerated type:

     enum { RED = 2, YELLOW = 3, BLUE = 5 } colors;

   It is an error to encode as an enum any other integer than those that
have been given assignments in the enum declaration.


@EndNode

@Node "Boolean" "RPC.guide/Boolean"
@Next "Hyper Integer and Unsigned Hyper Integer"
@Prev "Enumeration"
@Toc "XDR Data Types"

Boolean
-------

   Booleans are important enough and occur frequently enough to warrant
their own explicit type in the standard.  Booleans are declared as
follows:

     bool identifier;

   This is equivalent to:

     enum { FALSE = 0, TRUE = 1 } identifier;


@EndNode

@Node "Hyper Integer and Unsigned Hyper Integer" "RPC.guide/Hyper Integer and Unsigned Hyper Integer"
@Next "Floating-point"
@Prev "Boolean"
@Toc "XDR Data Types"

Hyper Integer and Unsigned Hyper Integer
----------------------------------------

   The standard also defines 64-bit (8-byte) numbers called hyper
integer and unsigned hyper integer.  Their representations are the
obvious extensions of integer and unsigned integer defined above.  They
are represented in two's complement notation.  The most and least
significant bytes are 0 and 7, respectively.  Their declarations:

     Hyper Integer
     Unsigned Hyper Integer
     
     (MSB)                                                   (LSB)
     +-------+-------+-------+-------+-------+-------+-------+-------+
     |byte 0 |byte 1 |byte 2 |byte 3 |byte 4 |byte 5 |byte 6 |byte 7 |
     +-------+-------+-------+-------+-------+-------+-------+-------+
     <----------------------------64 bits---------------------------->


@EndNode

@Node "Floating-point" "RPC.guide/Floating-point"
@Next "Double-precision Floating-point"
@Prev "Hyper Integer and Unsigned Hyper Integer"
@Toc "XDR Data Types"

Floating-point
--------------

   The standard defines the floating-point data type `float' (32 bits
or 4 bytes).  The encoding used is the IEEE standard for normalized
single-precision floating-point numbers [3].  The following three fields
describe the single-precision floating-point number:

S:
     The sign of the number.  Values 0 and 1 represent positive and
     negative, respectively.  One bit.

E:
     The exponent of the number, base 2.  8 bits are devoted to this
     field.  The exponent is biased by 127.

F:
     The fractional part of the number's mantissa, base 2.  23 bits are
     devoted to this field.

   Therefore, the floating-point number is described by:

     (-1)^S * 2^(E-Bias) * 1.F

   It is declared as follows:

     Single-Precision Floating-Point
     
     +-------+-------+-------+-------+
     |byte 0 |byte 1 |byte 2 |byte 3 |
     S|   E   |           F          |
     +-------+-------+-------+-------+
     1|<- 8 ->|<-------23 bits------>|
     <------------32 bits------------>

   Just as the most and least significant bytes of a number are 0 and 3,
the most and least significant bits of a single-precision floating-
point number are 0 and 31.  The beginning bit (and most significant bit)
offsets of S, E, and F are 0, 1, and 9, respectively.  Note that these
numbers refer to the mathematical positions of the bits, and NOT to
their actual physical locations (which vary from medium to medium).

   The IEEE specifications should be consulted concerning the encoding
for signed zero, signed infinity (overflow), and denormalized numbers
(underflow) [3].  According to IEEE specifications, the `NaN' (not a
number) is system dependent and should not be used externally.


@EndNode

@Node "Double-precision Floating-point" "RPC.guide/Double-precision Floating-point"
@Next "Fixed-length Opaque Data"
@Prev "Floating-point"
@Toc "XDR Data Types"

Double-precision Floating-point
-------------------------------

   The standard defines the encoding for the double-precision floating-
point data type `double' (64 bits or 8 bytes).  The encoding used is
the IEEE standard for normalized double-precision floating-point
numbers [3].  The standard encodes the following three fields, which
describe the double-precision floating-point number:

S:
     The sign of the number.  Values 0 and 1 represent positive and
     negative, respectively.  One bit.

E:
     The exponent of the number, base 2.  11 bits are devoted to this
     field.  The exponent is biased by 1023.

F:
     The fractional part of the number's mantissa, base 2.  52 bits are
     devoted to this field.

   Therefore, the floating-point number is described by:

     (-1)^S * 2^(E-Bias) * 1.F

   It is declared as follows:

     Double-Precision Floating-Point
     
     +------+------+------+------+------+------+------+------+
     |byte 0|byte 1|byte 2|byte 3|byte 4|byte 5|byte 6|byte 7|
     S|    E   |                    F                        |
     +------+------+------+------+------+------+------+------+
     1|<--11-->|<-----------------52 bits------------------->|
     <-----------------------64 bits------------------------->

   Just as the most and least significant bytes of a number are 0 and 3,
the most and least significant bits of a double-precision floating-
point number are 0 and 63.  The beginning bit (and most significant bit)
offsets of S, E , and F are 0, 1, and 12, respectively.  Note that these
numbers refer to the mathematical positions of the bits, and NOT to
their actual physical locations (which vary from medium to medium).

   The IEEE specifications should be consulted concerning the encoding
for signed zero, signed infinity (overflow), and denormalized numbers
(underflow) [3].  According to IEEE specifications, the `NaN' (not a
number) is system dependent and should not be used externally.


@EndNode

@Node "Fixed-length Opaque Data" "RPC.guide/Fixed-length Opaque Data"
@Next "Variable-length Opaque Data"
@Prev "Double-precision Floating-point"
@Toc "XDR Data Types"

Fixed-length Opaque Data
------------------------

   At times, fixed-length uninterpreted data needs to be passed among
machines.  This data is called `opaque' and is declared as follows:

     opaque identifier[n];

   where the constant n is the (static) number of bytes necessary to
contain the opaque data.  If n is not a multiple of four, then the n
bytes are followed by enough (0 to 3) residual zero bytes, r, to make
the total byte count of the opaque object a multiple of four.

     Fixed-Length Opaque
     
     0        1     ...
     +--------+--------+...+--------+--------+...+--------+
     | byte 0 | byte 1 |...|byte n-1|    0   |...|    0   |
     +--------+--------+...+--------+--------+...+--------+
     |<-----------n bytes---------->|<------r bytes------>|
     |<-----------n+r (where (n+r) mod 4 = 0)------------>|


@EndNode

@Node "Variable-length Opaque Data" "RPC.guide/Variable-length Opaque Data"
@Next "String"
@Prev "Fixed-length Opaque Data"
@Toc "XDR Data Types"

Variable-length Opaque Data
---------------------------

   The standard also provides for variable-length (counted) opaque data,
defined as a sequence of n (numbered 0 through n-1) arbitrary bytes to
be the number n encoded as an unsigned integer (as described below), and
followed by the n bytes of the sequence.

   Byte m of the sequence always precedes byte m+1 of the sequence, and
byte 0 of the sequence always follows the sequence's length (count).
enough (0 to 3) residual zero bytes, r, to make the total byte count a
multiple of four.  Variable-length opaque data is declared in the
following way:

     opaque identifier<m>;

   or

     opaque identifier<>;

   The constant m denotes an upper bound of the number of bytes that the
sequence may contain.  If m is not specified, as in the second
declaration, it is assumed to be (2^32) - 1, the maximum length.  The
constant m would normally be found in a protocol specification.  For
example, a filing protocol may state that the maximum data transfer size
is 8192 bytes, as follows:

     opaque filedata<8192>;

   This can be illustrated as follows:

     Variable-Length Opaque
     
     0     1     2     3     4     5   ...
     +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+
     |        length n       |byte0|byte1|...| n-1 |  0  |...|  0  |
     +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+
     |<-------4 bytes------->|<------n bytes------>|<---r bytes--->|
                             |<----n+r (where (n+r) mod 4 = 0)---->|

   It is an error to encode a length greater than the maximum described
in the specification.


@EndNode

@Node "String" "RPC.guide/String"
@Next "Fixed-length Array"
@Prev "Variable-length Opaque Data"
@Toc "XDR Data Types"

String
------

   The standard defines a string of n (numbered 0 through n-1) ASCII
bytes to be the number n encoded as an unsigned integer (as described
above), and followed by the n bytes of the string.  Byte m of the
string always precedes byte m+1 of the string, and byte 0 of the string
always follows the string's length.  If n is not a multiple of four,
then the n bytes are followed by enough (0 to 3) residual zero bytes,
r, to make the total byte count a multiple of four.  Counted byte
strings are declared as follows:

     string object<m>;

   or

     string object<>;

   The constant m denotes an upper bound of the number of bytes that a
string may contain.  If m is not specified, as in the second
declaration, it is assumed to be (2^32) - 1, the maximum length.  The
constant m would normally be found in a protocol specification.  For
example, a filing protocol may state that a file name can be no longer
than 255 bytes, as follows:

     string filename<255>;

   Which can be illustrated as:

     A String
     
     0     1     2     3     4     5   ...
     +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+
     |        length n       |byte0|byte1|...| n-1 |  0  |...|  0  |
     +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+
     |<-------4 bytes------->|<------n bytes------>|<---r bytes--->|
                             |<----n+r (where (n+r) mod 4 = 0)---->|

   It is an error to encode a length greater than the maximum described
in the specification.


@EndNode

@Node "Fixed-length Array" "RPC.guide/Fixed-length Array"
@Next "Variable-length Array"
@Prev "String"
@Toc "XDR Data Types"

Fixed-length Array
------------------

   Declarations for fixed-length arrays of homogeneous elements are in
the following form:

     type-name identifier[n];

   Fixed-length arrays of elements numbered 0 through n-1 are encoded by
individually encoding the elements of the array in their natural order,
0 through n-1.  Each element's size is a multiple of four bytes. Though
all elements are of the same type, the elements may have different
sizes.  For example, in a fixed-length array of strings, all elements
are of type `string', yet each element will vary in its length.

     Fixed-Length Array
     
     +---+---+---+---+---+---+---+---+...+---+---+---+---+
     |   element 0   |   element 1   |...|  element n-1  |
     +---+---+---+---+---+---+---+---+...+---+---+---+---+
     |<--------------------n elements------------------->|


@EndNode

@Node "Variable-length Array" "RPC.guide/Variable-length Array"
@Next "Structure"
@Prev "Fixed-length Array"
@Toc "XDR Data Types"

Variable-length Array
---------------------

   Counted arrays provide the ability to encode variable-length arrays
of homogeneous elements.  The array is encoded as the element count n
(an unsigned integer) followed by the encoding of each of the array's
elements, starting with element 0 and progressing through element n- 1.
The declaration for variable-length arrays follows this form:

     type-name identifier<m>;

   or

     type-name identifier<>;

   The constant m specifies the maximum acceptable element count of an
array; if m is not specified, as in the second declaration, it is
assumed to be (2^32) - 1.

     Counted Array
     
     0  1  2  3
     +--+--+--+--+--+--+--+--+--+--+--+--+...+--+--+--+--+
     |     n     | element 0 | element 1 |...|element n-1|
     +--+--+--+--+--+--+--+--+--+--+--+--+...+--+--+--+--+
     |<-4 bytes->|<--------------n elements------------->|

   It is an error to encode a value of n that is greater than the
maximum described in the specification.


@EndNode

@Node "Structure" "RPC.guide/Structure"
@Next "Discriminated Union"
@Prev "Variable-length Array"
@Toc "XDR Data Types"

Structure
---------

   Structures are declared as follows:

     struct {
             component-declaration-A;
             component-declaration-B;
             ...
     } identifier;

   The components of the structure are encoded in the order of their
declaration in the structure.  Each component's size is a multiple of
four bytes, though the components may be different sizes.

     Structure
     
     +-------------+-------------+...
     | component A | component B |...
     +-------------+-------------+...


@EndNode

@Node "Discriminated Union" "RPC.guide/Discriminated Union"
@Next "Void"
@Prev "Structure"
@Toc "XDR Data Types"

Discriminated Union
-------------------

   A discriminated union is a type composed of a discriminant followed
by a type selected from a set of prearranged types according to the
value of the discriminant.  The type of discriminant is either `int',
`unsigned int', or an enumerated type, such as `bool'.  The component
types are called "arms" of the union, and are preceded by the value of
the discriminant which implies their encoding.  Discriminated unions
are declared as follows:

     union switch (discriminant-declaration) {
             case discriminant-value-A:
             arm-declaration-A;
             case discriminant-value-B:
             arm-declaration-B;
             ...
             default: default-declaration;
     } identifier;

   Each `case' keyword is followed by a legal value of the
discriminant.  The default arm is optional.  If it is not specified,
then a valid encoding of the union cannot take on unspecified
discriminant values.  The size of the implied arm is always a multiple
of four bytes.

   The discriminated union is encoded as its discriminant followed by
the encoding of the implied arm.

     Discriminated Union
     
     0   1   2   3
     +---+---+---+---+---+---+---+---+
     |  discriminant |  implied arm  |
     +---+---+---+---+---+---+---+---+
     |<---4 bytes--->|


@EndNode

@Node "Void" "RPC.guide/Void"
@Next "Constant"
@Prev "Discriminated Union"
@Toc "XDR Data Types"

Void
----

   An XDR void is a 0-byte quantity.  Voids are useful for describing
operations that take no data as input or no data as output. They are
also useful in unions, where some arms may contain data and others do
not.  The declaration is simply as follows:

     void;

   Voids are illustrated as follows:

     Void
     
       ++
       ||
       ++
     --><-- 0 bytes


@EndNode

@Node "Constant" "RPC.guide/Constant"
@Next "Typedef (type definition)"
@Prev "Void"
@Toc "XDR Data Types"

Constant
--------

   The data declaration for a constant follows this form:

     const name-identifier = n;

   `const' is used to define a symbolic name for a constant; it does
not declare any data.  The symbolic constant may be used anywhere a
regular constant may be used.  For example, the following defines a
symbolic constant DOZEN, equal to 12.

     const DOZEN = 12;


@EndNode

@Node "Typedef (type definition)" "RPC.guide/Typedef (type definition)"
@Next "Optional-data"
@Prev "Constant"
@Toc "XDR Data Types"

Typedef
-------

   `typedef' does not declare any data either, but serves to define new
identifiers for declaring data. The syntax is:

     typedef declaration;

   The new type name is actually the variable name in the declaration
part of the typedef.  For example, the following defines a new type
called `eggbox' using an existing type called `egg':

     typedef egg eggbox[DOZEN];

   Variables declared using the new type name have the same type as the
new type name would have in the typedef, if it was considered a
variable.  For example, the following two declarations are equivalent
in declaring the variable `fresheggs':

     eggbox  fresheggs;
     egg     fresheggs[DOZEN];

   When a typedef involves a struct, enum, or union definition, there is
another (preferred) syntax that may be used to define the same type.  In
general, a typedef of the following form:

     typedef <<struct, union, or enum definition>> identifier;

   may be converted to the alternative form by removing the `typedef'
part and placing the identifier after the `struct', `union', or `enum'
keyword, instead of at the end.  For example, here are the two ways to
define the type `bool':

     typedef enum {    /* using typedef */
             FALSE = 0,
             TRUE = 1
             } bool;
     
     enum bool {       /* preferred alternative */
             FALSE = 0,
             TRUE = 1
             };

   The reason this syntax is preferred is one does not have to wait
until the end of a declaration to figure out the name of the new type.


@EndNode

@Node "Optional-data" "RPC.guide/Optional-data"
@Next "Areas for Future Enhancement"
@Prev "Typedef (type definition)"
@Toc "XDR Data Types"

Optional-data
-------------

   Optional-data is one kind of union that occurs so frequently that we
give it a special syntax of its own for declaring it.  It is declared as
follows:

     type-name *identifier;

   This is equivalent to the following union:

     union switch (bool opted) {
             case TRUE:
             type-name element;
             case FALSE:
             void;
     } identifier;

   It is also equivalent to the following variable-length array
declaration, since the boolean `opted' can be interpreted as the length
of the array:

     type-name identifier<1>;

   Optional-data is not so interesting in itself, but it is very useful
for describing recursive data-structures such as linked-lists and trees.
For example, the following defines a type `stringlist' that encodes
lists of arbitrary length strings:

     struct *stringlist {
             string item<>;
             stringlist next;
     };

   It could have been equivalently declared as the following union:

     union stringlist switch (bool opted) {
             case TRUE:
                     struct {
                             string item<>;
                             stringlist next;
                     } element;
             case FALSE:
                     void;
     };

   or as a variable-length array:

     struct stringlist<1> {
             string item<>;
             stringlist next;
     };

   Both of these declarations obscure the intention of the stringlist
type, so the optional-data declaration is preferred over both of them.
The optional-data type also has a close correlation to how recursive
data structures are represented in high-level languages such as Pascal
or C by use of pointers. In fact, the syntax is the same as that of the
C language for pointers.


@EndNode

@Node "Areas for Future Enhancement" "RPC.guide/Areas for Future Enhancement"
@Prev "Optional-data"
@Toc "XDR Data Types"

Areas for Future Enhancement
----------------------------

   The XDR standard lacks representations for bit fields and bitmaps,
since the standard is based on bytes.  Also missing are packed (or
binary-coded) decimals.

   The intent of the XDR standard was not to describe every kind of data
that people have ever sent or will ever want to send from machine to
machine. Rather, it only describes the most commonly used data-types of
high-level languages such as Pascal or C so that applications written in
these languages will be able to communicate easily over some medium.

   One could imagine extensions to XDR that would let it describe almost
any existing protocol, such as TCP.  The minimum necessary for this are
support for different block sizes and byte-orders.  The XDR discussed
here could then be considered the 4-byte big-endian member of a larger
XDR family.


@EndNode

@Node "Discussion" "RPC.guide/Discussion"
@Next "The XDR Language Specification"
@Prev "XDR Data Types"
@Toc "XDR Protocol Specification"

Discussion
==========


 @{" Why a Language for Describing Data? " Link "Why a Language for Describing Data?"} 
 @{" Why Only one Byte-Order for an XDR Unit? " Link "Why Only one Byte-Order for an XDR Unit?"} 
 @{" Why does XDR use Big-Endian Byte-Order? " Link "Why does XDR use Big-Endian Byte-Order?"} 
 @{" Why is the XDR Unit Four Bytes Wide? " Link "Why is the XDR Unit Four Bytes Wide?"} 
 @{" Why must Variable-Length Data be Padded with Zeros? " Link "Why must Variable-Length Data be Padded with Zeros?"} 
 @{" Why is there No Explicit Data-Typing? " Link "Why is there No Explicit Data-Typing?"} 


@EndNode

@Node "Why a Language for Describing Data?" "RPC.guide/Why a Language for Describing Data?"
@Next "Why Only one Byte-Order for an XDR Unit?"
@Toc "Discussion"

Why a Language for Describing Data?
-----------------------------------

   There are many advantages in using a data-description language such
as XDR versus using diagrams.  Languages are more formal than diagrams
and lead to less ambiguous descriptions of data.  Languages are also
easier to understand and allow one to think of other issues instead of
the low-level details of bit-encoding.  Also, there is a close analogy
between the types of XDR and a high-level language such as C or Pascal.
This makes the implementation of XDR encoding and decoding modules an
easier task.  Finally, the language specification itself is an ASCII
string that can be passed from machine to machine to perform on-the-fly
data interpretation.


@EndNode

@Node "Why Only one Byte-Order for an XDR Unit?" "RPC.guide/Why Only one Byte-Order for an XDR Unit?"
@Next "Why does XDR use Big-Endian Byte-Order?"
@Prev "Why a Language for Describing Data?"
@Toc "Discussion"

Why Only one Byte-Order for an XDR Unit?
----------------------------------------

   Supporting two byte-orderings requires a higher level protocol for
determining in which byte-order the data is encoded.  Since XDR is not a
protocol, this can't be done.  The advantage of this, though, is that
data in XDR format can be written to a magnetic tape, for example, and
any machine will be able to interpret it, since no higher level protocol
is necessary for determining the byte-order.


@EndNode

@Node "Why does XDR use Big-Endian Byte-Order?" "RPC.guide/Why does XDR use Big-Endian Byte-Order?"
@Next "Why is the XDR Unit Four Bytes Wide?"
@Prev "Why Only one Byte-Order for an XDR Unit?"
@Toc "Discussion"

Why does XDR use Big-Endian Byte-Order?
---------------------------------------

   Yes, it is unfair, but having only one byte-order means you have to
be unfair to somebody.  Many architectures, such as the Motorola 68000
and IBM 370, support the big-endian byte-order.


@EndNode

@Node "Why is the XDR Unit Four Bytes Wide?" "RPC.guide/Why is the XDR Unit Four Bytes Wide?"
@Next "Why must Variable-Length Data be Padded with Zeros?"
@Prev "Why does XDR use Big-Endian Byte-Order?"
@Toc "Discussion"

Why is the XDR Unit Four Bytes Wide?
------------------------------------

   There is a tradeoff in choosing the XDR unit size.  Choosing a small
size such as two makes the encoded data small, but causes alignment
problems for machines that aren't aligned on these boundaries.  A large
size such as eight means the data will be aligned on virtually every
machine, but causes the encoded data to grow too big.  We chose four as
a compromise.  Four is big enough to support most architectures
efficiently, except for rare machines such as the eight-byte aligned
Cray.  Four is also small enough to keep the encoded data restricted to
a reasonable size.


@EndNode

@Node "Why must Variable-Length Data be Padded with Zeros?" "RPC.guide/Why must Variable-Length Data be Padded with Zeros?"
@Next "Why is there No Explicit Data-Typing?"
@Prev "Why is the XDR Unit Four Bytes Wide?"
@Toc "Discussion"

Why must Variable-Length Data be Padded with Zeros?
---------------------------------------------------

   It is desirable that the same data encode into the same thing on all
machines, so that encoded data can be meaningfully compared or
checksummed.  Forcing the padded bytes to be zero ensures this.


@EndNode

@Node "Why is there No Explicit Data-Typing?" "RPC.guide/Why is there No Explicit Data-Typing?"
@Prev "Why must Variable-Length Data be Padded with Zeros?"
@Toc "Discussion"

Why is there No Explicit Data-Typing?
-------------------------------------

   Data-typing has a relatively high cost for what small advantages it
may have.  One cost is the expansion of data due to the inserted type
fields.  Another is the added cost of interpreting these type fields and
acting accordingly.  And most protocols already know what type they
expect, so data-typing supplies only redundant information.  However,
one can still get the benefits of data-typing using XDR. One way is to
encode two things: first a string which is the XDR data description of
the encoded data, and then the encoded data itself.  Another way is to
assign a value to all the types in XDR, and then define a universal type
which takes this value as its discriminant and for each value, describes
the corresponding data type.


@EndNode

@Node "The XDR Language Specification" "RPC.guide/The XDR Language Specification"
@Next "An Example of an XDR Data Description"
@Prev "Discussion"
@Toc "XDR Protocol Specification"

The XDR Language Specification
==============================


 @{" Notational Conventions " Link "Notational Conventions"} 
 @{" Lexical Notes " Link "Lexical Notes"} 
 @{" Syntax Information " Link "Syntax Information"} 


@EndNode

@Node "Notational Conventions" "RPC.guide/Notational Conventions"
@Next "Lexical Notes"
@Toc "The XDR Language Specification"

Notational Conventions
----------------------

   This specification uses an extended Backus-Naur Form notation for
describing the XDR language.  Here is a brief description of the
notation:

   * The characters `|', `(', `)', `[', `]', `"', and `*' are special.

   * Terminal symbols are strings of any characters surrounded by double
     quotes.

   * Non-terminal symbols are strings of non-special characters.

   * Alternative items are separated by a vertical bar (`|').

   * Optional items are enclosed in brackets.

   * Items are grouped together by enclosing them in parentheses.

   * A `*' following an item means 0 or more occurrences of that item.

   For example, consider the following pattern:

     "a " "very" (", " " very")* [" cold " "and"]  " rainy " ("day" | "night")

   An infinite number of strings match this pattern. A few of them are:

     "a very rainy day"
     "a very, very rainy day"
     "a very cold and  rainy day"
     "a very, very, very cold and  rainy night"


@EndNode

@Node "Lexical Notes" "RPC.guide/Lexical Notes"
@Next "Syntax Information"
@Prev "Notational Conventions"
@Toc "The XDR Language Specification"

Lexical Notes
-------------

  1. Comments begin with `/*' and terminate with `*/'.

  2. White space serves to separate items and is otherwise ignored.

  3. An identifier is a letter followed by an optional sequence of
     letters, digits or underbar (`_').  The case of identifiers is not
     ignored.

  4. A constant is a sequence of one or more decimal digits, optionally
     preceded by a minus-sign (`-').


@EndNode

@Node "Syntax Information" "RPC.guide/Syntax Information"
@Prev "Lexical Notes"
@Toc "The XDR Language Specification"

Syntax Information
------------------


 @{" XDR Syntax Notes " Link "XDR Syntax Notes"} 

     declaration:
             type-specifier identifier
             | type-specifier identifier "[" value "]"
             | type-specifier identifier "<" [ value ] ">"
             | "opaque" identifier "[" value "]"
             | "opaque" identifier "<" [ value ] ">"
             | "string" identifier "<" [ value ] ">"
             | type-specifier "*" identifier
             | "void"

     value:
             constant
             | identifier
     
     type-specifier:
               [ "unsigned" ] "int"
             | [ "unsigned" ] "hyper"
             | "float"
             | "double"
             | "bool"
             | enum-type-spec
             | struct-type-spec
             | union-type-spec
             | identifier

     enum-type-spec:
             "enum" enum-body
     
     enum-body:
             "{"
             ( identifier "=" value )
             ( "," identifier "=" value )*
             "}"

     struct-type-spec:
             "struct" struct-body
     
     struct-body:
             "{"
             ( declaration ";" )
             ( declaration ";" )*
             "}"

     union-type-spec:
             "union" union-body
     
     union-body:
             "switch" "(" declaration ")" "{"
             ( "case" value ":" declaration ";" )
             ( "case" value ":" declaration ";" )*
             [ "default" ":" declaration ";" ]
             "}"
     
     constant-def:
             "const" identifier "=" constant ";"

     type-def:
             "typedef" declaration ";"
             | "enum" identifier enum-body ";"
             | "struct" identifier struct-body ";"
             | "union" identifier union-body ";"
     
     definition:
             type-def
             | constant-def
     
     specification:
             definition *


@EndNode

@Node "XDR Syntax Notes" "RPC.guide/XDR Syntax Notes"
@Toc "Syntax Information"

Syntax Notes
............

  1. The following are keywords and cannot be used as identifiers:

          `bool', `case', `const', `default', `double',
          `enum', `float', `hyper', `opaque', `string',
          `struct', `switch', `typedef', `union',
          `unsigned' and `void'.

  2. Only unsigned constants may be used as size specifications for
     arrays.  If an identifier is used, it must have been declared
     previously as an unsigned constant in a `const' definition.

  3. Constant and type identifiers within the scope of a specification
     are in the same name space and must be declared uniquely within
     this scope.

  4. Similarly, variable names must be unique within the scope of
     struct and union declarations. Nested struct and union
     declarations create new scopes.

  5. The discriminant of a union must be of a type that evaluates to an
     integer. That is, `int', `unsigned int', `bool', an enumerated
     type or any typedefed type that evaluates to one of these is
     legal.  Also, the case values must be one of the legal values of
     the discriminant.  Finally, a case value may not be specified more
     than once within the scope of a union declaration.


@EndNode

@Node "An Example of an XDR Data Description" "RPC.guide/An Example of an XDR Data Description"
@Next "XDR References"
@Prev "The XDR Language Specification"
@Toc "XDR Protocol Specification"

An Example of an XDR Data Description
=====================================

   Here is a short XDR data description of a thing called a "file",
which might be used to transfer files from one machine to another.


     const MAXUSERNAME = 32;     /* max length of a user name */
     const MAXFILELEN = 65535;   /* max length of a file      */
     const MAXNAMELEN = 255;     /* max length of a file name */
     
     /*
      * Types of files:
      */
     enum filekind {
             TEXT = 0,       /* ascii data */
             DATA = 1,       /* raw data   */
             EXEC = 2        /* executable */
     };
     
     /*
      * File information, per kind of file:
      */
     union filetype switch (filekind kind) {
             case TEXT:
                     void;                           /* no extra information */
             case DATA:
                     string creator<MAXNAMELEN>;     /* data creator         */
             case EXEC:
                     string interpretor<MAXNAMELEN>; /* program interpretor  */
     };
     
     /*
      * A complete file:
      */
     struct file {
             string filename<MAXNAMELEN>; /* name of file */
             filetype type;               /* info about file */
             string owner<MAXUSERNAME>;   /* owner of file   */
             opaque data<MAXFILELEN>;     /* file data       */
     };

   Suppose now that there is a user named "john" who wants to store his
lisp program `sillyprog' that contains just the data "(quit)".  His
file would be encoded as follows:

     Offset  Hex Bytes   ASCII  Description
     
     0       00 00 00 09 ....   Length of filename = 9
     4       73 69 6c 6c sill   Filename characters
     8       79 70 72 6f ypro   ... and more characters ...
     12      67 00 00 00 g...   ... and 3 zero-bytes of fill
     16      00 00 00 02 ....   Filekind is EXEC = 2
     20      00 00 00 04 ....   Length of interpretor = 4
     24      6c 69 73 70 lisp   Interpretor characters
     28      00 00 00 04 ....   Length of owner = 4
     32      6a 6f 68 6e john   Owner characters
     36      00 00 00 06 ....   Length of file data = 6
     40      28 71 75 69 (qui   File data bytes ...
     44      74 29 00 00 t)..   ... and 2 zero-bytes of fill


@EndNode

@Node "XDR References" "RPC.guide/XDR References"
@Prev "An Example of an XDR Data Description"
@Toc "XDR Protocol Specification"

References
==========

[1]
     Brian W. Kernighan & Dennis M. Ritchie, `The C Programming
     Language', Bell Laboratories, Murray Hill, New Jersey, 1978.

[2]
     Danny Cohen, `On Holy Wars and a Plea for Peace', IEEE Computer,
     October 1981.

[3]
     `IEEE Standard for Binary Floating-Point Arithmetic', ANSI/IEEE
     Standard 754-1985, Institute of Electrical and Electronics
     Engineers, August 1985.

[4]
     `Courier: The Remote Procedure Call Protocol', XEROX Corporation,
     XSIS 038112, December 1981.


@EndNode

@Node "Remote Procedure Calls Protocol Specification" "RPC.guide/Remote Procedure Calls Protocol Specification"
@Next "Network File System Version 2 Protocol Specification"
@Prev "XDR Protocol Specification"
@Toc "Main"

Remote Procedure Calls: Protocol Specification
**********************************************

   This chapter specifies a protocol that Sun Microsystems, Inc., and
others are using.  It has been designated RFC1050 by the ARPA Network
Information Center.


 @{" Introduction to RPC " Link "Introduction to RPC"} 
 @{" RPC Protocol Requirements " Link "RPC Protocol Requirements"} 
 @{" The RPC Message Protocol " Link "The RPC Message Protocol"} 
 @{" Authentication Protocols " Link "Authentication Protocols"} 
 @{" Record Marking Standard " Link "Record Marking Standard"} 
 @{" The RPC Language " Link "The RPC Language"} 
 @{" Port Mapper Program Protocol " Link "Port Mapper Program Protocol"} 
 @{" RPC References " Link "RPC References"} 


@EndNode

@Node "Introduction to RPC" "RPC.guide/Introduction to RPC"
@Next "RPC Protocol Requirements"
@Toc "Remote Procedure Calls Protocol Specification"

Introduction to RPC
===================

   This chapter specifies a message protocol used in implementing Sun's
Remote Procedure Call (RPC) package.  (The message protocol is specified
with the External Data Representation (XDR) language.  see
@{"XDR Protocol Specification" Link "XDR Protocol Specification"} for the details.  Here, we assume that the
reader is familiar with XDR and do not attempt to justify it or its
uses).  The paper by Birrell and Nelson [1] is recommended as an
excellent background to and justification of RPC.


 @{" Terminology " Link "Terminology"} 
 @{" The RPC Model " Link "The RPC Model"} 
 @{" Transports and Semantics " Link "Transports and Semantics"} 
 @{" Binding and Rendezvous Independence " Link "Binding and Rendezvous Independence"} 
 @{" Authentication " Link "Authentication"} 


@EndNode

@Node "Terminology" "RPC.guide/Terminology"
@Next "The RPC Model"
@Toc "Introduction to RPC"

Terminology
-----------

   This chapter discusses servers, services, programs, procedures,
clients, and versions.  A "server" is a piece of software where network
services are implemented.  A "network service" is a collection of one
or more remote programs.  A "remote program" implements one or more
remote procedures; the procedures, their parameters, and results are
documented in the specific program's "protocol specification" (see the
@{"Port Mapper Program Protocol" Link "Port Mapper Program Protocol"}, below, for an example).  "Network
clients" are pieces of software that initiate remote procedure calls to
services.  A server may support more than one version of a remote
program in order to be forward compatible with changing protocols.

   For example, a network file service may be composed of two programs.
One program may deal with high-level applications such as file system
access control and locking.  The other may deal with low-level file IO
and have procedures like `read' and `write'.  A client machine of the
network file service would call the procedures associated with the two
programs of the service on behalf of some user on the client machine.


@EndNode

@Node "The RPC Model" "RPC.guide/The RPC Model"
@Next "Transports and Semantics"
@Prev "Terminology"
@Toc "Introduction to RPC"

The RPC Model
-------------

   The remote procedure call model is similar to the local procedure
call model.  In the local case, the caller places arguments to a
procedure in some well-specified location (such as a result register).
It then transfers control to the procedure, and eventually gains back
control.  At that point, the results of the procedure are extracted
from the well-specified location, and the caller continues execution.

   The remote procedure call is similar, in that one thread of control
logically winds through two processes -- one is the caller's process,
the other is a server's process.  That is, the caller process sends a
call message to the server process and waits (blocks) for a reply
message.  The call message contains the procedure's parameters, among
other things.  The reply message contains the procedure's results, among
other things.  Once the reply message is received, the results of the
procedure are extracted, and caller's execution is resumed.

   On the server side, a process is dormant awaiting the arrival of a
call message.  When one arrives, the server process extracts the
procedure's parameters, computes the results, sends a reply message,
and then awaits the next call message.

   Note that in this model, only one of the two processes is active at
any given time.  However, this model is only given as an example.  The
RPC protocol makes no restrictions on the concurrency model
implemented, and others are possible.  For example, an implementation
may choose to have RPC calls be asynchronous, so that the client may do
useful work while waiting for the reply from the server.  Another
possibility is to have the server create a task to process an incoming
request, so that the server can be free to receive other requests.


@EndNode

@Node "Transports and Semantics" "RPC.guide/Transports and Semantics"
@Next "Binding and Rendezvous Independence"
@Prev "The RPC Model"
@Toc "Introduction to RPC"

Transports and Semantics
------------------------

   The RPC protocol is independent of transport protocols.  That is, RPC
does not care how a message is passed from one process to another.  The
protocol deals only with specification and interpretation of messages.

   It is important to point out that RPC does not try to implement any
kind of reliability and that the application must be aware of the type
of transport protocol underneath RPC.  If it knows it is running on top
of a reliable transport such as TCP/IP[6], then most of the work is
already done for it.  On the other hand, if it is running on top of an
unreliable transport such as UDP/IP[7], it must implement is own
retransmission and time-out policy as the RPC layer does not provide
this service.

   Because of transport independence, the RPC protocol does not attach
specific semantics to the remote procedures or their execution.
Semantics can be inferred from (but should be explicitly specified by)
the underlying transport protocol.  For example, consider RPC running on
top of an unreliable transport such as UDP/IP.  If an application
retransmits RPC messages after short time-outs, the only thing it can
infer if it receives no reply is that the procedure was executed zero or
more times.  If it does receive a reply, then it can infer that the
procedure was executed at least once.

   A server may wish to remember previously granted requests from a
client and not regrant them in order to insure some degree of
execute-at-most-once semantics.  A server can do this by taking
advantage of the transaction ID that is packaged with every RPC request.
The main use of this transaction is by the client RPC layer in matching
replies to requests.  However, a client application may choose to reuse
its previous transaction ID when retransmitting a request.  The server
application, knowing this fact, may choose to remember this ID after
granting a request and not regrant requests with the same ID in order to
achieve some degree of execute-at-most-once semantics.  The server is
not allowed to examine this ID in any other way except as a test for
equality.

   On the other hand, if using a reliable transport such as TCP/IP, the
application can infer from a reply message that the procedure was
executed exactly once, but if it receives no reply message, it cannot
assume the remote procedure was not executed.  Note that even if a
connection-oriented protocol like TCP is used, an application still
needs time-outs and reconnection to handle server crashes.

   There are other possibilities for transports besides datagram- or
connection-oriented protocols.  For example, a request-reply protocol
such as VMTP[2] is perhaps the most natural transport for RPC.

   *NOTE:* At Sun, RPC is currently implemented on top of both TCP/IP
and UDP/IP transports.


@EndNode

@Node "Binding and Rendezvous Independence" "RPC.guide/Binding and Rendezvous Independence"
@Next "Authentication"
@Prev "Transports and Semantics"
@Toc "Introduction to RPC"

Binding and Rendezvous Independence
-----------------------------------

   The act of binding a client to a service is NOT part of the remote
procedure call specification.  This important and necessary function is
left up to some higher-level software.  (The software may use RPC itself
-- see the @{"Port Mapper Program Protocol" Link "Port Mapper Program Protocol"}, below).

   Implementors should think of the RPC protocol as the jump-subroutine
instruction (`JSR') of a network; the loader (binder) makes `JSR'
useful, and the loader itself uses `JSR' to accomplish its task.
Likewise, the network makes RPC useful, using RPC to accomplish this
task.


@EndNode

@Node "Authentication" "RPC.guide/Authentication"
@Prev "Binding and Rendezvous Independence"
@Toc "Introduction to RPC"

Authentication
--------------

   The RPC protocol provides the fields necessary for a client to
identify itself to a service and vice-versa.  Security and access
control mechanisms can be built on top of the message authentication.
Several different authentication protocols can be supported.  A field
in the RPC header indicates which protocol is being used.  More
information on specific authentication protocols can be found in the
@{"Authentication Protocols" Link "Authentication Protocols"}, below.


@EndNode

@Node "RPC Protocol Requirements" "RPC.guide/RPC Protocol Requirements"
@Next "The RPC Message Protocol"
@Prev "Introduction to RPC"
@Toc "Remote Procedure Calls Protocol Specification"

RPC Protocol Requirements
=========================


 @{" Programs and Procedures " Link "Programs and Procedures"} 
 @{" Authentication Requirements " Link "Authentication Requirements"} 
 @{" Program Number Assignment " Link "Program Number Assignment"} 
 @{" Other Uses of the RPC Protocol " Link "Other Uses of the RPC Protocol"} 

   The RPC protocol must provide for the following:

  1. Unique specification of a procedure to be called.

  2. Provisions for matching response messages to request messages.

  3. Provisions for authenticating the caller to service and vice-versa.

   Besides these requirements, features that detect the following are
worth supporting because of protocol roll-over errors, implementation
bugs, user error, and network administration:

  1. RPC protocol mismatches.

  2. Remote program protocol version mismatches.

  3. Protocol errors (such as misspecification of a procedure's
     parameters).

  4. Reasons why remote authentication failed.

  5. Any other reasons why the desired procedure was not called.


@EndNode

@Node "Programs and Procedures" "RPC.guide/Programs and Procedures"
@Next "Authentication Requirements"
@Toc "RPC Protocol Requirements"

Programs and Procedures
-----------------------

   The RPC call message has three unsigned fields: remote program
number, remote program version number, and remote procedure number.
The three fields uniquely identify the procedure to be called.  Program
numbers are administered by some central authority (like Sun).  Once an implementor has a program number, he
can implement his remote program; the first implementation would most
likely have the version number of 1.  Because most new protocols evolve
into better, stable, and mature protocols, a version field of the call
message identifies which version of the protocol the caller is using.
Version numbers make speaking old and new protocols through the same
server process possible.

   The procedure number identifies the procedure to be called.  These
numbers are documented in the specific program's protocol specification.
For example, a file service's protocol specification may state that its
procedure number 5 is `read' and procedure number 12 is `write'.

   Just as remote program protocols may change over several versions,
the actual RPC message protocol could also change.  Therefore, the call
message also has in it the RPC version number, which is always equal to
two for the version of RPC described here.

   The reply message to a request message has enough information to
distinguish the following error conditions:

  1. The remote implementation of RPC does speak protocol version 2.
     The lowest and highest supported RPC version numbers are returned.

  2. The remote program is not available on the remote system.

  3. The remote program does not support the requested version number.
     The lowest and highest supported remote program version numbers are
     returned.

  4. The requested procedure number does not exist.  (This is usually a
     caller side protocol or programming error.)

  5. The parameters to the remote procedure appear to be garbage from
     the server's point of view.  (Again, this is usually caused by a
     disagreement about the protocol between client and service.)


@EndNode

@Node "Authentication Requirements" "RPC.guide/Authentication Requirements"
@Next "Program Number Assignment"
@Prev "Programs and Procedures"
@Toc "RPC Protocol Requirements"

Authentication
--------------

   Provisions for authentication of caller to service and vice-versa are
provided as a part of the RPC protocol.  The call message has two
authentication fields, the credentials and verifier.  The reply message
has one authentication field, the response verifier.  The RPC protocol
specification defines all three fields to be the following opaque type:

     enum auth_flavor {
         AUTH_NULL        = 0,
         AUTH_UNIX        = 1,
         AUTH_SHORT       = 2,
         AUTH_DES         = 3
         /* and more to be defined */
     };
     
     struct opaque_auth {
         auth_flavor flavor;
         opaque body<400>;
     };

   In simple English, any `opaque_auth' structure is an `auth_flavor'
enumeration followed by bytes which are opaque to the RPC protocol
implementation.

   The interpretation and semantics of the data contained within the
authentication fields is specified by individual, independent
authentication protocol specifications.  (See @{"Authentication Protocols" Link "Authentication Protocols"},
below, for definitions of the various authentication protocols.)

   If authentication parameters were rejected, the response message
contains information stating why they were rejected.


@EndNode

@Node "Program Number Assignment" "RPC.guide/Program Number Assignment"
@Next "Other Uses of the RPC Protocol"
@Prev "Authentication Requirements"
@Toc "RPC Protocol Requirements"

Program Number Assignment
-------------------------

   Program numbers are given out in groups of `0x20000000' (decimal
536870912) according to the following chart:

     Program Numbers      Description
     
            0 - 1fffffff  Defined by Sun
     20000000 - 3fffffff  Defined by user
     40000000 - 5fffffff  Transient
     60000000 - 7fffffff  Reserved
     80000000 - 9fffffff  Reserved
     a0000000 - bfffffff  Reserved
     c0000000 - dfffffff  Reserved
     e0000000 - ffffffff  Reserved

   The first group is a range of numbers administered by Sun
Microsystems and should be identical for all sites.  The second range
is for applications peculiar to a particular site.  This range is
intended primarily for debugging new programs.  When a site develops an
application that might be of general interest, that application should
be given an assigned number in the first range.  The third group is for
applications that generate program numbers dynamically.  The final
groups are reserved for future use, and should not be used.


@EndNode

@Node "Other Uses of the RPC Protocol" "RPC.guide/Other Uses of the RPC Protocol"
@Prev "Program Number Assignment"
@Toc "RPC Protocol Requirements"

Other Uses of the RPC Protocol
------------------------------

   The intended use of this protocol is for calling remote procedures.
That is, each call message is matched with a response message.  However,
the protocol itself is a message-passing protocol with which other
(non-RPC) protocols can be implemented.  Sun currently uses, or perhaps
abuses, the RPC message protocol for the following two (non-RPC)
protocols: batching (or pipelining) and broadcast RPC.  These two
protocols are discussed but not defined below.


 @{" Batching " Link "Batching"} 
 @{" RPC Broadcast " Link "RPC Broadcast"} 


@EndNode

@Node "Batching" "RPC.guide/Batching"
@Next "RPC Broadcast"
@Toc "Other Uses of the RPC Protocol"

Batching
........

   Batching allows a client to send an arbitrarily large sequence of
call messages to a server; batching typically uses reliable byte stream
protocols (like TCP/IP) for its transport.  In the case of batching, the
client never waits for a reply from the server, and the server does not
send replies to batch requests.  A sequence of batch calls is usually
terminated by a legitimate RPC in order to flush the pipeline (with
positive acknowledgement).


@EndNode

@Node "RPC Broadcast" "RPC.guide/RPC Broadcast"
@Prev "Batching"
@Toc "Other Uses of the RPC Protocol"

Broadcast RPC
.............

   In broadcast RPC-based protocols, the client sends a broadcast
packet to the network and waits for numerous replies.  Broadcast RPC
uses unreliable, packet-based protocols (like UDP/IP) as its transports.
Servers that support broadcast protocols only respond when the request
is successfully processed, and are silent in the face of errors.
Broadcast RPC uses the Port Mapper RPC service to achieve its semantics.
See the @{"Port Mapper Program Protocol" Link "Port Mapper Program Protocol"}, below, for more information.


@EndNode

@Node "The RPC Message Protocol" "RPC.guide/The RPC Message Protocol"
@Next "Authentication Protocols"
@Prev "RPC Protocol Requirements"
@Toc "Remote Procedure Calls Protocol Specification"

The RPC Message Protocol
========================

   This section defines the RPC message protocol in the XDR data
description language.  The message is defined in a top-down style.

     enum msg_type {
         CALL  = 0,
         REPLY = 1
     };
     
     /*
      * A reply to a call message can take on two forms:
      * The message was either accepted or rejected.
      */
     enum reply_stat {
         MSG_ACCEPTED = 0,
         MSG_DENIED   = 1
     };
     
     /*
      * Given that a call message was accepted, the following is the
      * status of an attempt to call a remote procedure.
      */
     enum accept_stat {
         SUCCESS       = 0, /* RPC executed successfully       */
         PROG_UNAVAIL  = 1, /* remote hasn't exported program  */
         PROG_MISMATCH = 2, /* remote can't support version #  */
         PROC_UNAVAIL  = 3, /* program can't support procedure */
         GARBAGE_ARGS  = 4  /* procedure can't decode params   */
     };

     /*
      * Reasons why a call message was rejected:
      */
     enum reject_stat {
         RPC_MISMATCH = 0, /* RPC version number != 2          */
         AUTH_ERROR = 1    /* remote can't authenticate caller */
     };
     
     /*
      * Why authentication failed:
      */
     enum auth_stat {
         AUTH_BADCRED      = 1,  /* bad credentials */
         AUTH_REJECTEDCRED = 2,  /* client must begin new session */
         AUTH_BADVERF      = 3,  /* bad verifier */
         AUTH_REJECTEDVERF = 4,  /* verifier expired or replayed  */
         AUTH_TOOWEAK      = 5   /* rejected for security reasons */
     };

     /*
      * The RPC message:
      * All messages start with a transaction identifier, `xid',
      * followed by a two-armed discriminated union.  The union's discriminant
      * is a `msg_type' which switches to one of the two types of the
      * message.  The `xid' of a `REPLY' message always matches that of the
      * initiating `CALL' message.  NB: The `xid' field is only used
      * for clients matching reply messages with call messages or for servers
      * detecting retransmissions; the service side cannot treat this id as
      * any type of sequence number.
      */
     struct rpc_msg {
         unsigned int xid;
         union switch (msg_type mtype) {
             case CALL:
                 call_body cbody;
             case REPLY:
                 reply_body rbody;
         } body;
     };

     /*
      * Body of an RPC request call: In version 2 of the RPC protocol
      * specification, `rpcvers' must be equal to 2.  The fields `prog', `vers', and
      * `proc' specify the remote program, its version number, and the procedure
      * within the remote program to be called.  After these fields are two
      * authentication parameters: `cred' (authentication credentials) and `verf'
      * (authentication verifier).  The two authentication parameters are
      * followed by the parameters to the remote procedure, which are
      * specified by the specific program protocol.
      */
     struct call_body {
         unsigned int rpcvers;  /* must be equal to two (2) */
         unsigned int prog;
         unsigned int vers;
         unsigned int proc;
         opaque_auth cred;
         opaque_auth verf;
         /* procedure specific parameters start here */
     };

     /*
      * Body of a reply to an RPC request:
      * The call message was either accepted or rejected.
      */
     union reply_body switch (reply_stat stat) {
         case MSG_ACCEPTED:
             accepted_reply areply;
         case MSG_DENIED:
             rejected_reply rreply;
     } reply;

     /*
      * Reply to an RPC request that was accepted by the server:
      * there could be an error even though the request was accepted.
      * The first field is an authentication verifier that the server
      * generates in order to validate itself to the caller.  It is
      * followed by a union whose discriminant is an enum
      * `accept_stat'.  The `SUCCESS' arm of the union is protocol
      * specific.  The `PROG_UNAVAIL', `PROC_UNAVAIL', and `GARBAGE_ARGP'
      * arms of the union are void.  The `PROG_MISMATCH' arm specifies
      * the lowest and highest version numbers of the remote program
      * supported by the server.
      */
     struct accepted_reply {
         opaque_auth verf;
         union switch (accept_stat stat) {
             case SUCCESS:
                 opaque results[0];
                 /* procedure-specific results start here */
             case PROG_MISMATCH:
                 struct {
                     unsigned int low;
                     unsigned int high;
                 } mismatch_info;
             default:
                 /*
                  * Void.  Cases include `PROG_UNAVAIL, PROC_UNAVAIL',
                  * and `GARBAGE_ARGS'.
                  */
                 void;
         } reply_data;
     };

     /*
      * Reply to an RPC request that was rejected by the server: The
      * request can be rejected for two reasons: either the server is not
      * running a compatible version of the RPC protocol (`RPC_MISMATCH'),
      * or the server refuses to authenticate the caller (`AUTH_ERROR').  In
      * case of an RPC version mismatch, the server returns the lowest and
      * highest supported RPC version numbers.  In case of refused
      * authentication, failure status is returned.
      */
     union rejected_reply switch (reject_stat stat) {
         case RPC_MISMATCH:
             struct {
                 unsigned int low;
                 unsigned int high;
             } mismatch_info;
         case AUTH_ERROR:
             auth_stat stat;
     };


@EndNode

@Node "Authentication Protocols" "RPC.guide/Authentication Protocols"
@Next "Record Marking Standard"
@Prev "The RPC Message Protocol"
@Toc "Remote Procedure Calls Protocol Specification"

Authentication Protocols
========================

   As previously stated, authentication parameters are opaque, but
open-ended to the rest of the RPC protocol.  This section defines some
"flavors" of authentication implemented at (and supported by) Sun.
Other sites are free to invent new authentication types, with the same
rules of flavor number assignment as there is for program number
assignment.


 @{" Null Authentication (protocol) " Link "Null Authentication (protocol)"} 
 @{" UNIX Authentication (protocol) " Link "UNIX Authentication (protocol)"} 
 @{" DES Authentication (protocol) " Link "DES Authentication (protocol)"} 


@EndNode

@Node "Null Authentication (protocol)" "RPC.guide/Null Authentication (protocol)"
@Next "UNIX Authentication (protocol)"
@Toc "Authentication Protocols"

Null Authentication
-------------------

   Often calls must be made where the caller does not know who he is or
the server does not care who the caller is.  In this case, the flavor
value (the discriminant of the `opaque_auth''s union) of the RPC
message's credentials, verifier, and response verifier is `AUTH_NULL'.
The bytes of the `opaque_auth''s body are undefined.  It is recommended
that the opaque length be zero.


@EndNode

@Node "UNIX Authentication (protocol)" "RPC.guide/UNIX Authentication (protocol)"
@Next "DES Authentication (protocol)"
@Prev "Null Authentication (protocol)"
@Toc "Authentication Protocols"

UNIX Authentication
-------------------

   The caller of a remote procedure may wish to identify himself as he
is identified on a UNIX system.  The value of the credential's
discriminant of an RPC call message is `AUTH_UNIX'.  The bytes of the
credential's opaque body encode the following structure:

     struct auth_unix {
         unsigned int stamp;
         string machinename<255>;
         unsigned int uid;
         unsigned int gid;
         unsigned int gids<10>;
     };

   The `stamp' is an arbitrary ID which the caller machine may
generate.  The `machinename' is the name of the caller's machine (like
"krypton").  The `uid' is the caller's effective user ID.  The `gid' is
the caller's effective group ID.  The `gids' is a counted array of
groups which contain the caller as a member.  The verifier accompanying
the credentials should be of `AUTH_NULL' (defined above).

   The value of the discriminant of the response verifier received in
the reply message from the server may be `AUTH_NULL' or `AUTH_SHORT'.
In the case of `AUTH_SHORT', the bytes of the response verifier's
string encode an opaque structure.  This new opaque structure may now
be passed to the server instead of the original `AUTH_UNIX' flavor
credentials.  The server keeps a cache which maps shorthand opaque
structures (passed back by way of an `AUTH_SHORT' style response
verifier) to the original credentials of the caller.  The caller can
save network bandwidth and server cpu cycles by using the new
credentials.

   The server may flush the shorthand opaque structure at any time.  If
this happens, the remote procedure call message will be rejected due to
an authentication error.  The reason for the failure will be
`AUTH_REJECTEDCRED'.  At this point, the caller may wish to try the
original `AUTH_UNIX' style of credentials.


@EndNode

@Node "DES Authentication (protocol)" "RPC.guide/DES Authentication (protocol)"
@Prev "UNIX Authentication (protocol)"
@Toc "Authentication Protocols"

DES Authentication
------------------

   UNIX authentication suffers from two major problems:

  1. The naming is too UNIX-system oriented.

  2. There is no verifier, so credentials can easily be faked.

   DES authentication attempts to fix these two problems.


 @{" Naming " Link "Naming"} 
 @{" DES Authentication Verifiers " Link "DES Authentication Verifiers"} 
 @{" Nicknames and Clock Synchronization " Link "Nicknames and Clock Synchronization"} 
 @{" DES Authentication Protocol (in XDR language) " Link "DES Authentication Protocol (in XDR language)"} 
 @{" Diffie-Hellman Encryption " Link "Diffie-Hellman Encryption"} 


@EndNode

@Node "Naming" "RPC.guide/Naming"
@Next "DES Authentication Verifiers"
@Toc "DES Authentication (protocol)"

Naming
......

   The first problem is handled by addressing the caller by a simple
string of characters instead of by an operating system specific
integer.  This string of characters is known as the "netname" or
network name of the caller.  The server is not allowed to interpret the
contents of the caller's name in any other way except to identify the
caller.  Thus, netnames should be unique for every caller in the
internet.

   It is up to each operating system's implementation of DES
authentication to generate netnames for its users that insure this
uniqueness when they call upon remote servers.  Operating systems
already know how to distinguish users local to their systems.  It is
usually a simple matter to extend this mechanism to the network.  For
example, a UNIX user at Sun with a user ID of 515 might be assigned the
following netname: "unix.515@sun.com".  This netname contains three
items that serve to insure it is unique.  Going backwards, there is
only one naming domain called "sun.com" in the internet.  Within this
domain, there is only one UNIX user with user ID 515.  However, there
may be another user on another operating system, for example VMS,
within the same naming domain that, by coincidence, happens to have the
same user ID.  To insure that these two users can be distinguished we
add the operating system name.  So one user is "unix.515@sun.com" and
the other is "vms.515@sun.com".

   The first field is actually a naming method rather than an operating
system name.  It just happens that today there is almost a one-to-one
correspondence between naming methods and operating systems.  If the
world could agree on a naming standard, the first field could be the
name of that standard, instead of an operating system name.


@EndNode

@Node "DES Authentication Verifiers" "RPC.guide/DES Authentication Verifiers"
@Next "Nicknames and Clock Synchronization"
@Prev "Naming"
@Toc "DES Authentication (protocol)"

DES Authentication Verifiers
............................

   Unlike UNIX authentication, DES authentication does have a verifier
so the server can validate the client's credential (and vice-versa).
The contents of this verifier is primarily an encrypted timestamp.  The
server can decrypt this timestamp, and if it is close to what the real
time is, then the client must have encrypted it correctly.  The only way
the client could encrypt it correctly is to know the "conversation key"
of the RPC session.  And if the client knows the conversation key, then
it must be the real client.

   The conversation key is a DES [5] key which the client generates and
notifies the server of in its first RPC call.  The conversation key is
encrypted using a public key scheme in this first transaction.  The
particular public key scheme used in DES authentication is
Diffie-Hellman [3] with 192-bit keys.  The details of this encryption
method are described later.

   The client and the server need the same notion of the current time
in order for all of this to work.  If network time synchronization
cannot be guaranteed, then client can synchronize with the server
before beginning the conversation, perhaps by consulting the Internet
Time Server (TIME[4]).

   The way a server determines if a client timestamp is valid is
somewhat complicated.  For any other transaction but the first, the
server just checks for two things:

  1. the timestamp is greater than the one previously seen from the same
     client.

  2. the timestamp has not expired.

   A timestamp is expired if the server's time is later than the sum of
the client's timestamp plus what is known as the client's "window".  The
"window" is a number the client passes (encrypted) to the server in its
first transaction.  You can think of it as a lifetime for the
credential.

   This explains everything but the first transaction.  In the first
transaction, the server checks only that the timestamp has not expired.
If this was all that was done though, then it would be quite easy for
the client to send random data in place of the timestamp with a fairly
good chance of succeeding.  As an added check, the client sends an
encrypted item in the first transaction known as the "window verifier"
which must be equal to the window minus 1, or the server will reject the
credential.

   The client too must check the verifier returned from the server to be
sure it is legitimate.  The server sends back to the client the
encrypted timestamp it received from the client, minus one second.  If
the client gets anything different than this, it will reject it.


@EndNode

@Node "Nicknames and Clock Synchronization" "RPC.guide/Nicknames and Clock Synchronization"
@Next "DES Authentication Protocol (in XDR language)"
@Prev "DES Authentication Verifiers"
@Toc "DES Authentication (protocol)"

Nicknames and Clock Synchronization
...................................

   After the first transaction, the server's DES authentication
subsystem returns in its verifier to the client an integer "nickname"
which the client may use in its further transactions instead of passing
its netname, encrypted DES key and window every time.  The nickname is
most likely an index into a table on the server which stores for each
client its netname, decrypted DES key and window.

   Though they originally were synchronized, the client's and server's
clocks can get out of sync again.  When this happens the client RPC
subsystem most likely will get back `RPC_AUTHERROR' at which point it
should resynchronize.

   A client may still get the `RPC_AUTHERROR' error even though it is
synchronized with the server.  The reason is that the server's nickname
table is a limited size, and it may flush entries whenever it wants.  A
client should resend its original credential in this case and the server
will give it a new nickname.  If a server crashes, the entire nickname
table gets flushed, and all clients will have to resend their original
credentials.


@EndNode

@Node "DES Authentication Protocol (in XDR language)" "RPC.guide/DES Authentication Protocol (in XDR language)"
@Next "Diffie-Hellman Encryption"
@Prev "Nicknames and Clock Synchronization"
@Toc "DES Authentication (protocol)"

DES Authentication Protocol (in XDR language)
.............................................

     /*
      * There are two kinds of credentials: one in which the client uses
      * its full network name, and one in which it uses its "nickname"
      * (just an unsigned integer) given to it by the server.  The
      * client must use its fullname in its first transaction with the
      * server, in which the server will return to the client its
      * nickname.  The client may use its nickname in all further
      * transactions with the server.  There is no requirement to use the
      * nickname, but it is wise to use it for performance reasons.
      */
     enum authdes_namekind {
         ADN_FULLNAME = 0,
         ADN_NICKNAME = 1
     };
     
     /*
      * A 64-bit block of encrypted DES data
      */
     typedef opaque des_block[8];
     
     /*
      * Maximum length of a network user's name
      */
     const MAXNETNAMELEN = 255;
     
     /*
      * A fullname contains the network name of the client, an encrypted
      * conversation key and the window.  The window is actually a
      * lifetime for the credential.  If the time indicated in the
      * verifier timestamp plus the window has past, then the server
      * should expire the request and not grant it.  To insure that
      * requests are not replayed, the server should insist that
      * timestamps are greater than the previous one seen, unless it is
      * the first transaction.  In the first transaction, the server
      * checks instead that the window verifier is one less than the
      * window.
      */
     struct authdes_fullname {
         string name<MAXNETNAMELEN>;  /* name of client */
         des_block key;               /* encrypted conversation key */
         unsigned int window;         /* encrypted window */
     };
     
     /*
      * A credential is either a fullname or a nickname
      */
     union authdes_cred switch (authdes_namekind adc_namekind) {
         case ADN_FULLNAME:
             authdes_fullname adc_fullname;
         case ADN_NICKNAME:
             unsigned int adc_nickname;
     };
     
     /*
      * A timestamp encodes the time since midnight, January 1, 1970.
      */
     struct timestamp {
         unsigned int seconds;    /* seconds */
         unsigned int useconds;   /* and microseconds */
     };
     
     /*
      * Verifier: client variety
      * The window verifier is only used in the first transaction.  In
      * conjunction with a fullname credential, these items are packed
      * into the following structure before being encrypted:
      *
      * struct {
      *     adv_timestamp;            -- one DES block
      *     adc_fullname.window;      -- one half DES block
      *     adv_winverf;              -- one half DES block
      * }
      * This structure is encrypted using CBC mode encryption with an
      * input vector of zero.  All other encryptions of timestamps use
      * ECB mode encryption.
      */
     struct authdes_verf_clnt {
         timestamp adv_timestamp;    /* encrypted timestamp */
         unsigned int adv_winverf;   /* encrypted window verifier */
     };
     
     /*
      * Verifier: server variety
      * The server returns (encrypted) the same timestamp the client
      * gave it minus one second.  It also tells the client its nickname
      * to be used in future transactions (unencrypted).
      */
     struct authdes_verf_svr {
         timestamp adv_timeverf;     /* encrypted verifier */
         unsigned int adv_nickname;  /* new nickname for client */
     };


@EndNode

@Node "Diffie-Hellman Encryption" "RPC.guide/Diffie-Hellman Encryption"
@Prev "DES Authentication Protocol (in XDR language)"
@Toc "DES Authentication (protocol)"

Diffie-Hellman Encryption
.........................

   In this scheme, there are two constants, `BASE' and `MODULUS'.  The
particular values Sun has chosen for these for the DES authentication
protocol are:

     const BASE = 3;
     const MODULUS =
             "d4a0ba0250b6fd2ec626e7efd637df76c716e22d0944b88b"; /* hex */

   The way this scheme works is best explained by an example.  Suppose
there are two people `A' and `B' who want to send encrypted messages to
each other.  So, A and B both generate "secret" keys at random which
they do not reveal to anyone.  Let these keys be represented as `SK(A)'
and `SK(B)'.  They also publish in a public directory their "public"
keys.  These keys are computed as follows:

     PK(A) = ( BASE ^ SK(A) ) mod MODULUS
     PK(B) = ( BASE ^ SK(B) ) mod MODULUS

   The `^' notation is used here to represent exponentiation.  Now,
both A and B can arrive at the "common" key between them, represented
here as `CK(A, B)', without revealing their secret keys.

   A computes:

     CK(A, B) = ( PK(B) ^ SK(A)) mod MODULUS

   while B computes:

     CK(A, B) = ( PK(A) ^ SK(B)) mod MODULUS

   These two can be shown to be equivalent:

     (PK(B) ^ SK(A)) mod MODULUS = (PK(A) ^ SK(B)) mod MODULUS

   We drop the "mod MODULUS" parts and assume modulo arithmetic to
simplify things:

     PK(B) ^ SK(A) = PK(A) ^ SK(B)

   Then, replace `PK(B)' by what B computed earlier and likewise for
`PK(A)'.

     ((BASE ^ SK(B)) ^ SK(A) = (BASE ^ SK(A)) ^ SK(B)

   which leads to:

     BASE ^ (SK(A) * SK(B)) = BASE ^ (SK(A) * SK(B))

   This common key `CK(A, B)' is not used to encrypt the timestamps
used in the protocol.  Rather, it is used only to encrypt a conversation
key which is then used to encrypt the timestamps.  The reason for doing
this is to use the common key as little as possible, for fear that it
could be broken.  Breaking the conversation key is a far less serious
offense, since conversations are relatively short-lived.

   The conversation key is encrypted using 56-bit DES keys, yet the
common key is 192 bits.  To reduce the number of bits, 56 bits are
selected from the common key as follows.  The middle-most 8-bytes are
selected from the common key, and then parity is added to the lower
order bit of each byte, producing a 56-bit key with 8 bits of parity.


@EndNode

@Node "Record Marking Standard" "RPC.guide/Record Marking Standard"
@Next "The RPC Language"
@Prev "Authentication Protocols"
@Toc "Remote Procedure Calls Protocol Specification"

Record Marking Standard
=======================

   When RPC messages are passed on top of a byte stream protocol (like
TCP/IP), it is necessary, or at least desirable, to delimit one message
from another in order to detect and possibly recover from user protocol
errors.  This is called record marking (RM).  Sun uses this RM/TCP/IP
transport for passing RPC messages on TCP streams.  One RPC message fits
into one RM record.

   A record is composed of one or more record fragments.  A record
fragment is a four-byte header followed by 0 to (2^31) - 1 bytes of
fragment data.  The bytes encode an unsigned binary number; as with XDR
integers, the byte order is from highest to lowest.  The number encodes
two values -- a boolean which indicates whether the fragment is the
last fragment of the record (bit value 1 implies the fragment is the
last fragment) and a 31-bit unsigned binary value which is the length
in bytes of the fragment's data.  The boolean value is the
highest-order bit of the header; the length is the 31 low-order bits.
(Note that this record specification is NOT in XDR standard form!)


@EndNode

@Node "The RPC Language" "RPC.guide/The RPC Language"
@Next "Port Mapper Program Protocol"
@Prev "Record Marking Standard"
@Toc "Remote Procedure Calls Protocol Specification"

The RPC Language
================

   Just as there was a need to describe the XDR data-types in a formal
language, there is also need to describe the procedures that operate on
these XDR data-types in a formal language as well.  We use the RPC
Language for this purpose.  It is an extension to the XDR language.  The
following example is used to describe the essence of the language.


 @{" An Example Service Described in the RPC Language " Link "An Example Service Described in the RPC Language"} 
 @{" The RPC Language Specification " Link "The RPC Language Specification"} 
 @{" RPC Syntax Notes " Link "RPC Syntax Notes"} 


@EndNode

@Node "An Example Service Described in the RPC Language" "RPC.guide/An Example Service Described in the RPC Language"
@Next "The RPC Language Specification"
@Toc "The RPC Language"

An Example Service Described in the RPC Language
------------------------------------------------

   Here is an example of the specification of a simple ping program.

     /*
      * Simple ping program
      */
     program PING_PROG {
         /* Latest and greatest version */
         version PING_VERS_PINGBACK {
         void
         PINGPROC_NULL(void) = 0;
     
         /*
          * Ping the caller, return the round-trip time
          * (in microseconds). Returns -1 if the operation
          * timed out.
          */
         int
         PINGPROC_PINGBACK(void) = 1;
     } = 2;
     
     /*
      * Original version
      */
     version PING_VERS_ORIG {
         void
         PINGPROC_NULL(void) = 0;
         } = 1;
     } = 1;
     
     const PING_VERS = 2;      /* latest version */

   The first version described is `PING_VERS_PINGBACK' with two
procedures, `PINGPROC_NULL' and `PINGPROC_PINGBACK'.  `PINGPROC_NULL'
takes no arguments and returns no results, but it is useful for
computing round-trip times from the client to the server and back
again.  By convention, procedure 0 of any RPC protocol should have the
same semantics, and never require any kind of authentication.  The
second procedure is used for the client to have the server do a reverse
ping operation back to the client, and it returns the amount of time
(in microseconds) that the operation used.  The next version,
`PING_VERS_ORIG', is the original version of the protocol and it does
not contain `PINGPROC_PINGBACK' procedure. It is useful for
compatibility with old client programs, and as this program matures it
may be dropped from the protocol entirely.


@EndNode

@Node "The RPC Language Specification" "RPC.guide/The RPC Language Specification"
@Next "RPC Syntax Notes"
@Prev "An Example Service Described in the RPC Language"
@Toc "The RPC Language"

The RPC Language Specification
------------------------------

   The RPC language is identical to the XDR language, except for the
added definition of a `program-def' described below.

     program-def:
         "program" identifier "{"
             version-def
             version-def *
         "}" "=" constant ";"
     
     version-def:
         "version" identifier "{"
             procedure-def
             procedure-def *
         "}" "=" constant ";"
     
     procedure-def:
         type-specifier identifier "(" type-specifier ")"
         "=" constant ";"


@EndNode

@Node "RPC Syntax Notes" "RPC.guide/RPC Syntax Notes"
@Prev "The RPC Language Specification"
@Toc "The RPC Language"

Syntax Notes
------------

  1. The following keywords are added and cannot be used as identifiers:
     `program' and `version';

  2. A version name cannot occur more than once within the scope of a
     program definition. Nor can a version number occur more than once
     within the scope of a program definition.

  3. A procedure name cannot occur more than once within the scope of a
     version definition. Nor can a procedure number occur more than once
     within the scope of version definition.

  4. Program identifiers are in the same name space as constant and type
     identifiers.

  5. Only unsigned constants can be assigned to programs, versions and
     procedures.


@EndNode

@Node "Port Mapper Program Protocol" "RPC.guide/Port Mapper Program Protocol"
@Next "RPC References"
@Prev "The RPC Language"
@Toc "Remote Procedure Calls Protocol Specification"

Port Mapper Program Protocol
============================

   The port mapper program maps RPC program and version numbers to
transport-specific port numbers.  This program makes dynamic binding of
remote programs possible.

   This is desirable because the range of reserved port numbers is very
small and the number of potential remote programs is very large.  By
running only the port mapper on a reserved port, the port numbers of
other remote programs can be ascertained by querying the port mapper.

   The port mapper also aids in broadcast RPC.  A given RPC program will
usually have different port number bindings on different machines, so
there is no way to directly broadcast to all of these programs.  The
port mapper, however, does have a fixed port number.  So, to broadcast
to a given program, the client actually sends its message to the port
mapper located at the broadcast address.  Each port mapper that picks up
the broadcast then calls the local service specified by the client.
When the port mapper gets the reply from the local service, it sends the
reply on back to the client.


 @{" Port Mapper Protocol Specification (in RPC Language) " Link "Port Mapper Protocol Specification (in RPC Language)"} 
 @{" Port Mapper Operation " Link "Port Mapper Operation"} 


@EndNode

@Node "Port Mapper Protocol Specification (in RPC Language)" "RPC.guide/Port Mapper Protocol Specification (in RPC Language)"
@Next "Port Mapper Operation"
@Toc "Port Mapper Program Protocol"

Port Mapper Protocol Specification (in RPC Language)
----------------------------------------------------

     const PMAP_PORT = 111;      /* portmapper port number */
     
     /*
      * A mapping of (program, version, protocol) to port number
      */
     struct mapping {
         unsigned int prog;
         unsigned int vers;
         unsigned int prot;
         unsigned int port;
     };
     
     /*
      * Supported values for the "prot" field
      */
     const IPPROTO_TCP = 6;      /* protocol number for TCP/IP */
     const IPPROTO_UDP = 17;     /* protocol number for UDP/IP */
     
     /*
      * A list of mappings
      */
     struct *pmaplist {
         mapping map;
         pmaplist next;
     };

     /*
      * Arguments to callit
      */
     struct call_args {
         unsigned int prog;
         unsigned int vers;
         unsigned int proc;
         opaque args<>;
     };
     
     /*
      * Results of callit
      */
     struct call_result {
         unsigned int port;
         opaque res<>;
     };

     /*
      * Port mapper procedures
      */
     program PMAP_PROG {
         version PMAP_VERS {
             void
             PMAPPROC_NULL(void)         = 0;
     
             bool
             PMAPPROC_SET(mapping)       = 1;
     
             bool
             PMAPPROC_UNSET(mapping)     = 2;
     
             unsigned int
             PMAPPROC_GETPORT(mapping)   = 3;
     
             pmaplist
             PMAPPROC_DUMP(void)         = 4;
     
             call_result
             PMAPPROC_CALLIT(call_args)  = 5;
         } = 2;
     } = 100000;


@EndNode

@Node "Port Mapper Operation" "RPC.guide/Port Mapper Operation"
@Prev "Port Mapper Protocol Specification (in RPC Language)"
@Toc "Port Mapper Program Protocol"

Port Mapper Operation
---------------------

   The portmapper program currently supports two protocols (UDP/IP and
TCP/IP).  The portmapper is contacted by talking to it on assigned port
number 111 (SUNRPC [8]) on either of these protocols.  The following is
a description of each of the portmapper procedures:

PMAPPROC_NULL:
     This procedure does no work.  By convention, procedure zero of any
     protocol takes no parameters and returns no results.

PMAPPROC_SET:
     When a program first becomes available on a machine, it registers
     itself with the port mapper program on the same machine.  The
     program passes its program number `prog', version number `vers',
     transport protocol number `prot', and the port `port' on which it
     awaits service request.  The procedure returns a boolean response
     whose value is `TRUE' if the procedure successfully established
     the mapping and `FALSE' otherwise.  The procedure refuses to
     establish a mapping if one already exists for the tuple `(prog,
     vers, prot)'.

PMAPPROC_UNSET:
     When a program becomes unavailable, it should unregister itself
     with the port mapper program on the same machine.  The parameters
     and results have meanings identical to those of `PMAPPROC_SET'.
     The protocol and port number fields of the argument are ignored.

PMAPPROC_GETPORT:
     Given a program number `prog', version number `vers', and
     transport protocol number `prot', this procedure returns the port
     number on which the program is awaiting call requests.  A port
     value of zeros means the program has not been registered.  The
     `port' field of the argument is ignored.

PMAPPROC_DUMP:
     This procedure enumerates all entries in the port mapper's
     database.  The procedure takes no parameters and returns a list of
     program, version, protocol, and port values.

PMAPPROC_CALLIT:
     This procedure allows a caller to call another remote procedure on
     the same machine without knowing the remote procedure's port
     number.  It is intended for supporting broadcasts to arbitrary
     remote programs via the well-known port mapper's port.  The
     parameters `prog', `vers', `proc', and the bytes of `args' are the
     program number, version number, procedure number, and parameters
     of the remote procedure.

   *Note:*
  1. This procedure only sends a response if the procedure was
     successfully executed and is silent (no response) otherwise.

  2. The port mapper communicates with the remote program using UDP/IP
     only.

   The procedure returns the remote program's port number, and the
bytes of results are the results of the remote procedure.


@EndNode

@Node "RPC References" "RPC.guide/RPC References"
@Prev "Port Mapper Program Protocol"
@Toc "Remote Procedure Calls Protocol Specification"

References
==========

[1]
     Birrell, Andrew D. & Nelson, Bruce Jay; `Implementing Remote
     Procedure Calls'; XEROX CSL-83-7, October 1983.

[2]
     Cheriton, D.; `VMTP: Versatile Message Transaction Protocol',
     Preliminary Version 0.3; Stanford University, January 1987.

[3]
     Diffie & Hellman; `New Directions in Cryptography'; IEEE
     Transactions on Information Theory IT-22, November 1976.

[4]
     Harrenstien, K.; `Time Server', RFC 738; Information Sciences
     Institute, October 1977.

[5]
     National Bureau of Standards; `Data Encryption Standard'; Federal
     Information Processing Standards Publication 46, January 1977.

[6]
     Postel, J.; `Transmission Control Protocol - DARPA Internet Program
     Protocol Specification', RFC 793; Information Sciences Institute,
     September 1981.

[7]
     Postel, J.; `User Datagram Protocol', RFC 768; Information Sciences
     Institute, August 1980.

[8]
     Reynolds, J. & Postel, J.; `Assigned Numbers', RFC 923; Information
     Sciences Institute, October 1984.


@EndNode

@Node "Network File System Version 2 Protocol Specification" "RPC.guide/Network File System Version 2 Protocol Specification"
@Next "Manual Pages"
@Prev "Remote Procedure Calls Protocol Specification"
@Toc "Main"

Network File System: Version 2 Protocol Specification
*****************************************************

   *Note:* This document specifies a protocol that Sun Microsystems,
Inc., and others are using.  It specifies it in standard ARPA RFC form.


 @{" Introduction to NFS " Link "Introduction to NFS"} 
 @{" NFS Protocol Definition " Link "NFS Protocol Definition"} 
 @{" NFS Implementation Issues " Link "NFS Implementation Issues"} 
 @{" Mount Protocol Definition " Link "Mount Protocol Definition"} 


@EndNode

@Node "Introduction to NFS" "RPC.guide/Introduction to NFS"
@Next "NFS Protocol Definition"
@Toc "Network File System Version 2 Protocol Specification"

Introduction to NFS
===================

   The Sun Network Filesystem (NFS) protocol provides transparent remote
access to shared filesystems over local area networks.  The NFS protocol
is designed to be machine, operating system, network architecture, and
transport protocol independent.  This independence is achieved through
the use of Remote Procedure Call (RPC) primitives built on top of an
External Data Representation (XDR).  Implementations exist for a variety
of machines, from personal computers to supercomputers.

   The supporting mount protocol allows the server to hand out remote
access privileges to a restricted set of clients.  It performs the
operating system-specific functions that allow, for example, to attach
remote directory trees to some local file system.


 @{" Remote Procedure Call " Link "Remote Procedure Call"} 
 @{" External Data Representation " Link "External Data Representation"} 
 @{" Stateless Servers " Link "Stateless Servers"} 


@EndNode

@Node "Remote Procedure Call" "RPC.guide/Remote Procedure Call"
@Next "External Data Representation"
@Toc "Introduction to NFS"

Remote Procedure Call
---------------------

   Sun's remote procedure call specification provides a
procedure-oriented interface to remote services.  Each server supplies
a program that is a set of procedures.  NFS is one such "program".  The
combination of host address, program number, and procedure number
specifies one remote service procedure.  RPC does not depend on
services provided by specific protocols, so it can be used with any
underlying transport protocol.  See
@{"Remote Procedure Calls Protocol Specification" Link "Remote Procedure Calls Protocol Specification"}.


@EndNode

@Node "External Data Representation" "RPC.guide/External Data Representation"
@Next "Stateless Servers"
@Prev "Remote Procedure Call"
@Toc "Introduction to NFS"

External Data Representation
----------------------------

   The External Data Representation (XDR) standard provides a common
way of representing a set of data types over a network.  The NFS
Protocol Specification is written using the RPC data description
language.  For more information, See @{"XDR Protocol Specification" Link "XDR Protocol Specification"}.  Sun
provides implementations of XDR and RPC, but NFS does not require their
use.  Any software that provides equivalent functionality can be used,
and if the encoding is exactly the same it can interoperate with other
implementations of NFS.


@EndNode

@Node "Stateless Servers" "RPC.guide/Stateless Servers"
@Prev "External Data Representation"
@Toc "Introduction to NFS"

Stateless Servers
-----------------

   The NFS protocol is stateless.  That is, a server does not need to
maintain any extra state information about any of its clients in order
to function correctly.  Stateless servers have a distinct advantage over
stateful servers in the event of a failure.  With stateless servers, a
client need only retry a request until the server responds; it does not
even need to know that the server has crashed, or the network
temporarily went down.  The client of a stateful server, on the other
hand, needs to either detect a server crash and rebuild the server's
state when it comes back up, or cause client operations to fail.

   This may not sound like an important issue, but it affects the
protocol in some unexpected ways.  We feel that it is worth a bit of
extra complexity in the protocol to be able to write very simple
servers that do not require fancy crash recovery.

   On the other hand, NFS deals with objects such as files and
directories that inherently have state - what good would a file be if
it did not keep its contents intact?  The goal is to not introduce any
extra state in the protocol itself.  Another way to simplify recovery
is by making operations "idempotent" whenever possible (so that they can
potentially be repeated).


@EndNode

@Node "NFS Protocol Definition" "RPC.guide/NFS Protocol Definition"
@Next "NFS Implementation Issues"
@Prev "Introduction to NFS"
@Toc "Network File System Version 2 Protocol Specification"

NFS Protocol Definition
=======================

   Servers have been known to change over time, and so can the protocol
that they use. So RPC provides a version number with each RPC request.
This RFC describes version two of the NFS protocol.  Even in the second
version, there are various obsolete procedures and parameters, which
will be removed in later versions. An RFC for version three of the NFS
protocol is currently under preparation(1).


 @{" File System Model " Link "File System Model"} 
 @{" RPC Information " Link "RPC Information"} 
 @{" Sizes of XDR Structures " Link "Sizes of XDR Structures"} 
 @{" Basic Data Types " Link "Basic Data Types"} 
 @{" Server Procedures " Link "Server Procedures"} 

   ---------- Footnotes ----------

   (1)  Editor's note: The version three specification is ready by now.


@EndNode

@Node "File System Model" "RPC.guide/File System Model"
@Next "RPC Information"
@Toc "NFS Protocol Definition"

File System Model
-----------------

   NFS assumes a file system that is hierarchical, with directories as
all but the bottom-level files.  Each entry in a directory (file,
directory, device, etc.)  has a string name.  Different operating
systems may have restrictions on the depth of the tree or the names
used, as well as using different syntax to represent the "pathname",
which is the concatenation of all the "components" (directory and file
names) in the name.  A "file system" is a tree on a single server
(usually a single disk or physical partition) with a specified "root".
Some operating systems provide a "mount" operation to make all file
systems appear as a single tree, while others maintain a "forest" of
file systems.  Files are unstructured streams of uninterpreted bytes.
Version 3 of NFS uses a slightly more general file system model.

   NFS looks up one component of a pathname at a time.  It may not be
obvious why it does not just take the whole pathname, traipse down the
directories, and return a file handle when it is done.  There are
several good reasons not to do this.  First, pathnames need separators
between the directory components, and different operating systems use
different separators.  We could define a Network Standard Pathname
Representation, but then every pathname would have to be parsed and
converted at each end.  Other issues are discussed in
@{"NFS Implementation Issues" Link "NFS Implementation Issues"} below.

   Although files and directories are similar objects in many ways,
different procedures are used to read directories and files.  This
provides a network standard format for representing directories.  The
same argument as above could have been used to justify a procedure that
returns only one directory entry per call.  The problem is efficiency.
Directories can contain many entries, and a remote call to return each
would be just too slow.


@EndNode

@Node "RPC Information" "RPC.guide/RPC Information"
@Next "Sizes of XDR Structures"
@Prev "File System Model"
@Toc "NFS Protocol Definition"

RPC Information
---------------

Authentication
     The NFS service uses `AUTH_UNIX', `AUTH_DES', or `AUTH_SHORT'
     style authentication, except in the NULL procedure where
     `AUTH_NONE' is also allowed.

Transport Protocols
     NFS currently is supported on UDP/IP only.

Port Number
     The NFS protocol currently uses the UDP port number 2049.  This is
     not an officially assigned port, so later versions of the protocol
     use the "Portmapping" facility of RPC.


@EndNode

@Node "Sizes of XDR Structures" "RPC.guide/Sizes of XDR Structures"
@Next "Basic Data Types"
@Prev "RPC Information"
@Toc "NFS Protocol Definition"

Sizes of XDR Structures
-----------------------

   These are the sizes, given in decimal bytes, of various XDR
structures used in the protocol:

     /* The maximum number of bytes of data in a READ or WRITE request  */
     const MAXDATA = 8192;
     
     /* The maximum number of bytes in a pathname argument */
     const MAXPATHLEN = 1024;
     
     /* The maximum number of bytes in a file name argument */
     const MAXNAMLEN = 255;
     
     /* The size in bytes of the opaque "cookie" passed by READDIR */
     const COOKIESIZE  = 4;
     
     /* The size in bytes of the opaque file handle */
     const FHSIZE = 32;


@EndNode

@Node "Basic Data Types" "RPC.guide/Basic Data Types"
@Next "Server Procedures"
@Prev "Sizes of XDR Structures"
@Toc "NFS Protocol Definition"

Basic Data Types
----------------

   The following XDR definitions are basic structures and types used in
other structures described further on.


 @{" stat " Link "stat"} 
 @{" ftype " Link "ftype"} 
 @{" fhandle " Link "fhandle"} 
 @{" timeval " Link "timeval"} 
 @{" fattr " Link "fattr"} 
 @{" sattr " Link "sattr"} 
 @{" filename " Link "filename"} 
 @{" path " Link "path"} 
 @{" attrstat " Link "attrstat"} 
 @{" diropargs " Link "diropargs"} 
 @{" diropres " Link "diropres"} 


@EndNode

@Node "stat" "RPC.guide/stat"
@Next "ftype"
@Toc "Basic Data Types"

stat
....

     enum stat {
         NFS_OK = 0,
         NFSERR_PERM=1,
         NFSERR_NOENT=2,
         NFSERR_IO=5,
         NFSERR_NXIO=6,
         NFSERR_ACCES=13,
         NFSERR_EXIST=17,
         NFSERR_NODEV=19,
         NFSERR_NOTDIR=20,
         NFSERR_ISDIR=21,
         NFSERR_FBIG=27,
         NFSERR_NOSPC=28,
         NFSERR_ROFS=30,
         NFSERR_NAMETOOLONG=63,
         NFSERR_NOTEMPTY=66,
         NFSERR_DQUOT=69,
         NFSERR_STALE=70,
         NFSERR_WFLUSH=99
     };

   The `stat' type is returned with every procedure's results.  A value
of `NFS_OK' indicates that the call completed successfully and the
results are valid.  The other values indicate some kind of error
occurred on the server side during the servicing of the procedure.  The
error values are derived from UNIX error numbers.
`NFSERR_PERM'
     Not owner.  The caller does not have correct ownership to perform
     the requested operation.

`NFSERR_NOENT'
     No such file or directory.  The file or directory specified does
     not exist.

`NFSERR_IO'
     Some sort of hard error occurred when the operation was in
     progress.  This could be a disk error, for example.

`NFSERR_NXIO'
     No such device or address.

`NFSERR_ACCES'
     Permission denied.  The caller does not have the correct
     permission to perform the requested operation.

`NFSERR_EXIST'
     File exists.  The file specified already exists.

`NFSERR_NODEV'
     No such device.

`NFSERR_NOTDIR'
     Not a directory.  The caller specified a non-directory in a
     directory operation.

`NFSERR_ISDIR'
     Is a directory.  The caller specified a directory in a non-
     directory operation.

`NFSERR_FBIG'
     File too large.  The operation caused a file to grow beyond the
     server's limit.

`NFSERR_NOSPC'
     No space left on device.  The operation caused the server's
     filesystem to reach its limit.

`NFSERR_ROFS'
     Read-only filesystem.  Write attempted on a read-only filesystem.

`NFSERR_NAMETOOLONG'
     File name too long.  The file name in an operation was too long.

`NFSERR_NOTEMPTY'
     Directory not empty.  Attempted to remove a directory that was not
     empty.

`NFSERR_DQUOT'
     Disk quota exceeded.  The client's disk quota on the server has
     been exceeded.

`NFSERR_STALE'
     The `fhandle' given in the arguments was invalid.  That is, the
     file referred to by that file handle no longer exists, or access
     to it has been revoked.

`NFSERR_WFLUSH'
     The server's write cache used in the `WRITECACHE' call got flushed
     to disk.


@EndNode

@Node "ftype" "RPC.guide/ftype"
@Next "fhandle"
@Prev "stat"
@Toc "Basic Data Types"

ftype
.....

     enum ftype {
         NFNON = 0,
         NFREG = 1,
         NFDIR = 2,
         NFBLK = 3,
         NFCHR = 4,
         NFLNK = 5
     };

   The enumeration `ftype' gives the type of a file.  The type `NFNON'
indicates a non-file, `NFREG' is a regular file, `NFDIR' is a
directory, `NFBLK' is a block-special device, `NFCHR' is a
character-special device, and `NFLNK' is a symbolic link.


@EndNode

@Node "fhandle" "RPC.guide/fhandle"
@Next "timeval"
@Prev "ftype"
@Toc "Basic Data Types"

fhandle
.......

     typedef opaque fhandle[FHSIZE];

   The `fhandle' is the file handle passed between the server and the
client.  All file operations are done using file handles to refer to a
file or directory.  The file handle can contain whatever information the
server needs to distinguish an individual file.


@EndNode

@Node "timeval" "RPC.guide/timeval"
@Next "fattr"
@Prev "fhandle"
@Toc "Basic Data Types"

timeval
.......

     struct timeval {
         unsigned int seconds;
         unsigned int useconds;
     };

   The `timeval' structure is the number of seconds and microseconds
since midnight January 1, 1970, Greenwich Mean Time.  It is used to pass
time and date information.


@EndNode

@Node "fattr" "RPC.guide/fattr"
@Next "sattr"
@Prev "timeval"
@Toc "Basic Data Types"

fattr
.....

     struct fattr {
         ftype        type;
         unsigned int mode;
         unsigned int nlink;
         unsigned int uid;
         unsigned int gid;
         unsigned int size;
         unsigned int blocksize;
         unsigned int rdev;
         unsigned int blocks;
         unsigned int fsid;
         unsigned int fileid;
         timeval      atime;
         timeval      mtime;
         timeval      ctime;
     };

   The `fattr' structure contains the attributes of a file; `type' is
the type of the file; `nlink' is the number of hard links to the file
(the number of different names for the same file); `uid' is the user
identification number of the owner of the file; `gid' is the group
identification number of the group of the file; `size' is the size in
bytes of the file; `blocksize' is the size in bytes of a block of the
file; `rdev' is the device number of the file if it is type `NFCHR' or
`NFBLK'; `blocks' is the number of blocks the file takes up on disk;
`fsid' is the file system identifier for the filesystem containing the
file; `fileid' is a number that uniquely identifies the file within its
filesystem; `atime' is the time when the file was last accessed for
either read or write; `mtime' is the time when the file data was last
modified (written); and `ctime' is the time when the status of the file
was last changed.  Writing to the file also changes `ctime' if the size
of the file changes.

   `mode' is the access mode encoded as a set of bits.  Notice that the
file type is specified both in the mode bits and in the file type.
This is really a bug in the protocol and will be fixed in future
versions.  The descriptions given below specify the bit positions using
octal numbers.

     Bit      Description
     
     0040000  This is a directory; `type' field should be NFDIR.
     0020000  This is a character special file; `type' field should be NFCHR.
     0060000  This is a block special file; `type' field should be NFBLK.
     0100000  This is a regular file; `type' field should be NFREG.
     0120000  This is a symbolic link file; `type' field should be NFLNK.
     0140000  This is a named socket; `type' field should be NFNON.
     0004000  Set user id on execution.
     0002000  Set group id on execution.
     0001000  Save swapped text even after use.
     0000400  Read permission for owner.
     0000200  Write permission for owner.
     0000100  Execute and search permission for owner.
     0000040  Read permission for group.
     0000020  Write permission for group.
     0000010  Execute and search permission for group.
     0000004  Read permission for others.
     0000002  Write permission for others.
     0000001  Execute and search permission for others.

   Notes:
  1. The bits are the same as the mode bits returned by the `stat'
     system call in the UNIX system.  The file type is specified both
     in the mode bits and in the file type.  This is fixed in future
     versions.

  2. The "rdev" field in the attributes structure is an operating system
     specific device specifier.  It will be removed and generalized in
     the next revision of the protocol.


@EndNode

@Node "sattr" "RPC.guide/sattr"
@Next "filename"
@Prev "fattr"
@Toc "Basic Data Types"

sattr
.....

     struct sattr {
         unsigned int mode;
         unsigned int uid;
         unsigned int gid;
         unsigned int size;
         timeval      atime;
         timeval      mtime;
     };

   The `sattr' structure contains the file attributes which can be set
from the client.  The fields are the same as for `fattr' above.  A
`size' of zero means the file should be truncated.  A value of `-1'
indicates a field that should be ignored.


@EndNode

@Node "filename" "RPC.guide/filename"
@Next "path"
@Prev "sattr"
@Toc "Basic Data Types"

filename
........

     typedef string filename<MAXNAMLEN>;

   The type `filename' is used for passing file names or pathname
components.


@EndNode

@Node "path" "RPC.guide/path"
@Next "attrstat"
@Prev "filename"
@Toc "Basic Data Types"

path
....

     typedef string path<MAXPATHLEN>;

   The type `path' is a pathname.  The server considers it as a string
with no internal structure, but to the client it is the name of a node
in a filesystem tree.


@EndNode

@Node "attrstat" "RPC.guide/attrstat"
@Next "diropargs"
@Prev "path"
@Toc "Basic Data Types"

attrstat
........

     union attrstat switch (stat status) {
         case NFS_OK:
             fattr attributes;
         default:
             void;
     };

   The `attrstat' structure is a common procedure result.  It contains
a `status' and, if the call succeeded, it also contains the attributes
of the file on which the operation was done.


@EndNode

@Node "diropargs" "RPC.guide/diropargs"
@Next "diropres"
@Prev "attrstat"
@Toc "Basic Data Types"

diropargs
.........

     struct diropargs {
         fhandle  dir;
         filename name;
     };

   The `diropargs' structure is used in directory operations.  The
`fhandle dir' is the directory in which to find the file `name'.  A
directory operation is one in which the directory is affected.


@EndNode

@Node "diropres" "RPC.guide/diropres"
@Prev "diropargs"
@Toc "Basic Data Types"

diropres
........

     union diropres switch (stat status) {
         case NFS_OK:
             struct {
                 fhandle file;
                 fattr   attributes;
             } diropok;
         default:
             void;
     };

   The results of a directory operation are returned in a `diropres'
structure.  If the call succeeded, a new file handle `file' and the
`attributes' associated with that file are returned along with the
`status'.


@EndNode

@Node "Server Procedures" "RPC.guide/Server Procedures"
@Prev "Basic Data Types"
@Toc "NFS Protocol Definition"

Server Procedures
-----------------

   The protocol definition is given as a set of procedures with
arguments and results defined using the RPC language.  A brief
description of the function of each procedure should provide enough
information to allow implementation.


 @{" Do Nothing " Link "Do Nothing"} 
 @{" Get File Attributes " Link "Get File Attributes"} 
 @{" Set File Attributes " Link "Set File Attributes"} 
 @{" Get Filesystem Root " Link "Get Filesystem Root"} 
 @{" Look Up File Name " Link "Look Up File Name"} 
 @{" Read From Symbolic Link " Link "Read From Symbolic Link"} 
 @{" Read From File " Link "Read From File"} 
 @{" Write to Cache " Link "Write to Cache"} 
 @{" Write to File " Link "Write to File"} 
 @{" Create File " Link "Create File"} 
 @{" Remove File " Link "Remove File"} 
 @{" Rename File " Link "Rename File"} 
 @{" Create Link to File " Link "Create Link to File"} 
 @{" Create Symbolic Link " Link "Create Symbolic Link"} 
 @{" Create Directory " Link "Create Directory"} 
 @{" Remove Directory " Link "Remove Directory"} 
 @{" Read From Directory " Link "Read From Directory"} 
 @{" Get Filesystem Attributes " Link "Get Filesystem Attributes"} 

   All of the procedures in the NFS protocol are assumed to be
synchronous.  When a procedure returns to the client, the client can
assume that the operation has completed and any data associated with
the request is now on stable storage.  For example, a client `WRITE'
request may cause the server to update data blocks, filesystem
information blocks (such as indirect blocks), and file attribute
information (size and modify times).  When the `WRITE' returns to the
client, it can assume that the write is safe, even in case of a server
crash, and it can discard the data written.  This is a very important
part of the statelessness of the server.  If the server waited to flush
data from remote requests, the client would have to save those requests
so that it could resend them in case of a server crash.

     /*
      * Remote file service routines
      */
     program NFS_PROGRAM {
         version NFS_VERSION {
             void        NFSPROC_NULL(void)              = 0;
             attrstat    NFSPROC_GETATTR(fhandle)        = 1;
             attrstat    NFSPROC_SETATTR(sattrargs)      = 2;
             void        NFSPROC_ROOT(void)              = 3;
             diropres    NFSPROC_LOOKUP(diropargs)       = 4;
             readlinkres NFSPROC_READLINK(fhandle)       = 5;
             readres     NFSPROC_READ(readargs)          = 6;
             void        NFSPROC_WRITECACHE(void)        = 7;
             attrstat    NFSPROC_WRITE(writeargs)        = 8;
             diropres    NFSPROC_CREATE(createargs)      = 9;
             stat        NFSPROC_REMOVE(diropargs)       = 10;
             stat        NFSPROC_RENAME(renameargs)      = 11;
             stat        NFSPROC_LINK(linkargs)          = 12;
             stat        NFSPROC_SYMLINK(symlinkargs)    = 13;
             diropres    NFSPROC_MKDIR(createargs)       = 14;
             stat        NFSPROC_RMDIR(diropargs)        = 15;
             readdirres  NFSPROC_READDIR(readdirargs)    = 16;
             statfsres   NFSPROC_STATFS(fhandle)         = 17;
         } = 2;
     } = 100003;


@EndNode

@Node "Do Nothing" "RPC.guide/Do Nothing"
@Next "Get File Attributes"
@Toc "Server Procedures"

Do Nothing
..........

     void
     NFSPROC_NULL(void) = 0;

   This procedure does no work.  It is made available in all RPC
services to allow server response testing and timing.


@EndNode

@Node "Get File Attributes" "RPC.guide/Get File Attributes"
@Next "Set File Attributes"
@Prev "Do Nothing"
@Toc "Server Procedures"

Get File Attributes
...................

     attrstat
     NFSPROC_GETATTR (fhandle) = 1;

   If the reply status is `NFS_OK', then the reply attributes contains
the attributes for the file given by the input fhandle.


@EndNode

@Node "Set File Attributes" "RPC.guide/Set File Attributes"
@Next "Get Filesystem Root"
@Prev "Get File Attributes"
@Toc "Server Procedures"

Set File Attributes
...................

     struct sattrargs {
         fhandle file;
         sattr attributes;
     };
     
     attrstat
     NFSPROC_SETATTR (sattrargs) = 2;

   The `attributes' argument contains fields which are either `-1' or
are the new value for the attributes of `file'.  If the reply status is
`NFS_OK', then the reply attributes have the attributes of the file
after the `SETATTR' operation has completed.

   *Note:* The use of `-1' to indicate an unused field in `attributes'
is changed in the next version of the protocol.


@EndNode

@Node "Get Filesystem Root" "RPC.guide/Get Filesystem Root"
@Next "Look Up File Name"
@Prev "Set File Attributes"
@Toc "Server Procedures"

Get Filesystem Root
...................

     void
     NFSPROC_ROOT(void) = 3;

   Obsolete.  This procedure is no longer used because finding the root
file handle of a filesystem requires moving pathnames between client and
server.  To do this right we would have to define a network standard
representation of pathnames.  Instead, the function of looking up the
root file handle is done by the `MNTPROC_MNT()' procedure.  (For
details, see @{"Mount Protocol Definition" Link "Mount Protocol Definition"}).


@EndNode

@Node "Look Up File Name" "RPC.guide/Look Up File Name"
@Next "Read From Symbolic Link"
@Prev "Get Filesystem Root"
@Toc "Server Procedures"

Look Up File Name
.................

     diropres
     NFSPROC_LOOKUP(diropargs) = 4;

   If the reply `status' is `NFS_OK', then the reply `file' and reply
`attributes' are the file handle and attributes for the file `name' in
the directory given by `dir' in the argument.


@EndNode

@Node "Read From Symbolic Link" "RPC.guide/Read From Symbolic Link"
@Next "Read From File"
@Prev "Look Up File Name"
@Toc "Server Procedures"

Read From Symbolic Link
.......................

     union readlinkres switch (stat status) {
         case NFS_OK:
             path data;
         default:
             void;
     };
     
     readlinkres
     NFSPROC_READLINK(fhandle) = 5;

   If `status' has the value `NFS_OK', then the reply `data' is the
data in the symbolic link given by the file referred to by the
`fhandle' argument.

   *Note:* since NFS always parses pathnames on the client, the
pathname in a symbolic link may mean something different (or be
meaningless) on a different client or on the server if a different
pathname syntax is used.


@EndNode

@Node "Read From File" "RPC.guide/Read From File"
@Next "Write to Cache"
@Prev "Read From Symbolic Link"
@Toc "Server Procedures"

Read From File
..............

     struct readargs {
         fhandle file;
         unsigned offset;
         unsigned count;
         unsigned totalcount;
     };
     
     union readres switch (stat status) {
         case NFS_OK:
             fattr attributes;
             opaque data<NFS_MAXDATA>;
         default:
             void;
     };
     
     readres
     NFSPROC_READ(readargs) = 6;

   Returns up to `count' bytes of `data' from the file given by `file',
starting at `offset' bytes from the beginning of the file.  The first
byte of the file is at offset zero.  The file attributes after the read
takes place are returned in `attributes'.

   *Note:* The argument `totalcount' is unused, and is removed in the
next protocol revision.


@EndNode

@Node "Write to Cache" "RPC.guide/Write to Cache"
@Next "Write to File"
@Prev "Read From File"
@Toc "Server Procedures"

Write to Cache
..............

     void
     NFSPROC_WRITECACHE(void) = 7;

   To be used in the next protocol revision.


@EndNode

@Node "Write to File" "RPC.guide/Write to File"
@Next "Create File"
@Prev "Write to Cache"
@Toc "Server Procedures"

Write to File
.............

     struct writeargs {
         fhandle file;
         unsigned beginoffset;
         unsigned offset;
         unsigned totalcount;
         opaque data<NFS_MAXDATA>;
     };
     
     attrstat
     NFSPROC_WRITE(writeargs) = 8;

   Writes `data' beginning `offset' bytes from the beginning of `file'.
The first byte of the file is at offset zero.  If the reply `status'
is `NFS_OK', then the reply `attributes' contains the attributes of the
file after the write has completed.  The write operation is atomic.
Data from this call to `WRITE' will not be mixed with data from another
client's calls.

   *Note:* The arguments `beginoffset' and `totalcount' are ignored and
are removed in the next protocol revision.


@EndNode

@Node "Create File" "RPC.guide/Create File"
@Next "Remove File"
@Prev "Write to File"
@Toc "Server Procedures"

Create File
...........

     struct createargs {
         diropargs where;
         sattr attributes;
     };
     
     diropres
     NFSPROC_CREATE(createargs) = 9;

   The file `name' is created in the directory given by `dir'.  The
initial attributes of the new file are given by `attributes'.  A reply
`status' of `NFS_OK' indicates that the file was created, and reply
`file' and reply `attributes' are its file handle and attributes.  Any
other reply `status' means that the operation failed and no file was
created.

   *Note:* This routine should pass an exclusive create flag, meaning
"create the file only if it is not already there".


@EndNode

@Node "Remove File" "RPC.guide/Remove File"
@Next "Rename File"
@Prev "Create File"
@Toc "Server Procedures"

Remove File
...........

     stat
     NFSPROC_REMOVE(diropargs) = 10;

   The file `name' is removed from the directory given by `dir'.  A
reply of `NFS_OK' means the directory entry was removed.

   *Note:* possibly non-idempotent operation.


@EndNode

@Node "Rename File" "RPC.guide/Rename File"
@Next "Create Link to File"
@Prev "Remove File"
@Toc "Server Procedures"

Rename File
...........

     struct renameargs {
         diropargs from;
         diropargs to;
     };
     
     stat
     NFSPROC_RENAME(renameargs) = 11;

   The existing file `from.name' in the directory given by `from.dir'
is renamed to `to.name' in the directory given by `to.dir'.  If the
reply is `NFS_OK', the file was renamed.  The RENAME operation is
atomic on the server; it cannot be interrupted in the middle.

   *Note:* possibly non-idempotent operation.


@EndNode

@Node "Create Link to File" "RPC.guide/Create Link to File"
@Next "Create Symbolic Link"
@Prev "Rename File"
@Toc "Server Procedures"

Create Link to File
...................

     struct linkargs {
         fhandle from;
         diropargs to;
     };
     
     stat
     NFSPROC_LINK(linkargs) = 12;

   Creates the file `to.name' in the directory given by `to.dir', which
is a hard link to the existing file given by `from'.  If the return
value is `NFS_OK', a link was created.  Any other return value
indicates an error, and the link was not created.

   A hard link should have the property that changes to either of the
linked files are reflected in both files.  When a hard link is made to a
file, the attributes for the file should have a value for `nlink' that
is one greater than the value before the link.

   *Note:* possibly non-idempotent operation.


@EndNode

@Node "Create Symbolic Link" "RPC.guide/Create Symbolic Link"
@Next "Create Directory"
@Prev "Create Link to File"
@Toc "Server Procedures"

Create Symbolic Link
....................

     struct symlinkargs {
         diropargs from;
         path to;
         sattr attributes;
     };
     
     stat
     NFSPROC_SYMLINK(symlinkargs) = 13;

   Creates the file `from.name' with ftype `NFLNK' in the directory
given by `from.dir'.  The new file contains the pathname `to' and has
initial attributes given by `attributes'.  If the return value is
`NFS_OK', a link was created.  Any other return value indicates an
error, and the link was not created.

   A symbolic link is a pointer to another file.  The name given in
`to' is not interpreted by the server, only stored in the newly created
file.  When the client references a file that is a symbolic link, the
contents of the symbolic link are normally transparently reinterpreted
as a pathname to substitute.  A `READLINK' operation returns the data
to the client for interpretation.

   *Note:* On UNIX servers the attributes are never used, since
symbolic links always have mode `0777'.


@EndNode

@Node "Create Directory" "RPC.guide/Create Directory"
@Next "Remove Directory"
@Prev "Create Symbolic Link"
@Toc "Server Procedures"

Create Directory
................

     diropres
     NFSPROC_MKDIR (createargs) = 14;

   The new directory `where.name' is created in the directory given by
`where.dir'.  The initial attributes of the new directory are given by
`attributes'.  A reply `status' of `NFS_OK' indicates that the new
directory was created, and reply `file' and reply `attributes' are its
file handle and attributes.  Any other reply `status' means that the
operation failed and no directory was created.

   *Note:* possibly non-idempotent operation.


@EndNode

@Node "Remove Directory" "RPC.guide/Remove Directory"
@Next "Read From Directory"
@Prev "Create Directory"
@Toc "Server Procedures"

Remove Directory
................

     stat
     NFSPROC_RMDIR(diropargs) = 15;

   The existing empty directory `name' in the directory given by `dir'
is removed.  If the reply is `NFS_OK', the directory was removed.

   *Note:* possibly non-idempotent operation.


@EndNode

@Node "Read From Directory" "RPC.guide/Read From Directory"
@Next "Get Filesystem Attributes"
@Prev "Remove Directory"
@Toc "Server Procedures"

Read From Directory
...................

     struct readdirargs {
         fhandle dir;
         nfscookie cookie;
         unsigned count;
     };
     
     struct entry {
         unsigned fileid;
         filename name;
         nfscookie cookie;
         entry *nextentry;
     };
     
     union readdirres switch (stat status) {
         case NFS_OK:
             struct {
                 entry *entries;
                 bool eof;
             } readdirok;
         default:
             void;
     };
     
     readdirres
     NFSPROC_READDIR (readdirargs) = 16;

   Returns a variable number of directory entries, with a total size of
up to `count' bytes, from the directory given by `dir'.  If the
returned value of `status' is `NFS_OK', then it is followed by a
variable number of `entry's.  Each `entry' contains a `fileid' which
consists of a unique number to identify the file within a filesystem,
the `name' of the file, and a `cookie' which is an opaque pointer to
the next entry in the directory.  The cookie is used in the next
`READDIR' call to get more entries starting at a given point in the
directory.  The special cookie zero (all bits zero) can be used to get
the entries starting at the beginning of the directory.  The `fileid'
field should be the same number as the `fileid' in the the attributes
of the file.  (see @{"Basic Data Types" Link "Basic Data Types"}.)  The `eof' flag has a value of
`TRUE' if there are no more entries in the directory.


@EndNode

@Node "Get Filesystem Attributes" "RPC.guide/Get Filesystem Attributes"
@Prev "Read From Directory"
@Toc "Server Procedures"

Get Filesystem Attributes
.........................

     union statfsres (stat status) {
         case NFS_OK:
             struct {
                 unsigned tsize;
                 unsigned bsize;
                 unsigned blocks;
                 unsigned bfree;
                 unsigned bavail;
             } info;
         default:
             void;
     };
     
     statfsres
     NFSPROC_STATFS(fhandle) = 17;

   If the reply `status' is `NFS_OK', then the reply `info' gives the
attributes for the filesystem that contains file referred to by the
input fhandle.  The attribute fields contain the following values:
`tsize'
     The optimum transfer size of the server in bytes.  This is the
     number of bytes the server would like to have in the data part of
     READ and WRITE requests.

`bsize'
     The block size in bytes of the filesystem.

`blocks'
     The total number of `bsize' blocks on the filesystem.

`bfree'
     The number of free `bsize' blocks on the filesystem.

`bavail'
     The number of `bsize' blocks available to non-privileged users.

   *Note:* This call does not work well if a filesystem has variable
size blocks.


@EndNode

@Node "NFS Implementation Issues" "RPC.guide/NFS Implementation Issues"
@Next "Mount Protocol Definition"
@Prev "NFS Protocol Definition"
@Toc "Network File System Version 2 Protocol Specification"

NFS Implementation Issues
=========================

   The NFS protocol is designed to be operating system independent, but
since this version was designed in a UNIX environment, many operations
have semantics similar to the operations of the UNIX file system.  This
section discusses some of the implementation-specific semantic issues.


 @{" Server-Client Relationship " Link "Server-Client Relationship"} 
 @{" Pathname Interpretation " Link "Pathname Interpretation"} 
 @{" Permission Issues " Link "Permission Issues"} 
 @{" Setting RPC Parameters " Link "Setting RPC Parameters"} 


@EndNode

@Node "Server-Client Relationship" "RPC.guide/Server-Client Relationship"
@Next "Pathname Interpretation"
@Toc "NFS Implementation Issues"

Server/Client Relationship
--------------------------

   The NFS protocol is designed to allow servers to be as simple and
general as possible.  Sometimes the simplicity of the server can be a
problem, if the client wants to implement complicated filesystem
semantics.

   For example, some operating systems allow removal of open files.  A
process can open a file and, while it is open, remove it from the
directory.  The file can be read and written as long as the process
keeps it open, even though the file has no name in the filesystem.  It
is impossible for a stateless server to implement these semantics.  The
client can do some tricks such as renaming the file on remove, and only
removing it on close.  We believe that the server provides enough
functionality to implement most file system semantics on the client.

   Every NFS client can also potentially be a server, and remote and
local mounted filesystems can be freely intermixed.  This leads to some
interesting problems when a client travels down the directory tree of a
remote filesystem and reaches the mount point on the server for another
remote filesystem.  Allowing the server to follow the second remote
mount would require loop detection, server lookup, and user
revalidation.  Instead, we decided not to let clients cross a server's
mount point.  When a client does a `LOOKUP' on a directory on which the
server has mounted a filesystem, the client sees the underlying
directory instead of the mounted directory.  A client can do remote
mounts that match the server's mount points to maintain the server's
view.


@EndNode

@Node "Pathname Interpretation" "RPC.guide/Pathname Interpretation"
@Next "Permission Issues"
@Prev "Server-Client Relationship"
@Toc "NFS Implementation Issues"

Pathname Interpretation
-----------------------

   There are a few complications to the rule that pathnames are always
parsed on the client.  For example, symbolic links could have different
interpretations on different clients.  Another common problem for
non-UNIX implementations is the special interpretation of the pathname
`..'  to mean the parent of a given directory.  The next revision of
the protocol uses an explicit flag to indicate the parent instead.


@EndNode

@Node "Permission Issues" "RPC.guide/Permission Issues"
@Next "Setting RPC Parameters"
@Prev "Pathname Interpretation"
@Toc "NFS Implementation Issues"

Permission Issues
-----------------

   The NFS protocol, strictly speaking, does not define the permission
checking used by servers.  However, it is expected that a server will do
normal operating system permission checking using `AUTH_UNIX' style
authentication as the basis of its protection mechanism.  The server
gets the client's effective "uid", effective "gid", and groups on each
call and uses them to check permission.  There are various problems
with this method that can been resolved in interesting ways.

   Using "uid" and "gid" implies that the client and server share the
same "uid" list.  Every server and client pair must have the same
mapping from user to "uid" and from group to "gid".  Since every client
can also be a server, this tends to imply that the whole network shares
the same "uid/gid" space.  `AUTH_DES' (and the next revision of the NFS
protocol) uses string names instead of numbers, but there are still
complex problems to be solved.

   Another problem arises due to the usually stateful open operation.
Most operating systems check permission at open time, and then check
that the file is open on each read and write request.  With stateless
servers, the server has no idea that the file is open and must do
permission checking on each read and write call.  On a local
filesystem, a user can open a file and then change the permissions so
that no one is allowed to touch it, but will still be able to write to
the file because it is open.  On a remote filesystem, by contrast, the
write would fail.  To get around this problem, the server's permission
checking algorithm should allow the owner of a file to access it
regardless of the permission setting.

   A similar problem has to do with paging in from a file over the
network.  The operating system usually checks for execute permission
before opening a file for demand paging, and then reads blocks from the
open file.  The file may not have read permission, but after it is
opened it doesn't matter.  An NFS server can not tell the difference
between a normal file read and a demand page-in read.  To make this
work, the server allows reading of files if the "uid" given in the call
has execute or read permission on the file.

   In most operating systems, a particular user (on the user ID zero)
has access to all files no matter what permission and ownership they
have.  This "super-user" permission may not be allowed on the server,
since anyone who can become super-user on their workstation could gain
access to all remote files.  The UNIX server by default maps user id 0
to -2 before doing its access checking.  This works except for NFS root
filesystems, where super-user access cannot be avoided.


@EndNode

@Node "Setting RPC Parameters" "RPC.guide/Setting RPC Parameters"
@Prev "Permission Issues"
@Toc "NFS Implementation Issues"

Setting RPC Parameters
----------------------

   Various file system parameters and options should be set at mount
time.  The mount protocol is described in the appendix below.  For
example, "Soft" mounts as well as "Hard" mounts are usually both
provided.  Soft mounted file systems return errors when RPC operations
fail (after a given number of optional retransmissions), while hard
mounted file systems continue to retransmit forever.  Clients and
servers may need to keep caches of recent operations to help avoid
problems with non-idempotent operations.


@EndNode

@Node "Mount Protocol Definition" "RPC.guide/Mount Protocol Definition"
@Prev "NFS Implementation Issues"
@Toc "Network File System Version 2 Protocol Specification"

Mount Protocol Definition
=========================


 @{" Mount Protocol Introduction " Link "Mount Protocol Introduction"} 
 @{" Mount Protocol RPC Information " Link "Mount Protocol RPC Information"} 
 @{" Mount Protocol Sizes of XDR Structures " Link "Mount Protocol Sizes of XDR Structures"} 
 @{" Mount Protocol Basic Data Types " Link "Mount Protocol Basic Data Types"} 
 @{" Mount Protocol Server Procedures " Link "Mount Protocol Server Procedures"} 


@EndNode

@Node "Mount Protocol Introduction" "RPC.guide/Mount Protocol Introduction"
@Next "Mount Protocol RPC Information"
@Toc "Mount Protocol Definition"

Introduction
------------

   The mount protocol is separate from, but related to, the NFS
protocol.  It provides operating system specific services to get the
NFS off the ground - looking up server path names, validating user
identity, and checking access permissions.  Clients use the mount
protocol to get the first file handle, which allows them entry into a
remote filesystem.

   The mount protocol is kept separate from the NFS protocol to make it
easy to plug in new access checking and validation methods without
changing the NFS server protocol.

   Notice that the protocol definition implies stateful servers because
the server maintains a list of client's mount requests.  The mount list
information is not critical for the correct functioning of either the
client or the server.  It is intended for advisory use only, for
example, to warn possible clients when a server is going down.

   Version one of the mount protocol is used with version two of the NFS
protocol.  The only connecting point is the `fhandle' structure, which
is the same for both protocols.


@EndNode

@Node "Mount Protocol RPC Information" "RPC.guide/Mount Protocol RPC Information"
@Next "Mount Protocol Sizes of XDR Structures"
@Prev "Mount Protocol Introduction"
@Toc "Mount Protocol Definition"

RPC Information
---------------

Authentication
     The mount service uses `AUTH_UNIX' and `AUTH_DES' style
     authentication only.

Transport Protocols
     The mount service is currently supported on UDP/IP only.

Port Number
     Consult the server's portmapper, described in
     @{"Remote Procedure Calls Protocol Specification" Link "Remote Procedure Calls Protocol Specification"}, to find the port
     number on which the mount service is registered.


@EndNode

@Node "Mount Protocol Sizes of XDR Structures" "RPC.guide/Mount Protocol Sizes of XDR Structures"
@Next "Mount Protocol Basic Data Types"
@Prev "Mount Protocol RPC Information"
@Toc "Mount Protocol Definition"

Sizes of XDR Structures
-----------------------

   These are the sizes, given in decimal bytes, of various XDR
structures used in the protocol:

     /* The maximum number of bytes in a pathname argument */
     const MNTPATHLEN = 1024;
     
     /* The maximum number of bytes in a name argument */
     const MNTNAMLEN = 255;
     
     /* The size in bytes of the opaque file handle */
     const FHSIZE = 32;


@EndNode

@Node "Mount Protocol Basic Data Types" "RPC.guide/Mount Protocol Basic Data Types"
@Next "Mount Protocol Server Procedures"
@Prev "Mount Protocol Sizes of XDR Structures"
@Toc "Mount Protocol Definition"

Basic Data Types
----------------

   This section presents the data types used by the mount protocol.  In
many cases they are similar to the types used in NFS.


 @{" fhandle (Mount) " Link "fhandle (Mount)"} 
 @{" fhstatus " Link "fhstatus"} 
 @{" dirpath " Link "dirpath"} 
 @{" name " Link "name"} 


@EndNode

@Node "fhandle (Mount)" "RPC.guide/fhandle (Mount)"
@Next "fhstatus"
@Toc "Mount Protocol Basic Data Types"

fhandle
.......

     typedef opaque fhandle[FHSIZE];

   The type `fhandle' is the file handle that the server passes to the
client.  All file operations are done using file handles to refer to a
file or directory.  The file handle can contain whatever information the
server needs to distinguish an individual file.

   This is the same as the `fhandle' XDR definition in version 2 of the
NFS protocol; see @{"Basic Data Types" Link "Basic Data Types"} in the definition of the NFS
protocol, above.


@EndNode

@Node "fhstatus" "RPC.guide/fhstatus"
@Next "dirpath"
@Prev "fhandle (Mount)"
@Toc "Mount Protocol Basic Data Types"

fhstatus
........

     union fhstatus switch (unsigned status) {
         case 0:
             fhandle directory;
         default:
             void;
     };

   The type `fhstatus' is a union.  If a `status' of zero is returned,
the call completed successfully, and a file handle for the `directory'
follows.  A non-zero status indicates some sort of error.  In this case
the status is a UNIX error number.


@EndNode

@Node "dirpath" "RPC.guide/dirpath"
@Next "name"
@Prev "fhstatus"
@Toc "Mount Protocol Basic Data Types"

dirpath
.......

     typedef string dirpath<MNTPATHLEN>;

   The type `dirpath' is a server pathname of a directory.


@EndNode

@Node "name" "RPC.guide/name"
@Prev "dirpath"
@Toc "Mount Protocol Basic Data Types"

name
....

     typedef string name<MNTNAMLEN>;

   The type `name' is an arbitrary string used for various names.


@EndNode

@Node "Mount Protocol Server Procedures" "RPC.guide/Mount Protocol Server Procedures"
@Prev "Mount Protocol Basic Data Types"
@Toc "Mount Protocol Definition"

Server Procedures
-----------------

   The following sections define the RPC procedures supplied by a mount
server.


 @{" Do Nothing (Mount) " Link "Do Nothing (Mount)"} 
 @{" Add Mount Entry " Link "Add Mount Entry"} 
 @{" Return Mount Entries " Link "Return Mount Entries"} 
 @{" Remove Mount Entry " Link "Remove Mount Entry"} 
 @{" Remove All Mount Entries " Link "Remove All Mount Entries"} 
 @{" Return Export List " Link "Return Export List"} 

     /*
      * Protocol description for the mount program
      */
     program MOUNTPROG {
     /*
      * Version 1 of the mount protocol used with
      * version 2 of the NFS protocol.
      */
         version MOUNTVERS {
             void        MOUNTPROC_NULL(void)    = 0;
             fhstatus    MOUNTPROC_MNT(dirpath)  = 1;
             mountlist   MOUNTPROC_DUMP(void)    = 2;
             void        MOUNTPROC_UMNT(dirpath) = 3;
             void        MOUNTPROC_UMNTALL(void) = 4;
             exportlist  MOUNTPROC_EXPORT(void)  = 5;
         } = 1;
     } = 100005;


@EndNode

@Node "Do Nothing (Mount)" "RPC.guide/Do Nothing (Mount)"
@Next "Add Mount Entry"
@Toc "Mount Protocol Server Procedures"

Do Nothing
..........

     void
     MNTPROC_NULL(void) = 0;

   This procedure does no work.  It is made available in all RPC
services to allow server response testing and timing.


@EndNode

@Node "Add Mount Entry" "RPC.guide/Add Mount Entry"
@Next "Return Mount Entries"
@Prev "Do Nothing (Mount)"
@Toc "Mount Protocol Server Procedures"

Add Mount Entry
...............

     fhstatus
     MNTPROC_MNT(dirpath) = 1;

   If the reply `status' is `0', then the reply `directory' contains
the file handle for the directory `dirname'.  This file handle may be
used in the NFS protocol.  This procedure also adds a new entry to the
mount list for this client mounting `dirname'.


@EndNode

@Node "Return Mount Entries" "RPC.guide/Return Mount Entries"
@Next "Remove Mount Entry"
@Prev "Add Mount Entry"
@Toc "Mount Protocol Server Procedures"

Return Mount Entries
....................

     struct *mountlist {
         name      hostname;
         dirpath   directory;
         mountlist nextentry;
     };
     
     mountlist
     MNTPROC_DUMP(void) = 2;

   Returns the list of remote mounted filesystems.  The `mountlist'
contains one entry for each `hostname' and `directory' pair.


@EndNode

@Node "Remove Mount Entry" "RPC.guide/Remove Mount Entry"
@Next "Remove All Mount Entries"
@Prev "Return Mount Entries"
@Toc "Mount Protocol Server Procedures"

Remove Mount Entry
..................

     void
     MNTPROC_UMNT(dirpath) = 3;

   Removes the mount list entry for the input `dirpath'.


@EndNode

@Node "Remove All Mount Entries" "RPC.guide/Remove All Mount Entries"
@Next "Return Export List"
@Prev "Remove Mount Entry"
@Toc "Mount Protocol Server Procedures"

Remove All Mount Entries
........................

     void
     MNTPROC_UMNTALL(void) = 4;

   Removes all of the mount list entries for this client.


@EndNode

@Node "Return Export List" "RPC.guide/Return Export List"
@Prev "Remove All Mount Entries"
@Toc "Mount Protocol Server Procedures"

Return Export List
..................

     struct *groups {
         name grname;
         groups grnext;
     };
     
     struct *exportlist {
         dirpath filesys;
         groups groups;
         exportlist next;
     };
     
     exportlist
     MNTPROC_EXPORT(void) = 5;

   Returns a variable number of export list entries.  Each entry
contains a filesystem name and a list of groups that are allowed to
import it.  The filesystem name is in `filesys', and the group name is
in the list `groups'.

   *Note:* The exportlist should contain more information about the
status of the filesystem, such as a read-only flag.


@EndNode

@Node "Manual Pages" "RPC.guide/Manual Pages"
@Next "Function Index"
@Prev "Network File System Version 2 Protocol Specification"
@Toc "Main"

Manual Pages
************

   All functions in these manual pages need the include file
`rpc/rpc.h' to be included.


Utilities:
 @{" portmap " Link "portmap Manual Page"}                     The RPC program-to-port mapper
 @{" rpcgen " Link "rpcgen Manual Page"}                    The RPC protocol compiler
 @{" rpcinfo " Link "rpcinfo Manual Page"}                     View RPC program information

`rpc' Data Base File Format:
 @{" rpc Data Base File Format " Link "rpc Data Base File Format"}   rpc program number database

Library Functions:
 @{" Miscellaneous Utility Functions " Link "Miscellaneous Utility Functions"} 
 @{" RPC Function Reference " Link "RPC Function Reference"} 
 @{" XDR Function Reference " Link "XDR Function Reference"} 


@EndNode

@Node "portmap Manual Page" "RPC.guide/portmap Manual Page"
@Next "rpcgen Manual Page"
@Toc "Manual Pages"

`portmap' Manual Page
=====================

NAME
     `portmap' - DARPA port to RPC program number mapper

SYNOPSIS
     `AmiTCP:bin/portmap'

DESCRIPTION
     `portmap' is a server that converts RPC program numbers into DARPA
     protocol port numbers.  It must be running in order to make RPC
     calls.  When an RPC server is started, it will tell `portmap' what
     port number it is listening to, and what RPC program numbers it is
     prepared to serve.  When a client wishes to make an RPC call to a
     given program number, it will first contact `portmap' on the
     server machine to determine the port number where RPC packets
     should be sent.  Normally, standard RPC servers are started by
     `inetd', so `portmap' must be started before `inetd' is invoked.

SEE ALSO
@{"rpcinfo" Link "rpcinfo Manual Page"}.

BUGS
     If `portmap' crashes, all servers must be restarted.


@EndNode

@Node "rpcgen Manual Page" "RPC.guide/rpcgen Manual Page"
@Next "rpcinfo Manual Page"
@Prev "portmap Manual Page"
@Toc "Manual Pages"

`rpcgen' Manual Page
====================

NAME
     `rpcgen' - an RPC protocol compiler

SYNOPSIS
     `rpcgen infile'

     `rpcgen [-Dname[=value]] [-T] [-K secs] infile'

     `rpcgen -c | -h | -l | -m | -t [-o outfile ] infile'

     `rpcgen [-I] -s nettype [-o outfile] infile'

     `rpcgen -n netid [-o outfile] infile'

DESCRIPTION
     `rpcgen' is a tool that generates C code to implement an RPC
     protocol.  The input to `rpcgen' is a language similar to C known
     as RPC Language (Remote Procedure Call Language).

     `rpcgen' is normally used as in the first synopsis where it takes
     an input file and generates up to four output files.  If the
     infile is named `proto.x', then `rpcgen' will generate a header
     file in `proto.h', XDR routines in `proto_xdr.c', server-side
     stubs in `proto_svc.c', and client-side stubs in `proto_clnt.c'.
     With the `-T' option, it will also generate the RPC dispatch table
     in `proto_tbl.i'.  With the `-Sc' option, it will also generate
     sample code which would illustrate how to use the remote
     procedures on the client side. This code would be created in
     `proto_client.c'.  With the `-Ss' option, it will also generate a
     sample server code which would illustrate how to write the remote
     procedures. This code would be created in `proto_server.c'.

     The server created can be started both by the port monitors (for
     example, inetd or listen) or by itself.  When it is started by a
     port monitor, it creates servers only for the transport for which
     the file descriptor 0 was passed.  The name of the transport must
     be specified by setting up the environmental variable PM_TRANSPORT.
     When the server generated by `rpcgen' is executed, it creates
     server handles for all the transports specified in NETPATH
     environment variable, or if it is unset, it creates server handles
     for all the visible transports from `/etc/netconfig' file.  Note:
     the transports are chosen at run time and not at compile time.
     When the server is self-started, it backgrounds itself by default.
     A special define symbol RPC_SVC_FG can be used to run the server
     process in foreground.

     The second synopsis provides special features which allow for the
     creation of more sophisticated RPC servers.  These features include
     support for user provided #defines and RPC dispatch tables.  The
     entries in the RPC dispatch table contain:

        + pointers to the service routine corresponding to that
          procedure,

        + a pointer to the input and output arguments

        + the size of these routines

     A server can use the dispatch table to check authorization and then
     to execute the service routine; a client library may use it to deal
     with the details of storage management and XDR data conversion.

     The other three synopses shown above are used when one does not
     want to generate all the output files, but only a particular one.
     Some examples of their usage is described in the EXAMPLE section
     below.  When `rpcgen' is executed with the `-s' option, it creates
     servers for that particular class of transports.  When executed
     with the `-n' option, it creates a server for the transport
     specified by netid.  If infile is not specified, `rpcgen' accepts
     the standard input.

     The C preprocessor, ccp, is run on the input file before it is
     actually interpreted by `rpcgen'.  For each type of output file,
     `rpcgen' defines a special preprocessor symbol for use by the
     `rpcgen' programmer:

          RPC_HDR   defined when compiling into header files
          RPC_XDR   defined when compiling into XDR routines
          RPC_SVC   defined when compiling into server-side stubs
          RPC_CLNT  defined when compiling into client-side stubs
          RPC_TBL   defined when compiling into RPC dispatch tables

     Any line beginning with `%' is passed directly into the output
     file, uninterpreted by `rpcgen'.

     For every data type referred to in infile, `rpcgen' assumes that
     there exists a routine with the string xdr_ prepended to the name
     of the data type.  If this routine does not exist in the RPC/XDR
     library, it must be provided.  Providing an undefined data type
     allows customization of XDR routines.

     The following options are available:

    `-a'
          Generate all the files including sample code for client and
          server side.

    `-b'
          This generates code for the SunOS4.1 style of rpc. It is for
          backward compatibilty.  This is the default.

    `-5'
          This generates code for the SysVr4 style of rpc. It is used
          by the Transport Independent RPC that is in Svr4 systems.  By
          default `rpcgen' generates code for SunOS4.1 stype of rpc.

    `-c'
          Compile into XDR routines.

    `-C'
          Generate code in ANSI C. This option also generates code that
          could be compiled with the C++ compiler.  This is the default.

    `-k'
          Generate code in K&R C.  The default is ANSI C.

    `-Dname[=value]'
          Define a symbol name.  Equivalent to the #define directive in
          the source.  If no value is given, value is defined as 1.
          This option may be specified more than once.

    `-h'
          Compile into C data-definitions (a header file).  `-T' option
          can be used in conjunction to produce a header file which
          supports RPC dispatch tables.

    `-I'
          Generate a service that can be started from inetd.  The
          default is to generate a static service that handles
          transports selected with `-s'.  Using `-I' allows starting a
          service by either method.

    `-K secs'
          By default, services created using `rpcgen' wait 120 seconds
          after servicing a request before exiting.  That interval can
          be changed using the `-K' flag.  To create a server that exits
          immediately upon servicing a request, `-K 0' can be used.  To
          create a server that never exits, the appropriate argument is
          `-K -1'.

          When monitoring for a server, some portmonitors, like
          listen(1M), always spawn a new process in response to a
          service request.  If it is known that a server will be used
          with such a monitor, the server should exit immediately on
          completion.  For such servers, `rpcgen' should be used with
          `-K -1'.

    `-l'
          Compile into client-side stubs.

    `-m'
          Compile into server-side stubs, but do not generate a main
          routine.  This option is useful for doing callback-routines
          and for users who need to write their own main routine to do
          initialization.

    `-n netid'
          Compile into server-side stubs for the transport specified by
          netid.  There should be an entry for netid in the netconfig
          database.  This option may be specified more than once, so as
          to compile a server that serves multiple transports.

    `-N'
          Use the newstyle of `rpcgen'. This allows procedures to have
          multiple arguments. It also uses the style of parameter
          passing that closely resembles C. So, when passing an
          argument to a remote procedure you do not have to pass a
          pointer to the argument but the argument itself. This
          behaviour is different from the oldstyle of `rpcgen'
          generated code. The newstyle is not the default case because
          of backward compatibility.

    `-o outfile'
          Specify the name of the output file.  If none is specified,
          standard output is used (`-c', `-h', `-l', `-m', `-n', `-s',
          `-sSc', `-sSs' and `-t' modes only).

    `-s nettype'
          Compile into server-side stubs for all the transports
          belonging to the class nettype.  The supported classes are
          netpath, visible, circuit_n, circuit_v, datagram_n,
          datagram_v, tcp, and udp [see rpc(3N) for the meanings
          associated with these classes].  This option may be specified
          more than once.  Note: the transports are chosen at run time
          and not at compile time.

    `-Sc'
          Generate sample code to show the use of remote procedure and
          how to bind to the server before calling the client side stubs
          generated by `rpcgen'.

    `-Ss'
          Generate skeleton code for the remote procedures on the server
          side. You would need to fill in the actual code for the remote
          procedures.

    `-t'
          Compile into RPC dispatch table.

    `-T'
          Generate the code to support RPC dispatch tables.

     The options `-c', `-h', `-l', `-m', `-s' and `-t' are used
     exclusively to generate a particular type of file, while the
     options `-D' and `-T' are global and can be used with the other
     options.

NOTES
     The RPC Language does not support nesting of structures.  As a
     work- around, structures can be declared at the top-level, and
     their name used inside other structures in order to achieve the
     same effect.

     Name clashes can occur when using program definitions, since the
     apparent scoping does not really apply.  Most of these can be
     avoided by giving unique names for programs, versions, procedures
     and types.

     The server code generated with `-n' option refers to the transport
     indicated by netid and hence is very site specific.

EXAMPLE
     The following example:

             $ rpcgen -T prot.x

     generates the five files: `prot.h', `prot_clnt.c', `prot_svc.c',
     `prot_xdr.c' and `prot_tbl.i'.

     The following example sends the C data-definitions (header file) to
     the standard output.

             $ rpcgen -h prot.x

     To send the test version of the `-DTEST', server side stubs for all
     the transport belonging to the class datagram_n to standard output,
     use:

             $ rpcgen -s datagram_n -DTEST prot.x

     To create the server side stubs for the transport indicated by
     netid tcp, use:

             $ rpcgen -n tcp -o prot_svc.c prot.x

SEE ALSO
     `cpp' manual


@EndNode

@Node "rpcinfo Manual Page" "RPC.guide/rpcinfo Manual Page"
@Next "rpc Data Base File Format"
@Prev "rpcgen Manual Page"
@Toc "Manual Pages"

`rpcinfo' Manual Page
=====================

NAME
     rpcinfo - report RPC information

SYNOPSIS
     `rpcinfo -p [ host ]'

     `rpcinfo [ -n portnum ] -u host program [ version ]'

     `rpcinfo [ -n portnum ] -t host program [ version ]'

     `rpcinfo -b program version'

     `rpcinfo -d program version'

DESCRIPTION
     `rpcinfo' makes an RPC call to an RPC server and reports what it
     finds.

OPTIONS
    `-p'
          Probe the portmapper on host, and print a list of all
          registered RPC programs.  If host is not specified, it
          defaults to the value returned by `gethostname()'.

    `-u'
          Make an RPC call to procedure 0 of program on the specified
          host using UDP, and report whether a response was received.

    `-t'
          Make an RPC call to procedure 0 of program on the specified
          host using TCP, and report whether a response was received.

    `-n'
          Use `portnum' as the port number for the `-t' and `-u'
          options instead of the port number given by the portmapper.

    `-b'
          Make an RPC broadcast to procedure 0 of the specified program
          and version using UDP and report all hosts that respond.

    `-d'
          Delete registration for the RPC service of the specified
          program and version.  This option can be exercised only by
          the superuser.  The program argument can be either a name or
          a number.  If a version is specified, `rpcinfo' attempts to
          call that version of the specified program.  Otherwise,
          rpcinfo attempts to find all the registered version numbers
          for the specified program by calling version 0 (which is
          presumed not to exist; if it does exist, rpcinfo attempts to
          obtain this information by calling an extremely high version
          number instead) and attempts to call each registered version.

     *Note:* the version number is required for -b and -d options.

EXAMPLES
     To show all of the RPC services registered on the local machine
     use:

          example% rpcinfo -p

     To show all of the RPC services registered on the machine named
     klaxon use:

          example% rpcinfo -p klaxon

     To show all machines on the local net that are running the Yellow
     Pages service use:

          example% rpcinfo -b ypserv 'version' | uniq

     where '`version'' is the current Yellow Pages version obtained
     from the results of the `-p' switch above.

     To delete the registration for version 1 of the `walld' service
     use:

          example% rpcinfo -d walld 1

SEE ALSO
@{"rpc" Link "rpc Data Base File Format"}, @{"portmap" Link "portmap Manual Page"}.


@EndNode

@Node "rpc Data Base File Format" "RPC.guide/rpc Data Base File Format"
@Next "Miscellaneous Utility Functions"
@Prev "rpcinfo Manual Page"
@Toc "Manual Pages"

rpc Data Base File Format
=========================

   The `AmiTCP:db/rpc' file contains user readable names that can be
used in place of rpc program numbers.  Each line has the following
information:

  1. name of server for the rpc program

  2. rpc program number

  3. aliases

   Items are separated by any number of blanks and/or tab characters.  A
"#" indicates the beginning of a comment; characters up to the end of
the line are not interpreted by routines which search the file.  Here is
an example of the `rpc' file from the Sun RPC Source distribution.

        #
        # rpc 88/08/01 4.0 RPCSRC; from 1.12   88/02/07 SMI
        #
        portmapper          100000    portmap sunrpc
        rstatd              100001    rstat rstat_svc rup perfmeter
        rusersd             100002    rusers
        nfs                 100003    nfsprog
        ypserv              100004    ypprog
        mountd              100005    mount showmount
        ypbind              100007
        walld               100008    rwall shutdown
        yppasswdd           100009    yppasswd
        etherstatd          100010    etherstat
        rquotad             100011    rquotaprog quota rquota
        sprayd              100012    spray
        3270_mapper         100013
        rje_mapper          100014
        selection_svc       100015    selnsvc
        database_svc        100016
        rexd                100017    rex
        alis                100018
        sched               100019
        llockmgr            100020
        nlockmgr            100021
        x25.inr             100022
        statmon             100023
        status              100024
        bootparam           100026
        ypupdated           100028    ypupdate
        keyserv             100029    keyserver
        tfsd                100037
        nsed                100038
        nsemntd             100039


@EndNode

@Node "Miscellaneous Utility Functions" "RPC.guide/Miscellaneous Utility Functions"
@Next "RPC Function Reference"
@Prev "rpc Data Base File Format"
@Toc "Manual Pages"

Miscellaneous Utility Functions
===============================


 @{" bindresvport() " Link "bindresvport()"} 
 @{" getrpcbyname() " Link "getrpcbyname()"} 
 @{" getrpcbynumber() " Link "getrpcbynumber()"} 
 @{" getrpcport() " Link "getrpcport()"} 


@EndNode

@Node "bindresvport()" "RPC.guide/bindresvport()"
@Next "getrpcbyname()"
@Toc "Miscellaneous Utility Functions"

bindresvport()
--------------

   Bind a socket to a privileged IP port.

     #include <sys/types.h>
     #include <netinet/in.h>
     
     int
     bindresvport(sd, sin)
     int sd;
     struct sockaddr_in *sin;

bindresvport() is used to bind a socket descriptor to a privileged IP
port, that is, a port number in the range 0-1023.  The routine returns
0 if it is successful, otherwise -1 is returned and errno set to
reflect the cause of the error.  Only root can bind to a privileged
port; this call will fail for any other users.


@EndNode

@Node "getrpcbyname()" "RPC.guide/getrpcbyname()"
@Next "getrpcbynumber()"
@Prev "bindresvport()"
@Toc "Miscellaneous Utility Functions"

getrpcbyname()
--------------

   Get an RPC entry.

     #include <netdb.h>
     
     struct rpcent *
     getrpcbyname(name)
     char *name;

Return a pointer to an object with the following structure containing
the broken-out fields of a line in the rpc program number data base,
`AmiTCP:db/rpc'.

     struct    rpcent {
        char *r_name;       /* name of server for this rpc program */
        char **r_aliases;   /* alias list */
        long r_number;      /* rpc program number */
     };

   The members of this structure are:
`r_name'
     The name of the server for this rpc program.

`r_aliases'
     A zero terminated list of alternate names for the rpc program.

`number'
     The rpc program number for this service.

   `getrpcbyname()' sequentially searches from the beginning of the
file until a matching rpc program `name' is found, or until end-of-file
is encountered.

   A `NULL' pointer is returned on `EOF' or error.

   *NOTE:* All information is contained in a static area so it must be
copied if it is to be saved.

See also:
=========

@{"getrpcbynumber()" Link "getrpcbynumber()"}, @{"rpc" Link "rpc Data Base File Format"}, @{"rpcinfo" Link "rpcinfo Manual Page"}.


@EndNode

@Node "getrpcbynumber()" "RPC.guide/getrpcbynumber()"
@Next "getrpcport()"
@Prev "getrpcbyname()"
@Toc "Miscellaneous Utility Functions"

getrpcbynumber()
----------------

   Get an RPC entry.

     #include <netdb.h>
     
     struct rpcent *
     getrpcbynumber(number)
     int number;

Return a pointer to an object with the following structure containing
the broken-out fields of a line in the rpc program number data base,
`AmiTCP:db/rpc'.

     struct    rpcent {
        char *r_name;       /* name of server for this rpc program */
        char **r_aliases;   /* alias list */
        long r_number;      /* rpc program number */
     };

   The members of this structure are:
`r_name'
     The name of the server for this rpc program.

`r_aliases'
     A zero terminated list of alternate names for the rpc program.

`number'
     The rpc program number for this service.

   `getrpcbynumber()' sequentially searches from the beginning of the
file until a matching rpc program `number' is found, or until
end-of-file is encountered.

   A `NULL' pointer is returned on `EOF' or error.

   *NOTE:* All information is contained in a static area so it must be
copied if it is to be saved.

See also:
=========

@{"getrpcbyname()" Link "getrpcbyname()"}, @{"rpc" Link "rpc Data Base File Format"}, @{"rpcinfo" Link "rpcinfo Manual Page"}.


@EndNode

@Node "getrpcport()" "RPC.guide/getrpcport()"
@Prev "getrpcbynumber()"
@Toc "Miscellaneous Utility Functions"

getrpcport()
------------

   Get RPC port number.

     int
     getrpcport(host, prognum, versnum, proto)
     char *host;
     int prognum, versnum, proto;

Returns the port number for version `versnum' of the RPC program
`prognum' running on `host' and using protocol `proto'.  It returns 0
if it cannot contact the portmapper, or if `prognum' is not registered.
If `prognum' is registered but not with version `versnum', it will
still return a port number (for some version of the program) indicating
that the program is indeed registered.  The version mismatch will be
detected upon the first call to the service.


@EndNode

@Node "RPC Function Reference" "RPC.guide/RPC Function Reference"
@Next "XDR Function Reference"
@Prev "Miscellaneous Utility Functions"
@Toc "Manual Pages"

RPC Function Reference
======================

   These routines allow C programs to make procedure calls on other
machines across the network.  First, the client calls a procedure to
send a data packet to the server.  Upon receipt of the packet, the
server calls a dispatch routine to perform the requested service, and
then sends back a reply.  Finally, the procedure call returns to the
client.

   Routines that are used for Secure RPC (DES authentication) are not
available in this release.


 @{" auth_destroy() " Link "auth_destroy()"} 
 @{" authnone_create() " Link "authnone_create()"} 
 @{" authunix_create() " Link "authunix_create()"} 
 @{" authunix_create_default() " Link "authunix_create_default()"} 
 @{" callrpc() " Link "callrpc()"} 
 @{" clnt_broadcast() " Link "clnt_broadcast()"} 
 @{" clnt_call() " Link "clnt_call()"} 
 @{" clnt_destroy() " Link "clnt_destroy()"} 
 @{" clnt_create() " Link "clnt_create()"} 
 @{" clnt_control() " Link "clnt_control()"} 
 @{" clnt_freeres() " Link "clnt_freeres()"} 
 @{" clnt_geterr() " Link "clnt_geterr()"} 
 @{" clnt_pcreateerror() " Link "clnt_pcreateerror()"} 
 @{" clnt_perrno() " Link "clnt_perrno()"} 
 @{" clnt_perror() " Link "clnt_perror()"} 
 @{" clnt_spcreateerror() " Link "clnt_spcreateerror()"} 
 @{" clnt_sperrno() " Link "clnt_sperrno()"} 
 @{" clnt_sperror() " Link "clnt_sperror()"} 
 @{" clntraw_create() " Link "clntraw_create()"} 
 @{" clnttcp_create() " Link "clnttcp_create()"} 
 @{" clntudp_create() " Link "clntudp_create()"} 
 @{" clntudp_bufcreate() " Link "clntudp_bufcreate()"} 
 @{" get_myaddress() " Link "get_myaddress()"} 
 @{" pmap_getmaps() " Link "pmap_getmaps()"} 
 @{" pmap_getport() " Link "pmap_getport()"} 
 @{" pmap_rmtcall() " Link "pmap_rmtcall()"} 
 @{" pmap_set() " Link "pmap_set()"} 
 @{" pmap_unset() " Link "pmap_unset()"} 
 @{" registerrpc() " Link "registerrpc()"} 
 @{" rpc_createerr " Link "rpc_createerr"} 
 @{" svc_destroy() " Link "svc_destroy()"} 
 @{" svc_fdset " Link "svc_fdset"} 
 @{" svc_fds " Link "svc_fds"} 
 @{" svc_freeargs() " Link "svc_freeargs()"} 
 @{" svc_getargs() " Link "svc_getargs()"} 
 @{" svc_getcaller() " Link "svc_getcaller()"} 
 @{" svc_getreqset() " Link "svc_getreqset()"} 
 @{" svc_getreq() " Link "svc_getreq()"} 
 @{" svc_register() " Link "svc_register()"} 
 @{" svc_run() " Link "svc_run()"} 
 @{" svc_sendreply() " Link "svc_sendreply()"} 
 @{" svc_unregister() " Link "svc_unregister()"} 
 @{" svcerr_auth() " Link "svcerr_auth()"} 
 @{" svcerr_decode() " Link "svcerr_decode()"} 
 @{" svcerr_noproc() " Link "svcerr_noproc()"} 
 @{" svcerr_noprog() " Link "svcerr_noprog()"} 
 @{" svcerr_progvers() " Link "svcerr_progvers()"} 
 @{" svcerr_systemerr() " Link "svcerr_systemerr()"} 
 @{" svcerr_weakauth() " Link "svcerr_weakauth()"} 
 @{" svcraw_create() " Link "svcraw_create()"} 
 @{" svctcp_create() " Link "svctcp_create()"} 
 @{" svcfd_create() " Link "svcfd_create()"} 
 @{" svcudp_bufcreate() " Link "svcudp_bufcreate()"} 
 @{" svcudp_create() " Link "svcudp_create()"} 
 @{" xdr_accepted_reply() " Link "xdr_accepted_reply()"} 
 @{" xdr_authunix_parms() " Link "xdr_authunix_parms()"} 
 @{" xdr_callhdr() " Link "xdr_callhdr()"} 
 @{" xdr_callmsg() " Link "xdr_callmsg()"} 
 @{" xdr_opaque_auth() " Link "xdr_opaque_auth()"} 
 @{" xdr_pmap() " Link "xdr_pmap()"} 
 @{" xdr_pmaplist() " Link "xdr_pmaplist()"} 
 @{" xdr_rejected_reply() " Link "xdr_rejected_reply()"} 
 @{" xdr_replymsg() " Link "xdr_replymsg()"} 
 @{" xprt_register() " Link "xprt_register()"} 
 @{" xprt_unregister() " Link "xprt_unregister()"} 


@EndNode

@Node "auth_destroy()" "RPC.guide/auth_destroy()"
@Next "authnone_create()"
@Toc "RPC Function Reference"

auth_destroy()
--------------

     void
     auth_destroy(auth)
     AUTH *auth;

A macro that destroys the authentication information associated with
`auth'.  Destruction usually involves deallocation of private data
structures. The use of `auth' is undefined after calling
`auth_destroy()'.


@EndNode

@Node "authnone_create()" "RPC.guide/authnone_create()"
@Next "authunix_create()"
@Prev "auth_destroy()"
@Toc "RPC Function Reference"

authnone_create()
-----------------

     AUTH *
     authnone_create()

Create and returns an `RPC' authentication handle that passes nonusable
authentication information with each remote procedure call. This is the
default authentication used by `RPC.'


@EndNode

@Node "authunix_create()" "RPC.guide/authunix_create()"
@Next "authunix_create_default()"
@Prev "authnone_create()"
@Toc "RPC Function Reference"

authunix_create()
-----------------

     AUTH *
     authunix_create(host, uid, gid, len, aup_gids)
     char *host;
     int uid, gid, len, *aup_gids;

Create and return an `RPC' authentication handle  that contains Unix
authentication information.  The parameter `host' is the name of the
machine on which the information was created; `uid' is the user's user
`ID'; `gid' is the user's current group `ID'; `len' and `aup_gids'
refer to a counted array of groups to which the user belongs.  It is
easy to impersonate a user.


@EndNode

@Node "authunix_create_default()" "RPC.guide/authunix_create_default()"
@Next "callrpc()"
@Prev "authunix_create()"
@Toc "RPC Function Reference"

authunix_create_default()
-------------------------

     AUTH *
     authunix_create_default()

Calls @{"authunix_create()" Link "authunix_create()"} with the appropriate parameters.


@EndNode

@Node "callrpc()" "RPC.guide/callrpc()"
@Next "clnt_broadcast()"
@Prev "authunix_create_default()"
@Toc "RPC Function Reference"

callrpc()
---------

     int
     callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
     char *host;
     u_long prognum, versnum, procnum;
     char *in, *out;
     xdrproc_t inproc, outproc;

Call the remote procedure associated with `prognum', `versnum', and
`procnum' on the machine, `host'.  The parameter `in' is the address of
the procedure's argument(s), and `out' is the address of where to place
the result(s); `inproc' is used to encode the procedure's parameters,
and `outproc' is used to decode the procedure's results.  This routine
returns zero if it succeeds, or the value of `enum clnt_stat' cast to
an integer if it fails.  The routine @{"clnt_perrno()" Link "clnt_perrno()"} is handy for
translating failure statuses into messages.

   *Warning:* calling remote procedures with this routine uses `UDP/IP'
as a transport; see @{"clntudp_create()" Link "clntudp_create()"} for restrictions.  You do not have
control of timeouts or authentication using this routine.


@EndNode

@Node "clnt_broadcast()" "RPC.guide/clnt_broadcast()"
@Next "clnt_call()"
@Prev "callrpc()"
@Toc "RPC Function Reference"

clnt_broadcast()
----------------

     enum clnt_stat
     clnt_broadcast(prognum, versnum, procnum, inproc, in, outproc, out, eachresult)
     u_long prognum, versnum, procnum;
     char *in, *out;
     xdrproc_t inproc, outproc;
     resultproc_t eachresult;

Like @{"callrpc()" Link "callrpc()"}, except the call message is broadcast to all locally
connected broadcast nets. Each time it receives a response, this
routine calls `eachresult()', whose form is:

     int
     eachresult(out, addr)
     char *out;
     struct sockaddr_in *addr;

where `out' is the same as `out' passed to `clnt_broadcast()', except
that the remote procedure's output is decoded there; `addr' points to
the address of the machine that sent the results.  If `eachresult()'
returns zero, `clnt_broadcast()' waits for more replies; otherwise it
returns with appropriate status.

   *Warning:* broadcast sockets are limited in size to the maximum
transfer unit of the data link. For ethernet, this value is 1500 bytes.


@EndNode

@Node "clnt_call()" "RPC.guide/clnt_call()"
@Next "clnt_destroy()"
@Prev "clnt_broadcast()"
@Toc "RPC Function Reference"

clnt_call()
-----------

     enum clnt_stat
     clnt_call(clnt, procnum, inproc, in, outproc, out, tout)
     CLIENT *clnt;
     u_long procnum;
     xdrproc_t inproc, outproc;
     char *in, *out;
     struct timeval tout;

A macro that calls the remote procedure `procnum'  associated with the
client handle, `clnt', which is obtained with an `RPC' client creation
routine such as @{"clnt_create()" Link "clnt_create()"}.  The parameter `in' is the address of
the procedure's argument(s), and `out' is the address of where to place
the result(s); `inproc' is used to encode the procedure's parameters,
and `outproc' is used to decode the procedure's results; `tout' is the
time allowed for results to come back.


@EndNode

@Node "clnt_destroy()" "RPC.guide/clnt_destroy()"
@Next "clnt_create()"
@Prev "clnt_call()"
@Toc "RPC Function Reference"

clnt_destroy()
--------------

     void
     clnt_destroy(clnt)
     CLIENT *clnt;

A macro that destroys the client's `RPC' handle.  Destruction usually
involves deallocation of private data structures, including `clnt'
itself.  Use of `clnt' is undefined after calling `clnt_destroy()'.  If
the `RPC' library opened the associated socket, it will close it also.
Otherwise, the socket remains open.


@EndNode

@Node "clnt_create()" "RPC.guide/clnt_create()"
@Next "clnt_control()"
@Prev "clnt_destroy()"
@Toc "RPC Function Reference"

clnt_create()
-------------

     CLIENT *
     clnt_create(host, prog, vers, proto)
     char *host;
     u_long prog, vers;
     char *proto;

Generic client creation routine. `host' identifies the name of the
remote host where the server is located.  `proto' indicates which kind
of transport protocol to use. The currently supported values for this
field are `"udp"' and `"tcp"'.  Default timeouts are set, but can be
modified using @{"clnt_control()" Link "clnt_control()"}.

   *Warning:* Using `UDP' has its shortcomings.  Since `UDP'-based
`RPC' messages can only hold up to 8 Kbytes of encoded data, this
transport cannot be used for procedures that take large arguments or
return huge results.


@EndNode

@Node "clnt_control()" "RPC.guide/clnt_control()"
@Next "clnt_freeres()"
@Prev "clnt_create()"
@Toc "RPC Function Reference"

clnt_control()
--------------

     bool_t
     clnt_control(cl, req, info)
     CLIENT *cl;
     char *info;

A macro used to change or retrieve various information about a client
object.  `req' indicates the type of operation, and `info' is a pointer
to the information. For both `UDP' and `TCP', the supported values of
`req' and their argument types and what they do are:

     CLSET_TIMEOUT        struct timeval      set total timeout
     CLGET_TIMEOUT        struct timeval      get total timeout

   *Note:* if you set the timeout using `clnt_control()', the timeout
parameter passed to @{"clnt_call()" Link "clnt_call()"} will be ignored in all future calls.

     CLGET_SERVER_ADDR    struct sockaddr_in  get server's address

   The following operations are valid for `UDP' only:

     CLSET_RETRY_TIMEOUT  struct timeval      set the retry timeout
     CLGET_RETRY_TIMEOUT  struct timeval      get the retry timeout

   The retry timeout is the time that `UDP RPC' waits for the server to
reply before retransmitting the request.


@EndNode

@Node "clnt_freeres()" "RPC.guide/clnt_freeres()"
@Next "clnt_geterr()"
@Prev "clnt_control()"
@Toc "RPC Function Reference"

clnt_freeres()
--------------

     bool_t
     clnt_freeres(clnt, outproc, out)
     CLIENT *clnt;
     xdrproc_t outproc;
     char *out;

A macro that frees any data allocated by the `RPC/XDR' system when it
decoded the results of an `RPC' call.  The parameter `out' is the
address of the results, and `outproc' is the `XDR' routine describing
the results.  This routine returns one if the results were successfully
freed, and zero otherwise.


@EndNode

@Node "clnt_geterr()" "RPC.guide/clnt_geterr()"
@Next "clnt_pcreateerror()"
@Prev "clnt_freeres()"
@Toc "RPC Function Reference"

clnt_geterr()
-------------

     void
     clnt_geterr(clnt, errp)
     CLIENT *clnt;
     struct rpc_err *errp;

A macro that copies the error structure out of the client handle to the
structure at address `errp'.


@EndNode

@Node "clnt_pcreateerror()" "RPC.guide/clnt_pcreateerror()"
@Next "clnt_perrno()"
@Prev "clnt_geterr()"
@Toc "RPC Function Reference"

clnt_pcreateerror()
-------------------

     void
     clnt_pcreateerror(s)
     char *s;

Print a message to standard error indicating why a client `RPC' handle
could not be created.  The message is prepended with string `s' and a
colon.  Used when a @{"clnt_create()" Link "clnt_create()"}, @{"clntraw_create()" Link "clntraw_create()"}, @{"clnttcp_create()" Link "clnttcp_create()"},
or @{"clntudp_create()" Link "clntudp_create()"} call fails.


@EndNode

@Node "clnt_perrno()" "RPC.guide/clnt_perrno()"
@Next "clnt_perror()"
@Prev "clnt_pcreateerror()"
@Toc "RPC Function Reference"

clnt_perrno()
-------------

     void
     clnt_perrno(stat)
     enum clnt_stat stat;

Print a message to standard error corresponding to the condition
indicated by `stat'.  Used after @{"callrpc()" Link "callrpc()"}.


@EndNode

@Node "clnt_perror()" "RPC.guide/clnt_perror()"
@Next "clnt_spcreateerror()"
@Prev "clnt_perrno()"
@Toc "RPC Function Reference"

clnt_perror()
-------------

     void
     clnt_perror(clnt, s)
     CLIENT *clnt;
     char *s;

Print a message to standard error indicating why an `RPC' call failed;
`clnt' is the handle used to do the call.  The message is prepended
with string `s' and a colon.  Used after @{"clnt_call()" Link "clnt_call()"}.


@EndNode

@Node "clnt_spcreateerror()" "RPC.guide/clnt_spcreateerror()"
@Next "clnt_sperrno()"
@Prev "clnt_perror()"
@Toc "RPC Function Reference"

clnt_spcreateerror()
--------------------

     char *
     clnt_spcreateerror(s)
     char *s;

Like @{"clnt_pcreateerror()" Link "clnt_pcreateerror()"}, except that it returns a string instead of
printing to the standard error.

   *Bugs:* returns pointer to static data that is overwritten on each
call.


@EndNode

@Node "clnt_sperrno()" "RPC.guide/clnt_sperrno()"
@Next "clnt_sperror()"
@Prev "clnt_spcreateerror()"
@Toc "RPC Function Reference"

clnt_sperrno()
--------------

     char *
     clnt_sperrno(stat)
     enum clnt_stat stat;

Take the same arguments as @{"clnt_perrno()" Link "clnt_perrno()"}, but instead of sending a
message to the standard error indicating why an `RPC' call failed,
return a pointer to a string which contains the message.  The string
ends with a `'\n''.  `clnt_sperrno()' is used instead of @{"clnt_perrno()" Link "clnt_perrno()"}
if the program does not have a standard error (as a program running as a
server quite likely does not), or if the programmer does not want the
message to be output with `printf', or if a message format different
than that supported by @{"clnt_perrno()" Link "clnt_perrno()"} is to be used.

   *Note:* unlike @{"clnt_sperror()" Link "clnt_sperror()"} and @{"clnt_spcreateerror()" Link "clnt_spcreateerror()"},
`clnt_sperrno()' returns pointer to static data, but the result will
not get overwritten on each call.


@EndNode

@Node "clnt_sperror()" "RPC.guide/clnt_sperror()"
@Next "clntraw_create()"
@Prev "clnt_sperrno()"
@Toc "RPC Function Reference"

clnt_sperror()
--------------

     char *
     clnt_sperror(rpch, s)
     CLIENT *rpch;
     char *s;

Like @{"clnt_perror()" Link "clnt_perror()"}, except that (like @{"clnt_sperrno()" Link "clnt_sperrno()"}) it returns a
string instead of printing to standard error.

   *Bugs:* returns pointer to static data that is overwritten on each
call.


@EndNode

@Node "clntraw_create()" "RPC.guide/clntraw_create()"
@Next "clnttcp_create()"
@Prev "clnt_sperror()"
@Toc "RPC Function Reference"

clntraw_create()
----------------

     CLIENT *
     clntraw_create(prognum, versnum)
     u_long prognum, versnum;

This routine creates a toy `RPC' client for the  remote program
`prognum', version `versnum'.  The transport used to pass messages to
the service is actually a buffer within the process's address space, so
the corresponding `RPC' server should live in the same address space;
see @{"svcraw_create()" Link "svcraw_create()"}.  This allows simulation of `RPC' and acquisition
of `RPC' overheads, such as round trip times, without any kernel
interference. This routine returns `NULL' if it fails.


@EndNode

@Node "clnttcp_create()" "RPC.guide/clnttcp_create()"
@Next "clntudp_create()"
@Prev "clntraw_create()"
@Toc "RPC Function Reference"

clnttcp_create()
----------------

     CLIENT *
     clnttcp_create(addr, prognum, versnum, sockp, sendsz, recvsz)
     struct sockaddr_in *addr;
     u_long prognum, versnum;
     int *sockp;
     u_int sendsz, recvsz;

This routine creates an `RPC' client for the remote  program `prognum',
version `versnum'; the client uses `TCP/IP' as a transport. The remote
program is located at Internet address `*addr'.  If `addr->sin_port' is
zero, then it is set to the actual port that the remote program is
listening on (the remote `portmap' service is consulted for this
information). The parameter `sockp' is a socket; if it is
`RPC_ANYSOCK', then this routine opens a new one and sets `sockp'.
Since `TCP'-based `RPC' uses buffered `I/O', the user may specify the
size of the send and receive buffers with the parameters `sendsz' and
`recvsz'; values of zero choose suitable defaults.  This routine
returns `NULL' if it fails.


@EndNode

@Node "clntudp_create()" "RPC.guide/clntudp_create()"
@Next "clntudp_bufcreate()"
@Prev "clnttcp_create()"
@Toc "RPC Function Reference"

clntudp_create()
----------------

     CLIENT *
     clntudp_create(addr, prognum, versnum, wait, sockp)
     struct sockaddr_in *addr;
     u_long prognum, versnum;
     struct timeval wait;
     int *sockp;

This routine creates an `RPC' client for the remote program `prognum',
version `versnum'; the client uses use `UDP/IP' as a transport. The
remote program is located at Internet address `addr'.  If
`addr->sin_port' is zero, then it is set to actual port that the remote
program is listening on (the remote `portmap' service is consulted for
this information). The parameter `sockp' is a socket; if it is
`RPC_ANYSOCK', then this routine opens a new one and sets `sockp'.  The
`UDP' transport resends the call message in intervals of `wait' time
until a response is received or until the call times out.  The total
time for the call to time out is specified by @{"clnt_call()" Link "clnt_call()"}.

   *Warning:* since `UDP'-based `RPC' messages can only hold up to 8
Kbytes of encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.


@EndNode

@Node "clntudp_bufcreate()" "RPC.guide/clntudp_bufcreate()"
@Next "get_myaddress()"
@Prev "clntudp_create()"
@Toc "RPC Function Reference"

clntudp_bufcreate()
-------------------

     CLIENT *
     clntudp_bufcreate(addr, prognum, versnum, wait, sockp, sendsize, recosize)
     struct sockaddr_in *addr;
     u_long prognum, versnum;
     struct timeval wait;
     int *sockp;
     unsigned int sendsize;
     unsigned int recosize;

This routine creates an `RPC' client for the remote program `prognum',
on `versnum'; the client uses use `UDP/IP' as a transport. The remote
program is located at Internet address `addr'.  If `addr->sin_port' is
zero, then it is set to actual port that the remote program is
listening on (the remote `portmap' service is consulted for this
information). The parameter `sockp' is a socket; if it is
`RPC_ANYSOCK', then this routine opens a new one and sets `sockp'.  The
`UDP' transport resends the call message in intervals of `wait' time
until a response is received or until the call times out.  The total
time for the call to time out is specified by @{"clnt_call()" Link "clnt_call()"}.  This allows
the user to specify the maximun packet size for sending and receiving
`UDP-based' `RPC' messages.


@EndNode

@Node "get_myaddress()" "RPC.guide/get_myaddress()"
@Next "pmap_getmaps()"
@Prev "clntudp_bufcreate()"
@Toc "RPC Function Reference"

get_myaddress()
---------------

     void
     get_myaddress(addr)
     struct sockaddr_in *addr;

Stuff the machine's `IP' address into `*addr', without consulting the
library routines that deal with host database or name service.  The
port number is always set to `htons(PMAPPORT)'.


@EndNode

@Node "pmap_getmaps()" "RPC.guide/pmap_getmaps()"
@Next "pmap_getport()"
@Prev "get_myaddress()"
@Toc "RPC Function Reference"

pmap_getmaps()
--------------

     struct pmaplist *
     pmap_getmaps(addr)
     struct sockaddr_in *addr;

A user interface to the `portmap' service, which returns a list of the
current `RPC' program-to-port mappings on the host located at `IP'
address `*addr'.  This routine can return `NULL'.  The command @{"portmap" Link "portmap and rpcinfo"}
uses this routine.


@EndNode

@Node "pmap_getport()" "RPC.guide/pmap_getport()"
@Next "pmap_rmtcall()"
@Prev "pmap_getmaps()"
@Toc "RPC Function Reference"

pmap_getport()
--------------

     u_short
     pmap_getport(addr, prognum, versnum, protocol)
     struct sockaddr_in *addr;
     u_long prognum, versnum, protocol;

A user interface to the `portmap' service, which  returns the port
number on which waits a service that supports program number `prognum',
version `versnum', and speaks the transport protocol associated with
`protocol'.  The value of `protocol' is most likely `IPPROTO_UDP' or
`IPPROTO_TCP'.  A return value of zero means that the mapping does not
exist or that the `RPC' system failured to contact the remote `portmap'
service.  In the latter case, the global variable @{"rpc_createerr" Link "rpc_createerr"}
contains the `RPC' status.


@EndNode

@Node "pmap_rmtcall()" "RPC.guide/pmap_rmtcall()"
@Next "pmap_set()"
@Prev "pmap_getport()"
@Toc "RPC Function Reference"

pmap_rmtcall()
--------------

     enum clnt_stat
     pmap_rmtcall(addr, prognum, versnum, procnum,
                  inproc, in, outproc, out, tout, portp)
     struct sockaddr_in *addr;
     u_long prognum, versnum, procnum;
     char *in, *out;
     xdrproc_t inproc, outproc;
     struct timeval tout;
     u_long *portp;

A user interface to the `portmap' service, which instructs `portmap' on
the host at `IP' address `*addr' to make an `RPC' call on your behalf
to a procedure on that host.  The parameter `*portp' will be modified
to the program's port number if the procedure succeeds. The definitions
of other parameters are discussed in @{"callrpc()" Link "callrpc()"} and @{"clnt_call()" Link "clnt_call()"}.  This
procedure should be used for a "ping" and nothing else.  See also
@{"clnt_broadcast()" Link "clnt_broadcast()"}.


@EndNode

@Node "pmap_set()" "RPC.guide/pmap_set()"
@Next "pmap_unset()"
@Prev "pmap_rmtcall()"
@Toc "RPC Function Reference"

pmap_set()
----------

     bool_t
     pmap_set(prognum, versnum, protocol, port)
     u_long prognum, versnum, protocol;
     u_short port;

A user interface to the `portmap' service, which establishes a mapping
between the triple [prognum,versnum,protocol] and `port' on the
machine's `portmap' service. The value of `protocol' is most likely
`IPPROTO_UDP' or `IPPROTO_TCP'.  This routine returns one if it
succeeds, zero otherwise.  Automatically done by @{"svc_register()" Link "svc_register()"}.


@EndNode

@Node "pmap_unset()" "RPC.guide/pmap_unset()"
@Next "registerrpc()"
@Prev "pmap_set()"
@Toc "RPC Function Reference"

pmap_unset()
------------

     bool_t
     pmap_unset(prognum, versnum)
     u_long prognum, versnum;

A user interface to the `portmap' service, which destroys all mapping
between the triple [prognum,versnum,*] and `ports' on the machine's
`portmap' service. This routine returns one if it succeeds, zero
otherwise.


@EndNode

@Node "registerrpc()" "RPC.guide/registerrpc()"
@Next "rpc_createerr"
@Prev "pmap_unset()"
@Toc "RPC Function Reference"

registerrpc()
-------------

     int
     registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
     u_long prognum, versnum, procnum;
     char *(*procname) () ;
     xdrproc_t inproc, outproc;

Register procedure `procname' with the `RPC' service package.  If a
request arrives for program `prognum', version `versnum', and procedure
`procnum', `procname' is called with a pointer to its parameter(s);
`progname' should return a pointer to its static result(s); `inproc' is
used to decode the parameters while `outproc' is used to encode the
results.  This routine returns zero if the registration succeeded, -1
otherwise.

   *Warning:* remote procedures registered in this form are accessed
using the `UDP/IP' transport; see @{"svcudp_create()" Link "svcudp_create()"} for restrictions.


@EndNode

@Node "rpc_createerr" "RPC.guide/rpc_createerr"
@Next "svc_destroy()"
@Prev "registerrpc()"
@Toc "RPC Function Reference"

rpc_createerr
-------------

     struct rpc_createerr     rpc_createerr;

A global variable whose value is set by any `RPC' client creation
routine that does not succeed.  Use the routine @{"clnt_pcreateerror()" Link "clnt_pcreateerror()"} to
print the reason why.


@EndNode

@Node "svc_destroy()" "RPC.guide/svc_destroy()"
@Next "svc_fdset"
@Prev "rpc_createerr"
@Toc "RPC Function Reference"

svc_destroy()
-------------

     void
     svc_destroy(xprt)
     SVCXPRT *xprt;

A macro that destroys the `RPC' service transport handle, `xprt'.
Destruction usually involves deallocation of private data structures,
including `xprt' itself.  Use of `xprt' is undefined after calling this
routine.


@EndNode

@Node "svc_fdset" "RPC.guide/svc_fdset"
@Next "svc_fds"
@Prev "svc_destroy()"
@Toc "RPC Function Reference"

svc_fdset
---------

     fd_set svc_fdset;

A global variable reflecting the `RPC' service side's read file
descriptor bit mask; it is suitable as a parameter to the `select'
system call. This is only of interest if a service implementor does not
call @{"svc_run()" Link "svc_run()"}, but rather does his own asynchronous event processing.
This variable is read-only (do not pass its address to `select'!), yet
it may change after calls to @{"svc_getreqset()" Link "svc_getreqset()"} or any creation routines.


@EndNode

@Node "svc_fds" "RPC.guide/svc_fds"
@Next "svc_freeargs()"
@Prev "svc_fdset"
@Toc "RPC Function Reference"

svc_fds
-------

     int svc_fds;

Similar to @{"svc_fdset" Link "svc_fdset"}, but limited to 32 descriptors. This interface is
obsoleted by @{"svc_fdset" Link "svc_fdset"}.


@EndNode

@Node "svc_freeargs()" "RPC.guide/svc_freeargs()"
@Next "svc_getargs()"
@Prev "svc_fds"
@Toc "RPC Function Reference"

svc_freeargs()
--------------

     bool_t
     svc_freeargs(xprt, inproc, in)
     SVCXPRT *xprt;
     xdrproc_t inproc;
     char *in;

A macro that frees any data allocated by the `RPC/XDR' system when it
decoded the arguments to a service procedure using @{"svc_getargs()" Link "svc_getargs()"}.  This
routine returns 1 if the results were successfully freed, and zero
otherwise.


@EndNode

@Node "svc_getargs()" "RPC.guide/svc_getargs()"
@Next "svc_getcaller()"
@Prev "svc_freeargs()"
@Toc "RPC Function Reference"

svc_getargs()
-------------

     bool_t
     svc_getargs(xprt, inproc, in)
     SVCXPRT *xprt;
     xdrproc_t inproc;
     char *in;

A macro that decodes the arguments of an `RPC' request associated with
the `RPC' service transport handle, `xprt'.  The parameter `in' is the
address where the arguments will be placed; `inproc' is the `XDR'
routine used to decode the arguments.  This routine returns one if
decoding succeeds, and zero otherwise.


@EndNode

@Node "svc_getcaller()" "RPC.guide/svc_getcaller()"
@Next "svc_getreqset()"
@Prev "svc_getargs()"
@Toc "RPC Function Reference"

svc_getcaller()
---------------

     struct sockaddr_in *
     svc_getcaller(xprt)
     SVCXPRT *xprt;

The approved way of getting the network address of the caller of a
procedure associated with the `RPC' service transport handle, `xprt'.


@EndNode

@Node "svc_getreqset()" "RPC.guide/svc_getreqset()"
@Next "svc_getreq()"
@Prev "svc_getcaller()"
@Toc "RPC Function Reference"

svc_getreqset()
---------------

     void
     svc_getreqset(rdfds)
     fd_set *rdfds;

This routine is only of interest if a service implementor does not call
@{"svc_run()" Link "svc_run()"}, but instead implements custom asynchronous event processing.
It is called when the `select()' system call has determined that an
`RPC' request has arrived on some `RPC' `socket(s)'; `rdfds' is the
resultant read file descriptor bit mask.  The routine returns when all
sockets associated with the value of `rdfds' have been serviced.


@EndNode

@Node "svc_getreq()" "RPC.guide/svc_getreq()"
@Next "svc_register()"
@Prev "svc_getreqset()"
@Toc "RPC Function Reference"

svc_getreq()
------------

     void
     svc_getreq(rdfds)
     int rdfds;

Similar to @{"svc_getreqset()" Link "svc_getreqset()"}, but limited to 32 descriptors. This
interface is obsoleted by @{"svc_getreqset()" Link "svc_getreqset()"}.


@EndNode

@Node "svc_register()" "RPC.guide/svc_register()"
@Next "svc_run()"
@Prev "svc_getreq()"
@Toc "RPC Function Reference"

svc_register()
--------------

     bool_t
     svc_register(xprt, prognum, versnum, dispatch, protocol)
     SVCXPRT *xprt;
     u_long prognum, versnum;
     void (*dispatch) ();
     u_long protocol;

Associates `prognum' and `versnum' with the service  dispatch
procedure, `dispatch'.  If `protocol' is zero, the service is not
registered with the `portmap' service.  If `protocol' is non-zero, then
a mapping of the triple [prognum,versnum,protocol] to `xprt->xp_port'
is established with the local `portmap' service (generally `protocol'
is zero, `IPPROTO_UDP' or `IPPROTO_TCP').  The procedure `dispatch' has
the following form:

     void
     dispatch(request, xprt)
     struct svc_req *request;
     SVCXPRT *xprt;

The `svc_register()' routine returns one if it succeeds, and zero
otherwise.


@EndNode

@Node "svc_run()" "RPC.guide/svc_run()"
@Next "svc_sendreply()"
@Prev "svc_register()"
@Toc "RPC Function Reference"

svc_run()
---------

     void
     svc_run()

This routine never returns. It waits for `RPC' requests to arrive, and
calls the appropriate service procedure using @{"svc_getreqset()" Link "svc_getreqset()"} when one
arrives. This procedure is usually waiting for a `select()' system call
to return.


@EndNode

@Node "svc_sendreply()" "RPC.guide/svc_sendreply()"
@Next "svc_unregister()"
@Prev "svc_run()"
@Toc "RPC Function Reference"

svc_sendreply()
---------------

     bool_t
     svc_sendreply(xprt, outproc, out)
     SVCXPRT *xprt;
     xdrproc_t outproc;
     char *out;

Called by an `RPC' service's dispatch routine to send the results of a
remote procedure call.  The parameter `xprt' is the request's
associated transport handle; `outproc' is the `XDR' routine which is
used to encode the results; and `out' is the address of the results.
This routine returns one if it succeeds, zero otherwise.


@EndNode

@Node "svc_unregister()" "RPC.guide/svc_unregister()"
@Next "svcerr_auth()"
@Prev "svc_sendreply()"
@Toc "RPC Function Reference"

svc_unregister()
----------------

     void
     svc_unregister(prognum, versnum)
     u_long prognum, versnum;

Remove all mapping of the double [prognum,versnum] to dispatch
routines, and of the triple [prognum,versnum,*] to port number.


@EndNode

@Node "svcerr_auth()" "RPC.guide/svcerr_auth()"
@Next "svcerr_decode()"
@Prev "svc_unregister()"
@Toc "RPC Function Reference"

svcerr_auth()
-------------

     void
     svcerr_auth(xprt, why)
     SVCXPRT *xprt;
     enum auth_stat why;

Called by a service dispatch routine that refuses to perform a remote
procedure call due to an authentication error.


@EndNode

@Node "svcerr_decode()" "RPC.guide/svcerr_decode()"
@Next "svcerr_noproc()"
@Prev "svcerr_auth()"
@Toc "RPC Function Reference"

svcerr_decode()
---------------

     void
     svcerr_decode(xprt)
     SVCXPRT *xprt;

Called by a service dispatch routine that cannot successfully decode
its parameters. Also See @{"svc_getargs()" Link "svc_getargs()"}.


@EndNode

@Node "svcerr_noproc()" "RPC.guide/svcerr_noproc()"
@Next "svcerr_noprog()"
@Prev "svcerr_decode()"
@Toc "RPC Function Reference"

svcerr_noproc()
---------------

     void
     svcerr_noproc(xprt)
     SVCXPRT *xprt;

Called by a service dispatch routine that does not implement the
procedure number that the caller requests.


@EndNode

@Node "svcerr_noprog()" "RPC.guide/svcerr_noprog()"
@Next "svcerr_progvers()"
@Prev "svcerr_noproc()"
@Toc "RPC Function Reference"

svcerr_noprog()
---------------

     void
     svcerr_noprog(xprt)
     SVCXPRT *xprt;

Called when the desired program is not registered with the `RPC'
package. Service implementors usually do not need this routine.


@EndNode

@Node "svcerr_progvers()" "RPC.guide/svcerr_progvers()"
@Next "svcerr_systemerr()"
@Prev "svcerr_noprog()"
@Toc "RPC Function Reference"

svcerr_progvers()
-----------------

     void
     svcerr_progvers(xprt)
     SVCXPRT *xprt;

Called when the desired version of a program is not registered with the
`RPC' package. Service implementors usually do not need this routine.


@EndNode

@Node "svcerr_systemerr()" "RPC.guide/svcerr_systemerr()"
@Next "svcerr_weakauth()"
@Prev "svcerr_progvers()"
@Toc "RPC Function Reference"

svcerr_systemerr()
------------------

     void
     svcerr_systemerr(xprt)
     SVCXPRT *xprt;

Called by a service dispatch routine when it detects a system error not
covered by any particular protocol.  For example, if a service can no
longer allocate storage, it may call this routine.


@EndNode

@Node "svcerr_weakauth()" "RPC.guide/svcerr_weakauth()"
@Next "svcraw_create()"
@Prev "svcerr_systemerr()"
@Toc "RPC Function Reference"

svcerr_weakauth()
-----------------

     void
     svcerr_weakauth(xprt)
     SVCXPRT *xprt;

Called by a service dispatch routine that refuses to perform a remote
procedure call due to insufficient authentication parameters.  The
routine calls `svcerr_auth(xprt, AUTH_TOOWEAK)'.


@EndNode

@Node "svcraw_create()" "RPC.guide/svcraw_create()"
@Next "svctcp_create()"
@Prev "svcerr_weakauth()"
@Toc "RPC Function Reference"

svcraw_create()
---------------

     SVCXPRT *
     svcraw_create()

This routine creates a toy `RPC' service transport, to which it returns
a pointer.  The transport is really a buffer within the process's
address space, so the corresponding `RPC' client should live in the
same address space; see @{"clntraw_create()" Link "clntraw_create()"}.  This routine allows
simulation of `RPC' and acquisition of `RPC' overheads (such as round
trip times), without any kernel interference.  This routine returns
`NULL' if it fails.


@EndNode

@Node "svctcp_create()" "RPC.guide/svctcp_create()"
@Next "svcfd_create()"
@Prev "svcraw_create()"
@Toc "RPC Function Reference"

svctcp_create()
---------------

     SVCXPRT *
     svctcp_create(sock, send_buf_size, recv_buf_size)
     int sock;
     u_int send_buf_size, recv_buf_size;

This routine creates a `TCP/IP'-based `RPC' service transport, to which
it returns a pointer.  The transport is associated with the socket
`sock', which may be `RPC_ANYSOCK', in which case a new socket is
created.  If the socket is not bound to a local `TCP' port, then this
routine binds it to an arbitrary port.  Upon completion,
`xprt->xp_sock' is the transport's socket descriptor, and
`xprt->xp_port' is the transport's port number.  This routine returns
`NULL' if it fails. Since `TCP'-based `RPC' uses buffered `I/O', users
may specify the size of buffers; values of zero choose suitable
defaults.


@EndNode

@Node "svcfd_create()" "RPC.guide/svcfd_create()"
@Next "svcudp_bufcreate()"
@Prev "svctcp_create()"
@Toc "RPC Function Reference"

svcfd_create()
--------------

     SVCXPRT *
     svcfd_create(fd, sendsize, recvsize)
     int fd;
     u_int sendsize;
     u_int recvsize;

Create a service on top of any open descriptor. Typically, this
descriptor is a connected socket for a stream protocol such as `TCP.'
`sendsize' and `recvsize' indicate sizes for the send and receive
buffers.  If they are zero, a reasonable default is chosen.


@EndNode

@Node "svcudp_bufcreate()" "RPC.guide/svcudp_bufcreate()"
@Next "svcudp_create()"
@Prev "svcfd_create()"
@Toc "RPC Function Reference"

svcudp_bufcreate()
------------------

     SVCXPRT *
     svcudp_bufcreate(sock, sendsize, recvsize)
     int sock;
     u_int sendsize, recvsize;

This routine creates a `UDP/IP'-based `RPC' service transport, to which
it returns a pointer.  The transport is associated with the socket
`sock', which may be `RPC_ANYSOCK', in which case a new socket is
created.  If the socket is not bound to a local `UDP' port, then this
routine binds it to an arbitrary port. Upon completion, `xprt->xp_sock'
is the transport's socket descriptor, and `xprt->xp_port' is the
transport's port number.  This routine returns `NULL' if it fails.
This allows the user to specify the maximun packet size for sending and
receiving `UDP'-based `RPC' messages.


@EndNode

@Node "svcudp_create()" "RPC.guide/svcudp_create()"
@Next "xdr_accepted_reply()"
@Prev "svcudp_bufcreate()"
@Toc "RPC Function Reference"

svcudp_create()
---------------

     SVCXPRT *
     svcudp_create(sock)
     int sock;

This routine creates a `UDP/IP'-based `RPC' service transport, to which
it returns a pointer.  This is done by calling the see
@{"svcudp_bufcreate()" Link "svcudp_bufcreate()"} with the default buffer size `UDPMSGSIZE'.


@EndNode

@Node "xdr_accepted_reply()" "RPC.guide/xdr_accepted_reply()"
@Next "xdr_authunix_parms()"
@Prev "svcudp_create()"
@Toc "RPC Function Reference"

xdr_accepted_reply()
--------------------

     bool_t XDRFUN
     xdr_accepted_reply(xdrs, ar)
     XDR *xdrs;
     struct accepted_reply *ar;

Used for encoding `RPC' reply messages. This routine is useful for
users who wish to generate RPC-style messages without using the `RPC'
package.


@EndNode

@Node "xdr_authunix_parms()" "RPC.guide/xdr_authunix_parms()"
@Next "xdr_callhdr()"
@Prev "xdr_accepted_reply()"
@Toc "RPC Function Reference"

xdr_authunix_parms()
--------------------

     bool_t XDRFUN
     xdr_authunix_parms(xdrs, aupp)
     XDR *xdrs;
     struct authunix_parms *aupp;

Used for describing `UNIX' credentials. This routine is useful for
users who wish to generate these credentials without using the `RPC'
authentication package.


@EndNode

@Node "xdr_callhdr()" "RPC.guide/xdr_callhdr()"
@Next "xdr_callmsg()"
@Prev "xdr_authunix_parms()"
@Toc "RPC Function Reference"

xdr_callhdr()
-------------

     void
     xdr_callhdr(xdrs, chdr)
     XDR *xdrs;
     struct rpc_msg *chdr;

Used for describing `RPC' call header messages.  This routine is useful
for users who wish to generate `RPC-style' messages without using the
`RPC' package.


@EndNode

@Node "xdr_callmsg()" "RPC.guide/xdr_callmsg()"
@Next "xdr_opaque_auth()"
@Prev "xdr_callhdr()"
@Toc "RPC Function Reference"

xdr_callmsg()
-------------

     bool_t XDRFUN
     xdr_callmsg(xdrs, cmsg)
     XDR *xdrs;
     struct rpc_msg *cmsg;

Used for describing `RPC' call messages.  This routine is useful for
users who wish to generate `RPC-style' messages without using the `RPC'
package.


@EndNode

@Node "xdr_opaque_auth()" "RPC.guide/xdr_opaque_auth()"
@Next "xdr_pmap()"
@Prev "xdr_callmsg()"
@Toc "RPC Function Reference"

xdr_opaque_auth()
-----------------

     bool_t XDRFUN
     xdr_opaque_auth(xdrs, ap)
     XDR *xdrs;
     struct opaque_auth *ap;

Used for describing `RPC' authentication information messages.  This
routine is useful for users who wish to generate `RPC-style' messages
without using the `RPC' package.


@EndNode

@Node "xdr_pmap()" "RPC.guide/xdr_pmap()"
@Next "xdr_pmaplist()"
@Prev "xdr_opaque_auth()"
@Toc "RPC Function Reference"

xdr_pmap()
----------

     bool_t XDRFUN
     xdr_pmap(xdrs, regs)
     XDR *xdrs;
     struct pmap *regs;

Used for describing parameters to various `portmap' procedures,
externally.  This routine is useful for users who wish to generate
these parameters without using the `pmap' interface.


@EndNode

@Node "xdr_pmaplist()" "RPC.guide/xdr_pmaplist()"
@Next "xdr_rejected_reply()"
@Prev "xdr_pmap()"
@Toc "RPC Function Reference"

xdr_pmaplist()
--------------

     bool_t XDRFUN
     xdr_pmaplist(xdrs, rp)
     XDR *xdrs;
     struct pmaplist **rp;

Used for describing a list of port mappings, externally.  This routine
is useful for users who wish to generate these parameters without using
the `pmap' interface.


@EndNode

@Node "xdr_rejected_reply()" "RPC.guide/xdr_rejected_reply()"
@Next "xdr_replymsg()"
@Prev "xdr_pmaplist()"
@Toc "RPC Function Reference"

xdr_rejected_reply()
--------------------

     bool_t XDRFUN
     xdr_rejected_reply(xdrs, rr)
     XDR *xdrs;
     struct rejected_reply *rr;

Used for describing `RPC' reply messages.  This routine is useful for
users who wish to generate `RPC-style' messages without using the `RPC'
package.


@EndNode

@Node "xdr_replymsg()" "RPC.guide/xdr_replymsg()"
@Next "xprt_register()"
@Prev "xdr_rejected_reply()"
@Toc "RPC Function Reference"

xdr_replymsg()
--------------

     bool_t XDRFUN
     xdr_replymsg(xdrs, rmsg)
     XDR *xdrs;
     struct rpc_msg *rmsg;

Used for describing `RPC' reply messages.  This routine is useful for
users who wish to generate `RPC' style messages without using the `RPC'
package.


@EndNode

@Node "xprt_register()" "RPC.guide/xprt_register()"
@Next "xprt_unregister()"
@Prev "xdr_replymsg()"
@Toc "RPC Function Reference"

xprt_register()
---------------

     void
     xprt_register(xprt)
     SVCXPRT *xprt;

After `RPC' service transport handles are created, they should register
themselves with the `RPC' service package.  This routine modifies the
global variable @{"svc_fds" Link "svc_fds"}.  Service implementors usually do not need this
routine.


@EndNode

@Node "xprt_unregister()" "RPC.guide/xprt_unregister()"
@Prev "xprt_register()"
@Toc "RPC Function Reference"

xprt_unregister()
-----------------

     void
     xprt_unregister(xprt)
     SVCXPRT *xprt;

Before an `RPC' service transport handle is destroyed, it should
unregister itself with the `RPC' service package.  This routine
modifies the global variable @{"svc_fds" Link "svc_fds"}.  Service implementors usually do
not need this routine.


@EndNode

@Node "XDR Function Reference" "RPC.guide/XDR Function Reference"
@Prev "RPC Function Reference"
@Toc "Manual Pages"

XDR Function Reference
======================

   These routines allow C programmers to describe arbitrary data
structures in a machine-independent fashion.  Data for remote procedure
calls are transmitted using these routines.


 @{" xdr_array() " Link "xdr_array()"} 
 @{" xdr_bool() " Link "xdr_bool()"} 
 @{" xdr_bytes() " Link "xdr_bytes()"} 
 @{" xdr_char() " Link "xdr_char()"} 
 @{" xdr_destroy() " Link "xdr_destroy()"} 
 @{" xdr_double() " Link "xdr_double()"} 
 @{" xdr_enum() " Link "xdr_enum()"} 
 @{" xdr_float() " Link "xdr_float()"} 
 @{" xdr_free() " Link "xdr_free()"} 
 @{" xdr_getpos() " Link "xdr_getpos()"} 
 @{" xdr_inline() " Link "xdr_inline()"} 
 @{" xdr_int() " Link "xdr_int()"} 
 @{" xdr_long() " Link "xdr_long()"} 
 @{" xdrmem_create() " Link "xdrmem_create()"} 
 @{" xdr_opaque() " Link "xdr_opaque()"} 
 @{" xdr_pointer() " Link "xdr_pointer()"} 
 @{" xdrrec_create() " Link "xdrrec_create()"} 
 @{" xdrrec_endofrecord() " Link "xdrrec_endofrecord()"} 
 @{" xdrrec_eof() " Link "xdrrec_eof()"} 
 @{" xdrrec_skiprecord() " Link "xdrrec_skiprecord()"} 
 @{" xdr_reference() " Link "xdr_reference()"} 
 @{" xdr_setpos() " Link "xdr_setpos()"} 
 @{" xdr_short() " Link "xdr_short()"} 
 @{" xdrstdio_create() " Link "xdrstdio_create()"} 
 @{" xdr_string() " Link "xdr_string()"} 
 @{" xdr_u_char() " Link "xdr_u_char()"} 
 @{" xdr_u_int() " Link "xdr_u_int()"} 
 @{" xdr_u_long() " Link "xdr_u_long()"} 
 @{" xdr_u_short() " Link "xdr_u_short()"} 
 @{" xdr_union() " Link "xdr_union()"} 
 @{" xdr_vector() " Link "xdr_vector()"} 
 @{" xdr_void() " Link "xdr_void()"} 
 @{" xdr_wrapstring() " Link "xdr_wrapstring()"} 


@EndNode

@Node "xdr_array()" "RPC.guide/xdr_array()"
@Next "xdr_bool()"
@Toc "XDR Function Reference"

xdr_array()
-----------

     bool_t XDRFUN
     xdr_array(xdrs, arrp, sizep, maxsize, elsize, elproc)
     XDR *xdrs;
     char **arrp;
     u_int *sizep, maxsize, elsize;
     xdrproc_t elproc;

A filter primitive that translates between variable-length arrays and
their corresponding external representations. The parameter `arrp' is
the address of the pointer to the array, while `sizep' is the address
of the element count of the array; this element count cannot exceed
`maxsize'.  The parameter `elsize' is the `sizeof' each of the array's
elements, and `elproc' is an `XDR' filter that translates between the
array elements' C form, and their external representation.  This
routine returns one if it succeeds, zero otherwise.


@EndNode

@Node "xdr_bool()" "RPC.guide/xdr_bool()"
@Next "xdr_bytes()"
@Prev "xdr_array()"
@Toc "XDR Function Reference"

xdr_bool()
----------

     bool_t XDRFUN
     xdr_bool(xdrs, bp)
     XDR *xdrs;
     bool_t *bp;

A filter primitive that translates between booleans (C integers) and
their external representations. When encoding data, this filter
produces values of either one or zero.  This routine returns one if it
succeeds, zero otherwise.


@EndNode

@Node "xdr_bytes()" "RPC.guide/xdr_bytes()"
@Next "xdr_char()"
@Prev "xdr_bool()"
@Toc "XDR Function Reference"

xdr_bytes()
-----------

     bool_t XDRFUN
     xdr_bytes(xdrs, sp, sizep, maxsize)
     XDR *xdrs;
     char **sp;
     u_int *sizep, maxsize;

A filter primitive that translates between counted byte strings and
their external representations.  The parameter `sp' is the address of
the string pointer. The length of the string is located at address
`sizep'; strings cannot be longer than `maxsize'.  This routine returns
one if it succeeds, zero otherwise.


@EndNode

@Node "xdr_char()" "RPC.guide/xdr_char()"
@Next "xdr_destroy()"
@Prev "xdr_bytes()"
@Toc "XDR Function Reference"

xdr_char()
----------

     bool_t XDRFUN
     xdr_char(xdrs, cp)
     XDR *xdrs;
     char *cp;

A filter primitive that translates between C characters and their
external representations.  This routine returns one if it succeeds,
zero otherwise.  Note: encoded characters are not packed, and occupy 4
bytes each. For arrays of characters, it is worthwhile to consider
@{"xdr_bytes()" Link "xdr_bytes()"}, @{"xdr_opaque()" Link "xdr_opaque()"} or @{"xdr_string()" Link "xdr_string()"}.


@EndNode

@Node "xdr_destroy()" "RPC.guide/xdr_destroy()"
@Next "xdr_double()"
@Prev "xdr_char()"
@Toc "XDR Function Reference"

xdr_destroy()
-------------

     void
     xdr_destroy(xdrs)
     XDR *xdrs;

A macro that invokes the destroy routine associated with the `XDR'
stream, `xdrs'.  Destruction usually involves freeing private data
structures associated with the stream.  Using `xdrs' after invoking
`xdr_destroy()' is undefined.


@EndNode

@Node "xdr_double()" "RPC.guide/xdr_double()"
@Next "xdr_enum()"
@Prev "xdr_destroy()"
@Toc "XDR Function Reference"

xdr_double()
------------

     bool_t XDRFUN
     xdr_double(xdrs, dp)
     XDR *xdrs;
     double *dp;

A filter primitive that translates between C `double' precision numbers
and their external representations.  This routine returns one if it
succeeds, zero otherwise.


@EndNode

@Node "xdr_enum()" "RPC.guide/xdr_enum()"
@Next "xdr_float()"
@Prev "xdr_double()"
@Toc "XDR Function Reference"

xdr_enum()
----------

     bool_t XDRFUN
     xdr_enum(xdrs, ep)
     XDR *xdrs;
     enum_t *ep;

A filter primitive that translates between C `enum's (actually
integers) and their external representations.  This routine returns one
if it succeeds, zero otherwise.


@EndNode

@Node "xdr_float()" "RPC.guide/xdr_float()"
@Next "xdr_free()"
@Prev "xdr_enum()"
@Toc "XDR Function Reference"

xdr_float()
-----------

     bool_t XDRFUN
     xdr_float(xdrs, fp)
     XDR *xdrs;
     float *fp;

A filter primitive that translates between C `float's and their
external representations.  This routine returns one if it succeeds,
zero otherwise.


@EndNode

@Node "xdr_free()" "RPC.guide/xdr_free()"
@Next "xdr_getpos()"
@Prev "xdr_float()"
@Toc "XDR Function Reference"

xdr_free()
----------

     void
     xdr_free(proc, objp)
     xdrproc_t proc;
     char *objp;

Generic freeing routine. The first argument is the `XDR' routine for
the object being freed. The second argument is a pointer to the object
itself. Note: the pointer passed to this routine is `not' freed, but
what it points to `is' freed (recursively).


@EndNode

@Node "xdr_getpos()" "RPC.guide/xdr_getpos()"
@Next "xdr_inline()"
@Prev "xdr_free()"
@Toc "XDR Function Reference"

xdr_getpos()
------------

     u_int
     xdr_getpos(xdrs)
     XDR *xdrs;

A macro that invokes the get-position routine associated with the `XDR'
stream, `xdrs'.  The routine returns an unsigned integer, which
indicates the position of the `XDR' byte stream.  A desirable feature
of `XDR' streams is that simple arithmetic works with this number,
although the `XDR' stream instances need not guarantee this.


@EndNode

@Node "xdr_inline()" "RPC.guide/xdr_inline()"
@Next "xdr_int()"
@Prev "xdr_getpos()"
@Toc "XDR Function Reference"

xdr_inline()
------------

     long *
     xdr_inline(xdrs, len)
     XDR *xdrs;
     int len;

A macro that invokes the in-line routine associated with the `XDR'
stream, `xdrs'.  The routine returns a pointer to a contiguous piece of
the stream's buffer; `len' is the byte length of the desired buffer.
Note: pointer is cast to `long *'.  *Warning:* `xdr_inline()' may
return `NULL' (0) if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances; it exists for
the sake of efficiency.


@EndNode

@Node "xdr_int()" "RPC.guide/xdr_int()"
@Next "xdr_long()"
@Prev "xdr_inline()"
@Toc "XDR Function Reference"

xdr_int()
---------

     bool_t XDRFUN
     xdr_int(xdrs, ip)
     XDR *xdrs;
     int *ip;

A filter primitive that translates between C integers and their
external representations.  This routine returns one if it succeeds,
zero otherwise.


@EndNode

@Node "xdr_long()" "RPC.guide/xdr_long()"
@Next "xdrmem_create()"
@Prev "xdr_int()"
@Toc "XDR Function Reference"

xdr_long()
----------

     bool_t XDRFUN
     xdr_long(xdrs, lp)
     XDR *xdrs;
     long *lp;

A filter primitive that translates between C `long' integers and their
external representations.  This routine returns one if it succeeds,
zero otherwise.


@EndNode

@Node "xdrmem_create()" "RPC.guide/xdrmem_create()"
@Next "xdr_opaque()"
@Prev "xdr_long()"
@Toc "XDR Function Reference"

xdrmem_create()
---------------

     void
     xdrmem_create(xdrs, addr, size, op)
     XDR *xdrs;
     char *addr;
     u_int size;
     enum xdr_op op;

This routine initializes the `XDR' stream object pointed to by `xdrs'.
The stream's data is written to, or read from, a chunk of memory at
location `addr' whose length is no more than `size' bytes long.  The
`op' determines the direction of the `XDR' stream (either `XDR_ENCODE',
`XDR_DECODE', or `XDR_FREE').


@EndNode

@Node "xdr_opaque()" "RPC.guide/xdr_opaque()"
@Next "xdr_pointer()"
@Prev "xdrmem_create()"
@Toc "XDR Function Reference"

xdr_opaque()
------------

     bool_t XDRFUN
     xdr_opaque(xdrs, cp, cnt)
     XDR *xdrs;
     char *cp;
     u_int cnt;

A filter primitive that translates between fixed size opaque data and
its external representation.  The parameter `cp' is the address of the
opaque object, and `cnt' is its size in bytes.  This routine returns
one if it succeeds, zero otherwise.


@EndNode

@Node "xdr_pointer()" "RPC.guide/xdr_pointer()"
@Next "xdrrec_create()"
@Prev "xdr_opaque()"
@Toc "XDR Function Reference"

xdr_pointer()
-------------

     bool_t XDRFUN
     xdr_pointer(xdrs, objpp, objsize, xdrobj)
     XDR *xdrs;
     char **objpp;
     u_int objsize;
     xdrproc_t xdrobj;

Like @{"xdr_reference()" Link "xdr_reference()"} execpt that it serializes `NULL' pointers, whereas
@{"xdr_reference()" Link "xdr_reference()"} does not.  Thus, `xdr_pointer()' can represent
recursive data structures, such as binary trees or linked lists.


@EndNode

@Node "xdrrec_create()" "RPC.guide/xdrrec_create()"
@Next "xdrrec_endofrecord()"
@Prev "xdr_pointer()"
@Toc "XDR Function Reference"

xdrrec_create()
---------------

     void
     xdrrec_create(xdrs, sendsize, recvsize, handle, readit, writeit)
     XDR *xdrs;
     u_int sendsize, recvsize;
     char *handle;
     int (*readit) (), (*writeit) ();

This routine initializes the `XDR' stream object pointed to by `xdrs'.
The stream's data is written to a buffer of size `sendsize'; a value of
zero indicates the system should use a suitable default. The stream's
data is read from a buffer of size `recvsize'; it too can be set to a
suitable default by passing a zero value.  When a stream's output
buffer is full, `writeit' is called.  Similarly, when a stream's input
buffer is empty, `readit' is called.  The behavior of these two
routines is similar to the system calls `read' and `write', except that
`handle' is passed to the former routines as the first parameter.
Note: the `XDR' stream's `op' field must be set by the caller.
Warning: this `XDR' stream implements an intermediate record stream.
Therefore there are additional bytes in the stream to provide record
boundary information.


@EndNode

@Node "xdrrec_endofrecord()" "RPC.guide/xdrrec_endofrecord()"
@Next "xdrrec_eof()"
@Prev "xdrrec_create()"
@Toc "XDR Function Reference"

xdrrec_endofrecord()
--------------------

     bool_t
     xdrrec_endofrecord(xdrs, sendnow)
     XDR *xdrs;
     bool_t sendnow;

This routine can be invoked only on streams created by @{"xdrrec_create()" Link "xdrrec_create()"}.
The data in the output buffer is marked as a completed record, and the
output buffer is optionally written out if `sendnow' is non-zero. This
routine returns one if it succeeds, zero otherwise.


@EndNode

@Node "xdrrec_eof()" "RPC.guide/xdrrec_eof()"
@Next "xdrrec_skiprecord()"
@Prev "xdrrec_endofrecord()"
@Toc "XDR Function Reference"

xdrrec_eof()
------------

     bool_t
     xdrrec_eof(xdrs)
     XDR *xdrs;

This routine can be invoked only on streams created by @{"xdrrec_create()" Link "xdrrec_create()"}.
After consuming the rest of the current record in the stream, this
routine returns one if the stream has no more input, zero otherwise.


@EndNode

@Node "xdrrec_skiprecord()" "RPC.guide/xdrrec_skiprecord()"
@Next "xdr_reference()"
@Prev "xdrrec_eof()"
@Toc "XDR Function Reference"

xdrrec_skiprecord()
-------------------

     bool_t
     xdrrec_skiprecord(xdrs)
     XDR *xdrs;

This routine can be invoked only on streams created by @{"xdrrec_create()" Link "xdrrec_create()"}.
It tells the `XDR' implementation that the rest of the current record
in the stream's input buffer should be discarded.  This routine returns
one if it succeeds, zero otherwise.


@EndNode

@Node "xdr_reference()" "RPC.guide/xdr_reference()"
@Next "xdr_setpos()"
@Prev "xdrrec_skiprecord()"
@Toc "XDR Function Reference"

xdr_reference()
---------------

     bool_t XDRFUN
     xdr_reference(xdrs, pp, size, proc)
     XDR *xdrs;
     char **pp;
     u_int size;
     xdrproc_t proc;

A primitive that provides pointer chasing within structures.  The
parameter `pp' is the address of the pointer; `size' is the `sizeof'
the structure that `*pp' points to; and `proc' is an `XDR' procedure
that filters the structure between its C form and its external
representation.  This routine returns one if it succeeds, zero
otherwise.  Warning: this routine does not understand `NULL' pointers.
Use @{"xdr_pointer()" Link "xdr_pointer()"} instead.


@EndNode

@Node "xdr_setpos()" "RPC.guide/xdr_setpos()"
@Next "xdr_short()"
@Prev "xdr_reference()"
@Toc "XDR Function Reference"

xdr_setpos()
------------

     bool_t XDRFUN
     xdr_setpos(xdrs, pos)
     XDR *xdrs;
     u_int pos;

A macro that invokes the set position routine associated with the `XDR'
stream `xdrs'.  The parameter `pos' is a position value obtained from
@{"xdr_getpos()" Link "xdr_getpos()"}.  This routine returns one if the `XDR' stream could be
repositioned, and zero otherwise.  Warning: it is difficult to
reposition some types of `XDR' streams, so this routine may fail with
one type of stream and succeed with another.


@EndNode

@Node "xdr_short()" "RPC.guide/xdr_short()"
@Next "xdrstdio_create()"
@Prev "xdr_setpos()"
@Toc "XDR Function Reference"

xdr_short()
-----------

     bool_t XDRFUN
     xdr_short(xdrs, sp)
     XDR *xdrs;
     short *sp;

A filter primitive that translates between C `short' integers and their
external representations.  This routine returns one if it succeeds,
zero otherwise.


@EndNode

@Node "xdrstdio_create()" "RPC.guide/xdrstdio_create()"
@Next "xdr_string()"
@Prev "xdr_short()"
@Toc "XDR Function Reference"

xdrstdio_create()
-----------------

     void
     xdrstdio_create(xdrs, file, op)
     XDR *xdrs;
     FILE *file;
     enum xdr_op op;

This routine initializes the `XDR' stream object pointed to by `xdrs'.
The `XDR' stream data is written to, or read from, the Standard `I/O'
stream `file'.  The parameter `op' determines the direction of the
`XDR' stream (either `XDR_ENCODE', `XDR_DECODE', or `XDR_FREE').
*Warning:* the destroy routine associated with such `XDR' streams calls
`fflush()' on the `file' stream, but never `fclose()'.


@EndNode

@Node "xdr_string()" "RPC.guide/xdr_string()"
@Next "xdr_u_char()"
@Prev "xdrstdio_create()"
@Toc "XDR Function Reference"

xdr_string()
------------

     bool_t XDRFUN
     xdr_string(xdrs, sp, maxsize)
     XDR *xdrs;
     char **sp;
     u_int maxsize;

A filter primitive that translates between C strings and their
corresponding external representations.  Strings cannot be longer than
`maxsize'.  Note: `sp' is the address of the string's pointer.  This
routine returns one if it succeeds, zero otherwise.


@EndNode

@Node "xdr_u_char()" "RPC.guide/xdr_u_char()"
@Next "xdr_u_int()"
@Prev "xdr_string()"
@Toc "XDR Function Reference"

xdr_u_char()
------------

     bool_t XDRFUN
     xdr_u_char(xdrs, ucp)
     XDR *xdrs;
     unsigned char *ucp;

A filter primitive that translates between `unsigned' C characters and
their external representations.  This routine returns one if it
succeeds, zero otherwise.


@EndNode

@Node "xdr_u_int()" "RPC.guide/xdr_u_int()"
@Next "xdr_u_long()"
@Prev "xdr_u_char()"
@Toc "XDR Function Reference"

xdr_u_int()
-----------

     bool_t XDRFUN
     xdr_u_int(xdrs, up)
     XDR *xdrs;
     unsigned *up;

A filter primitive that translates between C `unsigned' integers and
their external representations.  This routine returns one if it
succeeds, zero otherwise.


@EndNode

@Node "xdr_u_long()" "RPC.guide/xdr_u_long()"
@Next "xdr_u_short()"
@Prev "xdr_u_int()"
@Toc "XDR Function Reference"

xdr_u_long()
------------

     bool_t XDRFUN
     xdr_u_long(xdrs, ulp)
     XDR *xdrs;
     unsigned long *ulp;

A filter primitive that translates between C `unsigned long' integers
and their external representations.  This routine returns one if it
succeeds, zero otherwise.


@EndNode

@Node "xdr_u_short()" "RPC.guide/xdr_u_short()"
@Next "xdr_union()"
@Prev "xdr_u_long()"
@Toc "XDR Function Reference"

xdr_u_short()
-------------

     bool_t XDRFUN
     xdr_u_short(xdrs, usp)
     XDR *xdrs;
     unsigned short *usp;

A filter primitive that translates between C `unsigned short' integers
and their external representations.  This routine returns one if it
succeeds, zero otherwise.


@EndNode

@Node "xdr_union()" "RPC.guide/xdr_union()"
@Next "xdr_vector()"
@Prev "xdr_u_short()"
@Toc "XDR Function Reference"

xdr_union()
-----------

     bool_t XDRFUN
     xdr_union(xdrs, dscmp, unp, choices, dfault)
     XDR *xdrs;
     int *dscmp;
     char *unp;
     struct xdr_discrim *choices;
     bool_t (*defaultarm) ();  /* may equal NULL */

A filter primitive that translates between a discriminated C `union'
and its corresponding external representation. It first translates the
discriminant of the union located at `dscmp'.  This discriminant is
always an `enum_t'.  Next the union located at `unp' is translated.
The parameter `choices' is a pointer to an array of `xdr_discrim'
structures. Each structure contains an ordered pair of
[`value',`proc'].  If the union's discriminant is equal to the
associated `value', then the `proc' is called to translate the union.
The end of the `xdr_discrim' structure array is denoted by a routine of
value `NULL'.  If the discriminant is not found in the `choices' array,
then the `defaultarm' procedure is called (if it is not `NULL').
Returns one if it succeeds, zero otherwise.


@EndNode

@Node "xdr_vector()" "RPC.guide/xdr_vector()"
@Next "xdr_void()"
@Prev "xdr_union()"
@Toc "XDR Function Reference"

xdr_vector()
------------

     bool_t XDRFUN
     xdr_vector(xdrs, arrp, size, elsize, elproc)
     XDR *xdrs;
     char *arrp;
     u_int size, elsize;
     xdrproc_t elproc;

A filter primitive that translates between fixed-length arrays and
their corresponding external representations.  The parameter `arrp' is
the address of the pointer to the array, while `size' is is the element
count of the array.  The parameter `elsize' is the `sizeof' each of the
array's elements, and `elproc' is an `XDR' filter that translates
between the array elements' C form, and their external representation.
This routine returns one if it succeeds, zero otherwise.


@EndNode

@Node "xdr_void()" "RPC.guide/xdr_void()"
@Next "xdr_wrapstring()"
@Prev "xdr_vector()"
@Toc "XDR Function Reference"

xdr_void()
----------

     bool_t XDRFUN
     xdr_void(xdrs, dummy)
     XDR *xdrs;
     void *dummy;

This routine always returns one. It may be passed to `RPC' routines
that require a function parameter, where nothing is to be done. `NULL'
can be passed as argument pointer.


@EndNode

@Node "xdr_wrapstring()" "RPC.guide/xdr_wrapstring()"
@Prev "xdr_void()"
@Toc "XDR Function Reference"

xdr_wrapstring()
----------------

     bool_t XDRFUN
     xdr_wrapstring(xdrs, sp)
     XDR *xdrs;
     char **sp;

A primitive that calls `xdr_string(xdrs, sp, UINT_MAX);' where
`UINT_MAX' is the maximum value of an unsigned integer.
`xdr_wrapstring()' is handy because the `RPC' package passes a maximum
of two parameters to `XDR' routines, and @{"xdr_string()" Link "xdr_string()"}, one of the most
frequently used primitives, requires three.  Returns one if it
succeeds, zero otherwise.


@EndNode

@Node "Function Index" "RPC.guide/Function Index"
@Next "Concept Index"
@Prev "Manual Pages"
@Toc "Main"

Function Index
**************



 @{" authdes_create() " Link "DES Authentication"}                     DES Authentication
 @{" authnone_create() " Link "authnone_create()"}                    authnone_create()
 @{" authnone_create() " Link "UNIX Authentication"}                    UNIX Authentication
 @{" authunix_create() " Link "authunix_create()"}                    authunix_create()
 @{" authunix_create() " Link "DES Authentication"}                    DES Authentication
 @{" authunix_create_default() " Link "authunix_create_default()"}            authunix_create_default()
 @{" authunix_create_default() " Link "UNIX Authentication"}            UNIX Authentication
 @{" auth_destroy() " Link "auth_destroy()"}                       auth_destroy()
 @{" bindresvport() " Link "bindresvport()"}                       bindresvport()
 @{" callrpc() " Link "Intermediate Layer"}                            Intermediate Layer
 @{" callrpc() " Link "callrpc()"}                            callrpc()
 @{" clntraw_create() " Link "clntraw_create()"}                     clntraw_create()
 @{" clnttcp_create() " Link "The Calling Side"}                     The Calling Side
 @{" clnttcp_create() " Link "clnttcp_create()"}                     clnttcp_create()
 @{" clntudp_bufcreate() " Link "clntudp_bufcreate()"}                  clntudp_bufcreate()
 @{" clntudp_create() " Link "The Calling Side"}                     The Calling Side
 @{" clntudp_create() " Link "clntudp_create()"}                     clntudp_create()
 @{" clnt_broadcast() " Link "Broadcast RPC Synopsis"}                     Broadcast RPC Synopsis
 @{" clnt_broadcast() " Link "clnt_broadcast()"}                     clnt_broadcast()
 @{" clnt_call() " Link "The Calling Side"}                          The Calling Side
 @{" clnt_call() " Link "clnt_call()"}                          clnt_call()
 @{" clnt_control() " Link "clnt_control()"}                       clnt_control()
 @{" clnt_create() " Link "clnt_create()"}                        clnt_create()
 @{" clnt_destroy() " Link "clnt_destroy()"}                       clnt_destroy()
 @{" clnt_destroy() " Link "The Calling Side"}                       The Calling Side
 @{" clnt_freeres() " Link "clnt_freeres()"}                       clnt_freeres()
 @{" clnt_geterr() " Link "clnt_geterr()"}                        clnt_geterr()
 @{" clnt_pcreateerror() " Link "clnt_pcreateerror()"}                  clnt_pcreateerror()
 @{" clnt_perrno() " Link "clnt_perrno()"}                        clnt_perrno()
 @{" clnt_perror() " Link "clnt_perror()"}                        clnt_perror()
 @{" clnt_spcreateerror() " Link "clnt_spcreateerror()"}                 clnt_spcreateerror()
 @{" clnt_sperrno() " Link "clnt_sperrno()"}                       clnt_sperrno()
 @{" clnt_sperror() " Link "clnt_sperror()"}                       clnt_sperror()
 @{" getrpcbyname() " Link "getrpcbyname()"}                       getrpcbyname()
 @{" getrpcbynumber() " Link "getrpcbynumber()"}                     getrpcbynumber()
 @{" getrpcport() " Link "getrpcport()"}                         getrpcport()
 @{" gettransient() " Link "Callback Procedures"}                       Callback Procedures
 @{" get_myaddress() " Link "get_myaddress()"}                      get_myaddress()
 @{" host2netname() " Link "DES Authentication"}                       DES Authentication
 @{" netname2user() " Link "DES Authentication"}                       DES Authentication
 @{" ntohs() " Link "Callback Procedures"}                              Callback Procedures
 @{" pmap_getmaps() " Link "pmap_getmaps()"}                       pmap_getmaps()
 @{" pmap_getport() " Link "pmap_getport()"}                       pmap_getport()
 @{" pmap_rmtcall() " Link "pmap_rmtcall()"}                       pmap_rmtcall()
 @{" pmap_set() " Link "Callback Procedures"}                           Callback Procedures
 @{" pmap_set() " Link "pmap_set()"}                           pmap_set()
 @{" pmap_unset() " Link "More on the Server Side"}                         More on the Server Side
 @{" pmap_unset() " Link "pmap_unset()"}                         pmap_unset()
 @{" registerrpc() " Link "Intermediate Layer"}                        Intermediate Layer
 @{" registerrpc() " Link "registerrpc()"}                        registerrpc()
 @{" rpc_createerr " Link "rpc_createerr"}                        rpc_createerr
 @{" select() " Link "Select on the Server Side"}                             Select on the Server Side
 @{" svcerr_auth() " Link "svcerr_auth()"}                        svcerr_auth()
 @{" svcerr_decode() " Link "svcerr_decode()"}                      svcerr_decode()
 @{" svcerr_noproc() " Link "svcerr_noproc()"}                      svcerr_noproc()
 @{" svcerr_noproc() " Link "More on the Server Side"}                      More on the Server Side
 @{" svcerr_noprog() " Link "svcerr_noprog()"}                      svcerr_noprog()
 @{" svcerr_progvers() " Link "svcerr_progvers()"}                    svcerr_progvers()
 @{" svcerr_systemerr() " Link "svcerr_systemerr()"}                   svcerr_systemerr()
 @{" svcerr_systemerr() " Link "UNIX Authentication"}                   UNIX Authentication
 @{" svcerr_weakauth() " Link "UNIX Authentication"}                    UNIX Authentication
 @{" svcerr_weakauth() " Link "svcerr_weakauth()"}                    svcerr_weakauth()
 @{" svcfd_create() " Link "svcfd_create()"}                       svcfd_create()
 @{" svcraw_create() " Link "svcraw_create()"}                      svcraw_create()
 @{" svctcp_create() " Link "More on the Server Side"}                      More on the Server Side
 @{" svctcp_create() " Link "svctcp_create()"}                      svctcp_create()
 @{" svcudp_bufcreate() " Link "svcudp_bufcreate()"}                   svcudp_bufcreate()
 @{" svcudp_create() " Link "More on the Server Side"}                      More on the Server Side
 @{" svcudp_create() " Link "svcudp_create()"}                      svcudp_create()
 @{" svc_destroy() " Link "svc_destroy()"}                        svc_destroy()
 @{" svc_fds " Link "Select on the Server Side"}                              Select on the Server Side
 @{" svc_fds " Link "svc_fds"}                              svc_fds
 @{" svc_fdset " Link "svc_fdset"}                            svc_fdset
 @{" svc_freeargs() " Link "svc_freeargs()"}                       svc_freeargs()
 @{" svc_freeargs() " Link "Memory Allocation with XDR"}                       Memory Allocation with XDR
 @{" svc_getargs() " Link "Memory Allocation with XDR"}                        Memory Allocation with XDR
 @{" svc_getargs() " Link "svc_getargs()"}                        svc_getargs()
 @{" svc_getcaller() " Link "svc_getcaller()"}                      svc_getcaller()
 @{" svc_getreq() " Link "svc_getreq()"}                         svc_getreq()
 @{" svc_getreqset() " Link "Select on the Server Side"}                      Select on the Server Side
 @{" svc_getreqset() " Link "svc_getreqset()"}                      svc_getreqset()
 @{" svc_register() " Link "More on the Server Side"}                       More on the Server Side
 @{" svc_register() " Link "svc_register()"}                       svc_register()
 @{" svc_run() " Link "Intermediate Layer"}                            Intermediate Layer
 @{" svc_run() " Link "svc_run()"}                            svc_run()
 @{" svc_run() " Link "Select on the Server Side"}                            Select on the Server Side
 @{" svc_sendreply() " Link "svc_sendreply()"}                      svc_sendreply()
 @{" svc_sendreply() " Link "More on the Server Side"}                      More on the Server Side
 @{" svc_unregister() " Link "svc_unregister()"}                     svc_unregister()
 @{" user2netname() " Link "DES Authentication"}                       DES Authentication
 @{" xdrmem_create() " Link "Memory Streams"}                      Memory Streams
 @{" xdrmem_create() " Link "xdrmem_create()"}                      xdrmem_create()
 @{" xdrrec_create() " Link "xdrrec_create()"}                      xdrrec_create()
 @{" xdrrec_endofrecord() " Link "Record (TCP-IP) Streams"}                 Record (TCP-IP) Streams
 @{" xdrrec_endofrecord() " Link "xdrrec_endofrecord()"}                 xdrrec_endofrecord()
 @{" xdrrec_eof() " Link "Record (TCP-IP) Streams"}                         Record (TCP-IP) Streams
 @{" xdrrec_eof() " Link "xdrrec_eof()"}                         xdrrec_eof()
 @{" xdrrec_skiprecord() " Link "Record (TCP-IP) Streams"}                  Record (TCP-IP) Streams
 @{" xdrrec_skiprecord() " Link "xdrrec_skiprecord()"}                  xdrrec_skiprecord()
 @{" xdrstdio_create() " Link "xdrstdio_create()"}                    xdrstdio_create()
 @{" xdrstdio_create() " Link "Standard I-O Streams"}                    Standard I-O Streams
 @{" xdr_accepted_reply() " Link "xdr_accepted_reply()"}                 xdr_accepted_reply()
 @{" xdr_array() " Link "Arrays"}                          Arrays
 @{" xdr_array() " Link "xdr_array()"}                          xdr_array()
 @{" xdr_authunix_parms() " Link "xdr_authunix_parms()"}                 xdr_authunix_parms()
 @{" xdr_bool() " Link "xdr_bool()"}                           xdr_bool()
 @{" xdr_bytes() " Link "xdr_bytes()"}                          xdr_bytes()
 @{" xdr_bytes() " Link "Byte Arrays"}                          Byte Arrays
 @{" xdr_callhdr() " Link "xdr_callhdr()"}                        xdr_callhdr()
 @{" xdr_callmsg() " Link "xdr_callmsg()"}                        xdr_callmsg()
 @{" xdr_char() " Link "xdr_char()"}                           xdr_char()
 @{" xdr_destroy() " Link "Non-filter Primitives"}                        Non-filter Primitives
 @{" xdr_destroy() " Link "xdr_destroy()"}                        xdr_destroy()
 @{" xdr_double() " Link "xdr_double()"}                         xdr_double()
 @{" xdr_element() " Link "Arrays"}                        Arrays
 @{" xdr_enum() " Link "xdr_enum()"}                           xdr_enum()
 @{" xdr_float() " Link "xdr_float()"}                          xdr_float()
 @{" xdr_free() " Link "xdr_free()"}                           xdr_free()
 @{" xdr_getpos() " Link "xdr_getpos()"}                         xdr_getpos()
 @{" xdr_getpos() " Link "Non-filter Primitives"}                         Non-filter Primitives
 @{" xdr_inline() " Link "xdr_inline()"}                         xdr_inline()
 @{" xdr_int() " Link "xdr_int()"}                            xdr_int()
 @{" xdr_long() " Link "xdr_long()"}                           xdr_long()
 @{" xdr_opaque() " Link "Opaque Data"}                         Opaque Data
 @{" xdr_opaque() " Link "xdr_opaque()"}                         xdr_opaque()
 @{" xdr_opaque_auth() " Link "xdr_opaque_auth()"}                    xdr_opaque_auth()
 @{" xdr_pmap() " Link "xdr_pmap()"}                           xdr_pmap()
 @{" xdr_pmaplist() " Link "xdr_pmaplist()"}                       xdr_pmaplist()
 @{" xdr_pointer() " Link "xdr_pointer()"}                        xdr_pointer()
 @{" xdr_reference() " Link "xdr_reference()"}                      xdr_reference()
 @{" xdr_reference() " Link "Pointers"}                      Pointers
 @{" xdr_rejected_reply() " Link "xdr_rejected_reply()"}                 xdr_rejected_reply()
 @{" xdr_replymsg() " Link "xdr_replymsg()"}                       xdr_replymsg()
 @{" xdr_setpos() " Link "xdr_setpos()"}                         xdr_setpos()
 @{" xdr_setpos() " Link "Non-filter Primitives"}                         Non-filter Primitives
 @{" xdr_short() " Link "xdr_short()"}                          xdr_short()
 @{" xdr_string() " Link "Strings"}                         Strings
 @{" xdr_string() " Link "xdr_string()"}                         xdr_string()
 @{" xdr_union() " Link "xdr_union()"}                          xdr_union()
 @{" xdr_union() " Link "Discriminated Unions"}                          Discriminated Unions
 @{" xdr_u_char() " Link "xdr_u_char()"}                         xdr_u_char()
 @{" xdr_u_int() " Link "xdr_u_int()"}                          xdr_u_int()
 @{" xdr_u_long() " Link "xdr_u_long()"}                         xdr_u_long()
 @{" xdr_u_short() " Link "xdr_u_short()"}                        xdr_u_short()
 @{" xdr_vector() " Link "Fixed Sized Arrays"}                         Fixed Sized Arrays
 @{" xdr_vector() " Link "xdr_vector()"}                         xdr_vector()
 @{" xdr_void() " Link "xdr_void()"}                           xdr_void()
 @{" xdr_wrapstring() " Link "xdr_wrapstring()"}                     xdr_wrapstring()
 @{" xprt_register() " Link "xprt_register()"}                      xprt_register()
 @{" xprt_unregister() " Link "xprt_unregister()"}                    xprt_unregister()


@EndNode

@Node "Concept Index" "RPC.guide/Concept Index"
@Prev "Function Index"
@Toc "Main"

Concept Index
*************

@Index "Concept Index"



 @{" About the floating point format " Link "About the Floating Point Format"}      About the Floating Point Format
 @{" About the Port to AmiTCP/IP and Amiga " Link "About the Port to AmiTCP-IP and Amiga"} About the Port to AmiTCP-IP and Amiga
 @{" Administration of RPC " Link "Assigning Program Numbers"}                Assigning Program Numbers
 @{" AmiTCP/IP RPC Notes " Link "AmiTCP-IP Notes"}                  AmiTCP-IP Notes
 @{" Arbitrary data types " Link "Passing Arbitrary Data Types"}                 Passing Arbitrary Data Types
 @{" Assigning program numbers " Link "Assigning Program Numbers"}            Assigning Program Numbers
 @{" Authentication " Link "RPC Authentication"}                       RPC Authentication
 @{" Authentication protocols " Link "Authentication Protocols"}             Authentication Protocols
 @{" Authentication, DES " Link "DES Authentication (protocol)"}                  DES Authentication (protocol)
 @{" Authentication, general " Link "Authentication"}              Authentication
 @{" Authentication, Null " Link "Null Authentication (protocol)"}                 Null Authentication (protocol)
 @{" Authentication, requirements " Link "Authentication Requirements"}         Authentication Requirements
 @{" Authentication, UNIX " Link "UNIX Authentication (protocol)"}                 UNIX Authentication (protocol)
 @{" Batching " Link "RPC Batching"}                             RPC Batching
 @{" Batching (RFC) " Link "Batching"}                       Batching
 @{" Binding " Link "Binding and Rendezvous Independence"}                              Binding and Rendezvous Independence
 @{" bool " Link "XDR Booleans"}                                 XDR Booleans
 @{" Booleans " Link "XDR Booleans"}                             XDR Booleans
 @{" bool_t " Link "XDR Booleans"}                               XDR Booleans
 @{" Broadcast RPC " Link "Broadcast RPC"}                        Broadcast RPC
 @{" Broadcast RPC, (RFC) " Link "RPC Broadcast"}                 RPC Broadcast
 @{" Broadcast RPC, server response " Link "Handling Broadcast on the Server Side"}       Handling Broadcast on the Server Side
 @{" Broadcast RPC, synopsis " Link "Broadcast RPC Synopsis"}              Broadcast RPC Synopsis
 @{" C-preprocessor " Link "The C-Preprocessor"}                       The C-Preprocessor
 @{" Changes from SUNRPC 4.0 " Link "What Was Done to the Original SUNRPC 4.0 While Porting"}              What Was Done to the Original SUNRPC 4.0 While Porting
 @{" Choosing the Library to Use " Link "Choosing the Library to Use"}          Choosing the Library to Use
 @{" Client handle, used by rpcgen " Link "Converting Local Procedures into Remote Procedures"}        Converting Local Procedures into Remote Procedures
 @{" Compiling the library " Link "Compiling the library"}                Compiling the library
 @{" Constants " Link "Constants"}                            Constants
 @{" Debugging with rpcgen " Link "Generating XDR Routines"}                Generating XDR Routines
 @{" Declarations " Link "Declarations"}                         Declarations
 @{" Definitions " Link "Definitions"}                          Definitions
 @{" DES authentication protocol " Link "DES Authentication Protocol (in XDR language)"}          DES Authentication Protocol (in XDR language)
 @{" DES authentication verifiers " Link "DES Authentication Verifiers"}         DES Authentication Verifiers
 @{" DES authentication, protocol " Link "DES Authentication (protocol)"}         DES Authentication (protocol)
 @{" DES clock synchronization " Link "Nicknames and Clock Synchronization"}            Nicknames and Clock Synchronization
 @{" DES naming " Link "Naming"}                           Naming
 @{" DES nicknames " Link "Nicknames and Clock Synchronization"}                        Nicknames and Clock Synchronization
 @{" Diffie-Hellman encryption " Link "Diffie-Hellman Encryption"}            Diffie-Hellman Encryption
 @{" direction of XDR operations " Link "XDR Operation Directions"}          XDR Operation Directions
 @{" Disclaimer & Copyright " Link "Disclaimer & Copyright"}               Disclaimer & Copyright
 @{" Encryption, Diffie-Hellman " Link "Diffie-Hellman Encryption"}           Diffie-Hellman Encryption
 @{" enum clnt_stat (in RPC programming) " Link "Intermediate Layer"}  Intermediate Layer
 @{" Enumerations " Link "Enumerations"}                         Enumerations
 @{" External Data Representation: protocol specification " Link "XDR Protocol Specification"} XDR Protocol Specification
 @{" file format, rpc " Link "rpc Data Base File Format"}                     rpc Data Base File Format
 @{" File system model " Link "File System Model"}                    File System Model
 @{" Fixed-length array declarations " Link "Fixed-Length Array Declarations"}      Fixed-Length Array Declarations
 @{" Function reference, RPC " Link "RPC Function Reference"}              RPC Function Reference
 @{" Function reference, XDR " Link "XDR Function Reference"}              XDR Function Reference
 @{" Generating XDR routines " Link "Generating XDR Routines"}              Generating XDR Routines
 @{" Highest layer of RPC " Link "Highest Layer"}                 Highest Layer
 @{" IEEE vs. FFP floating point format " Link "About the Floating Point Format"}   About the Floating Point Format
 @{" inetd " Link "Using Inetd"}                                Using Inetd
 @{" Intermediate layer of RPC " Link "Intermediate Layer"}            Intermediate Layer
 @{" Introcuction to RPC protocol " Link "Introduction to RPC"}         Introduction to RPC
 @{" Introduction to RPC programming guide " Link "Introduction to RPC Programming Guide"} Introduction to RPC Programming Guide
 @{" Introduction to XDR protocol " Link "Introduction to XDR"}         Introduction to XDR
 @{" Introduction, mount protocol " Link "Mount Protocol Introduction"}         Mount Protocol Introduction
 @{" Introduction, NFS " Link "Introduction to NFS"}                    Introduction to NFS
 @{" layers of RPC " Link "Layers of RPC"}                        Layers of RPC
 @{" library primitives for XDR " Link "XDR Library Primitives"}           XDR Library Primitives
 @{" Local procedures " Link "Converting Local Procedures into Remote Procedures"}                     Converting Local Procedures into Remote Procedures
 @{" Lowest layer of RPC " Link "Lowest Layer of RPC"}                  Lowest Layer of RPC
 @{" Manual Pages " Link "Manual Pages"}                         Manual Pages
 @{" Memory allocation with XDR " Link "Memory Allocation with XDR"}           Memory Allocation with XDR
 @{" Message protocol " Link "The RPC Message Protocol"}                     The RPC Message Protocol
 @{" Miscellaneous RPC features " Link "Other RPC Features"}           Other RPC Features
 @{" Miscellaneous utility functions " Link "Miscellaneous Utility Functions"}      Miscellaneous Utility Functions
 @{" Mount data types " Link "Mount Protocol Basic Data Types"}                     Mount Protocol Basic Data Types
 @{" Mount data types, dirpath " Link "dirpath"}            dirpath
 @{" Mount data types, fhandle " Link "fhandle (Mount)"}            fhandle (Mount)
 @{" Mount data types, fhstatus " Link "fhstatus"}           fhstatus
 @{" Mount data types, name " Link "name"}               name
 @{" Mount protocol " Link "Mount Protocol Definition"}                       Mount Protocol Definition
 @{" Mount protocol server procedures " Link "Mount Protocol Server Procedures"}     Mount Protocol Server Procedures
 @{" Mount protocol, basic data types " Link "Mount Protocol Basic Data Types"}     Mount Protocol Basic Data Types
 @{" Mount protocol, introduction " Link "Mount Protocol Introduction"}         Mount Protocol Introduction
 @{" Mount protocol, RPC information " Link "Mount Protocol RPC Information"}      Mount Protocol RPC Information
 @{" Mount protocol, XDR structure sizes " Link "Mount Protocol Sizes of XDR Structures"}  Mount Protocol Sizes of XDR Structures
 @{" Mount server procedures, MNTPROC_DUMP() " Link "Return Mount Entries"} Return Mount Entries
 @{" Mount server procedures, MNTPROC_EXPORT() " Link "Return Export List"} Return Export List
 @{" Mount server procedures, MNTPROC_MNT() " Link "Add Mount Entry"} Add Mount Entry
 @{" Mount server procedures, MNTPROC_NULL() " Link "Do Nothing (Mount)"} Do Nothing (Mount)
 @{" Mount server procedures, MNTPROC_UMNT() " Link "Remove Mount Entry"} Remove Mount Entry
 @{" Mount server procedures, MNTPROC_UMNTALL() " Link "Remove All Mount Entries"} Remove All Mount Entries
 @{" Network File System: version 2 protocol specification " Link "Network File System Version 2 Protocol Specification"} Network File System Version 2 Protocol Specification
 @{" NFS data types " Link "Basic Data Types"}                       Basic Data Types
 @{" NFS data types, attrstat " Link "attrstat"}             attrstat
 @{" NFS data types, diropargs " Link "diropargs"}            diropargs
 @{" NFS data types, diropres " Link "diropres"}             diropres
 @{" NFS data types, fattr " Link "fattr"}                fattr
 @{" NFS data types, fhandle " Link "fhandle"}              fhandle
 @{" NFS data types, filename " Link "filename"}             filename
 @{" NFS data types, ftype " Link "ftype"}                ftype
 @{" NFS data types, path " Link "path"}                 path
 @{" NFS data types, sattr " Link "sattr"}                sattr
 @{" NFS data types, stat " Link "stat"}                 stat
 @{" NFS data types, timeval " Link "timeval"}              timeval
 @{" NFS implementation " Link "NFS Implementation Issues"}                   NFS Implementation Issues
 @{" NFS introduction " Link "Introduction to NFS"}                     Introduction to NFS
 @{" NFS Mount protocol " Link "Mount Protocol Definition"}                   Mount Protocol Definition
 @{" NFS protocol " Link "NFS Protocol Definition"}                         NFS Protocol Definition
 @{" NFS server procedures " Link "Server Procedures"}                Server Procedures
 @{" NFS server procedures, NFSPROC_CREATE() " Link "Create File"} Create File
 @{" NFS server procedures, NFSPROC_GETATTR() " Link "Get File Attributes"} Get File Attributes
 @{" NFS server procedures, NFSPROC_LINK() " Link "Create Link to File"} Create Link to File
 @{" NFS server procedures, NFSPROC_LOOKUP() " Link "Look Up File Name"} Look Up File Name
 @{" NFS server procedures, NFSPROC_MKDIR() " Link "Create Directory"} Create Directory
 @{" NFS server procedures, NFSPROC_NULL() " Link "Do Nothing"} Do Nothing
 @{" NFS server procedures, NFSPROC_READ() " Link "Read From File"} Read From File
 @{" NFS server procedures, NFSPROC_READDIR() " Link "Read From Directory"} Read From Directory
 @{" NFS server procedures, NFSPROC_READLINK() " Link "Read From Symbolic Link"} Read From Symbolic Link
 @{" NFS server procedures, NFSPROC_REMOVE() " Link "Remove File"} Remove File
 @{" NFS server procedures, NFSPROC_RENAME() " Link "Rename File"} Rename File
 @{" NFS server procedures, NFSPROC_RMDIR() " Link "Remove Directory"} Remove Directory
 @{" NFS server procedures, NFSPROC_ROOT() " Link "Get Filesystem Root"} Get Filesystem Root
 @{" NFS server procedures, NFSPROC_SETATTR() " Link "Set File Attributes"} Set File Attributes
 @{" NFS server procedures, NFSPROC_STATFS() " Link "Get Filesystem Attributes"} Get Filesystem Attributes
 @{" NFS server procedures, NFSPROC_SYMLINK() " Link "Create Symbolic Link"} Create Symbolic Link
 @{" NFS server procedures, NFSPROC_WRITE() " Link "Write to File"} Write to File
 @{" NFS server procedures, NFSPROC_WRITECACHE() " Link "Write to Cache"} Write to Cache
 @{" NFS, basic data types " Link "Basic Data Types"}                Basic Data Types
 @{" NFS, external data representation " Link "External Data Representation"}    External Data Representation
 @{" NFS, pathname interpretation " Link "Pathname Interpretation"}         Pathname Interpretation
 @{" NFS, permission issues " Link "Permission Issues"}               Permission Issues
 @{" NFS, protocol definition " Link "NFS Protocol Definition"}             NFS Protocol Definition
 @{" NFS, remote procedure call " Link "Remote Procedure Call"}           Remote Procedure Call
 @{" NFS, RPC information " Link "RPC Information"}                 RPC Information
 @{" NFS, server/client relationship " Link "Server-Client Relationship"}      Server-Client Relationship
 @{" NFS, setting RPC parameters " Link "Setting RPC Parameters"}          Setting RPC Parameters
 @{" NFS, version 2 protocol specification " Link "Network File System Version 2 Protocol Specification"} Network File System Version 2 Protocol Specification
 @{" NFS, XDR structure sizes " Link "Sizes of XDR Structures"}             Sizes of XDR Structures
 @{" Nonsupported features " Link "Nonsupported Features"}                Nonsupported Features
 @{" Null authentication, protocol " Link "Null Authentication (protocol)"}        Null Authentication (protocol)
 @{" opaque " Link "XDR Opaque Data"}                               XDR Opaque Data
 @{" Opaque data " Link "XDR Opaque Data"}                          XDR Opaque Data
 @{" Pointer declarations " Link "Pointer Declarations"}                 Pointer Declarations
 @{" Pointer semantics and XDR " Link "Pointers"}            Pointers
 @{" Port Mapper operation " Link "Port Mapper Operation"}                Port Mapper Operation
 @{" Port Mapper program protocol " Link "Port Mapper Program Protocol"}         Port Mapper Program Protocol
 @{" Port Mapper protocol specification " Link "Port Mapper Protocol Specification (in RPC Language)"}   Port Mapper Protocol Specification (in RPC Language)
 @{" portmap (the program) " Link "portmap and rpcinfo"}                portmap and rpcinfo
 @{" portmap manual page " Link "portmap Manual Page"}                  portmap Manual Page
 @{" Preprocessor " Link "The C-Preprocessor"}                         The C-Preprocessor
 @{" Program number assignment " Link "Assigning Program Numbers"}            Assigning Program Numbers
 @{" Program number assignment (RFC) " Link "Program Number Assignment"}      Program Number Assignment
 @{" Programs " Link "Programs"}                             Programs
 @{" Protocol Requirements (RPC) " Link "RPC Protocol Requirements"}          RPC Protocol Requirements
 @{" Protocol specification, NFS version 2 " Link "Network File System Version 2 Protocol Specification"} Network File System Version 2 Protocol Specification
 @{" Protocol specification, RPC " Link "Remote Procedure Calls Protocol Specification"}          Remote Procedure Calls Protocol Specification
 @{" Protocol specification, XDR " Link "XDR Protocol Specification"}          XDR Protocol Specification
 @{" Record Marking standard " Link "Record Marking Standard"}              Record Marking Standard
 @{" References (RPC) " Link "RPC References"}                     RPC References
 @{" References (XDR) " Link "XDR References"}                     XDR References
 @{" Remote Procedure Call programming guide " Link "Remote Procedure Call Programming Guide"} Remote Procedure Call Programming Guide
 @{" Remote Procedure Calls: protocol specification " Link "Remote Procedure Calls Protocol Specification"} Remote Procedure Calls Protocol Specification
 @{" Remote procedures " Link "Converting Local Procedures into Remote Procedures"}                    Converting Local Procedures into Remote Procedures
 @{" Rendezvous independence " Link "Binding and Rendezvous Independence"}              Binding and Rendezvous Independence
 @{" RFC, XDR " Link "XDR Protocol Specification"}                             XDR Protocol Specification
 @{" RPC administration " Link "Assigning Program Numbers"}                   Assigning Program Numbers
 @{" RPC authentication, library functions " Link "DES Authentication"} DES Authentication
 @{" RPC binding " Link "Binding and Rendezvous Independence"}                          Binding and Rendezvous Independence
 @{" rpc data base file format " Link "rpc Data Base File Format"}            rpc Data Base File Format
 @{" RPC DES " Link "DES Authentication"}                              DES Authentication
 @{" RPC function reference " Link "RPC Function Reference"}               RPC Function Reference
 @{" RPC guarantees " Link "UNIX Authentication"}                       UNIX Authentication
 @{" RPC language " Link "RPC Language"}                         RPC Language
 @{" RPC language specification " Link "The RPC Language Specification"}           The RPC Language Specification
 @{" RPC language, example service " Link "An Example Service Described in the RPC Language"}        An Example Service Described in the RPC Language
 @{" RPC language, ext. to the XDR Language " Link "The RPC Language"} The RPC Language
 @{" RPC language, syntax notes " Link "RPC Syntax Notes"}           RPC Syntax Notes
 @{" RPC message protocol " Link "The RPC Message Protocol"}                 The RPC Message Protocol
 @{" RPC model " Link "The RPC Model"}                            The RPC Model
 @{" RPC paradigm " Link "The RPC Paradigm"}                         The RPC Paradigm
 @{" RPC procedures " Link "Programs and Procedures"}                       Programs and Procedures
 @{" RPC programming guide, introduction " Link "Introduction to RPC Programming Guide"}  Introduction to RPC Programming Guide
 @{" RPC programs " Link "Programs and Procedures"}                         Programs and Procedures
 @{" RPC Protocol Requirements " Link "RPC Protocol Requirements"}            RPC Protocol Requirements
 @{" RPC protocol, introduction " Link "Introduction to RPC"}           Introduction to RPC
 @{" RPC protocol, other uses " Link "Other Uses of the RPC Protocol"}             Other Uses of the RPC Protocol
 @{" RPC select() " Link "Select on the Server Side"}                         Select on the Server Side
 @{" RPC services " Link "Highest Layer"}                         Highest Layer
 @{" RPC terminology " Link "Terminology"}                      Terminology
 @{" RPC transport semantics " Link "Transports and Semantics"}              Transports and Semantics
 @{" RPC, authentication " Link "RPC Authentication"}                  RPC Authentication
 @{" RPC, batching " Link "RPC Batching"}                        RPC Batching
 @{" RPC, broadcast " Link "Broadcast RPC"}                       Broadcast RPC
 @{" RPC, broadcast synopsis " Link "Broadcast RPC Synopsis"}              Broadcast RPC Synopsis
 @{" RPC, built-in routines " Link "Passing Arbitrary Data Types"}               Passing Arbitrary Data Types
 @{" RPC, callback procedures " Link "Callback Procedures"}             Callback Procedures
 @{" RPC, calling side " Link "The Calling Side"}                    The Calling Side
 @{" RPC, highest layer " Link "Highest Layer"}                   Highest Layer
 @{" RPC, intermediate layer " Link "Intermediate Layer"}              Intermediate Layer
 @{" RPC, layers " Link "Layers of RPC"}                          Layers of RPC
 @{" RPC, lowest layer " Link "Lowest Layer of RPC"}                    Lowest Layer of RPC
 @{" RPC, miscellaneous features " Link "Other RPC Features"}          Other RPC Features
 @{" RPC, protocol specification " Link "Remote Procedure Calls Protocol Specification"}          Remote Procedure Calls Protocol Specification
 @{" RPC, server side " Link "More on the Server Side"}                     More on the Server Side
 @{" RPC, the highest layer, introduction " Link "The Highest Layer"} The Highest Layer
 @{" RPC, the lowest layer, introduction " Link "The Lowest Layer"}  The Lowest Layer
 @{" RPC, the middle layer, introduction " Link "The Middle Layer"}  The Middle Layer
 @{" RPC, versions " Link "Versions"}                        Versions
 @{" rpcgen " Link "Introduction to RPC Programming Guide"}                               Introduction to RPC Programming Guide
 @{" rpcgen C-preprocessor " Link "The C-Preprocessor"}                The C-Preprocessor
 @{" rpcgen constants " Link "Constants"}                     Constants
 @{" rpcgen declarations " Link "Declarations"}                  Declarations
 @{" rpcgen definitions " Link "Definitions"}                   Definitions
 @{" rpcgen enumerations " Link "Enumerations"}                  Enumerations
 @{" rpcgen manual page " Link "rpcgen Manual Page"}                   rpcgen Manual Page
 @{" rpcgen Notes " Link "rpcgen Notes"}                         rpcgen Notes
 @{" rpcgen other operations " Link "rpcgen Programming Notes"}              rpcgen Programming Notes
 @{" rpcgen programming guide " Link "rpcgen Programming Guide"}             rpcgen Programming Guide
 @{" rpcgen programs " Link "Programs"}                      Programs
 @{" rpcgen special cases " Link "Special Cases"}                 Special Cases
 @{" rpcgen structures " Link "Structures"}                    Structures
 @{" rpcgen typedef " Link "Typedef"}                       Typedef
 @{" rpcgen unions " Link "Unions"}                        Unions
 @{" rpcgen, broadcast RPC " Link "Handling Broadcast on the Server Side"}                Handling Broadcast on the Server Side
 @{" rpcgen, introduction " Link "The rpcgen Protocol Compiler"}                 The rpcgen Protocol Compiler
 @{" rpcgen, RPC language " Link "RPC Language"}                 RPC Language
 @{" rpcinfo (the program) " Link "portmap and rpcinfo"}                portmap and rpcinfo
 @{" rpcinfo manual page " Link "rpcinfo Manual Page"}                  rpcinfo Manual Page
 @{" RPCL " Link "RPC Language"}                                 RPC Language
 @{" SAS/C 6.x " Link "Supported Compilers"}                            Supported Compilers
 @{" select() on the server side " Link "Select on the Server Side"}          Select on the Server Side
 @{" Servers, stateless " Link "Stateless Servers"}                   Stateless Servers
 @{" Simple declarations " Link "Simple Declarations"}                  Simple Declarations
 @{" Stateless servers " Link "Stateless Servers"}                    Stateless Servers
 @{" stream implementation in XDR " Link "XDR Stream Implementation"}         XDR Stream Implementation
 @{" string " Link "XDR Strings"}                               XDR Strings
 @{" Strings " Link "XDR Strings"}                              XDR Strings
 @{" Structures " Link "Structures"}                           Structures
 @{" Supported Compilers " Link "Supported Compilers"}                  Supported Compilers
 @{" TCP " Link "TCP"}                                  TCP
 @{" Terminology " Link "Terminology"}                          Terminology
 @{" The rpcgen protocol compiler " Link "The rpcgen Protocol Compiler"}         The rpcgen Protocol Compiler
 @{" Timeout changes " Link "Timeout Changes"}                      Timeout Changes
 @{" Transport semantics " Link "Transports and Semantics"}                  Transports and Semantics
 @{" Typedef " Link "Typedef"}                              Typedef
 @{" UDP 8K warning " Link "Intermediate Layer"}                       Intermediate Layer
 @{" Unions " Link "Unions"}                               Unions
 @{" UNIX authentication, library functions " Link "UNIX Authentication"} UNIX Authentication
 @{" UNIX authentication, protocol " Link "UNIX Authentication (protocol)"}        UNIX Authentication (protocol)
 @{" Using inetd " Link "Using Inetd"}                          Using Inetd
 @{" Using the Library " Link "Using the Library"}                    Using the Library
 @{" Variable-length array declarations " Link "Variable-Length Array Declarations"}   Variable-Length Array Declarations
 @{" Versions " Link "Versions"}                             Versions
 @{" void " Link "XDR Voids"}                                 XDR Voids
 @{" Voids " Link "XDR Voids"}                                XDR Voids
 @{" XDR array, fixed length " Link "Fixed-length Array"}              Fixed-length Array
 @{" XDR array, variable length " Link "Variable-length Array"}           Variable-length Array
 @{" XDR basic block size " Link "Basic Block Size"}                 Basic Block Size
 @{" XDR block size " Link "Basic Block Size"}                       Basic Block Size
 @{" XDR boolean " Link "Boolean"}                          Boolean
 @{" XDR byte order " Link "Why Only one Byte-Order for an XDR Unit?"}                       Why Only one Byte-Order for an XDR Unit?
 @{" XDR constant " Link "Constant"}                         Constant
 @{" XDR data types " Link "XDR Data Types"}                       XDR Data Types
 @{" XDR data, optional " Link "Optional-data"}                   Optional-data
 @{" XDR discriminated union " Link "Discriminated Union"}              Discriminated Union
 @{" XDR double-precision floating-point integer " Link "Double-precision Floating-point"} Double-precision Floating-point
 @{" XDR enumeration " Link "Enumeration"}                      Enumeration
 @{" XDR fixed-length array " Link "Fixed-length Array"}               Fixed-length Array
 @{" XDR fixed-length opaque data " Link "Fixed-length Opaque Data"}         Fixed-length Opaque Data
 @{" XDR floating-point integer " Link "Floating-point"}           Floating-point
 @{" XDR function reference " Link "XDR Function Reference"}               XDR Function Reference
 @{" XDR futures " Link "Areas for Future Enhancement"}                          Areas for Future Enhancement
 @{" XDR hyper integer " Link "Hyper Integer and Unsigned Hyper Integer"}                    Hyper Integer and Unsigned Hyper Integer
 @{" XDR integer " Link "Integer"}                          Integer
 @{" XDR integer, double-precision floating point " Link "Double-precision Floating-point"} Double-precision Floating-point
 @{" XDR integer, floating point " Link "Floating-point"}          Floating-point
 @{" XDR integer, hyper " Link "Hyper Integer and Unsigned Hyper Integer"}                   Hyper Integer and Unsigned Hyper Integer
 @{" XDR integer, unsigned " Link "Unsigned Integer"}                Unsigned Integer
 @{" XDR justification " Link "Justification"}                    Justification
 @{" XDR language " Link "Why a Language for Describing Data?"}                         Why a Language for Describing Data?
 @{" XDR language notation " Link "Notational Conventions"}                Notational Conventions
 @{" XDR language specification " Link "The XDR Language Specification"}           The XDR Language Specification
 @{" XDR language syntax " Link "Syntax Information"}                  Syntax Information
 @{" XDR language syntax notes " Link "XDR Syntax Notes"}            XDR Syntax Notes
 @{" XDR library, arrays " Link "Arrays"}                  Arrays
 @{" XDR library, byte arrays " Link "Byte Arrays"}             Byte Arrays
 @{" XDR library, constructed data type filters " Link "Constructed Data Type Filters"} Constructed Data Type Filters
 @{" XDR library, constructed data type filters: examples " Link "XDR Examples"} XDR Examples
 @{" XDR library, discriminated unions " Link "Discriminated Unions"}    Discriminated Unions
 @{" XDR library, enumeration filters " Link "Enumeration Filters"}     Enumeration Filters
 @{" XDR library, fixed sized arrays " Link "Fixed Sized Arrays"}      Fixed Sized Arrays
 @{" XDR library, floating point filters " Link "Floating Point Filters"}  Floating Point Filters
 @{" XDR library, no data " Link "No Data"}                 No Data
 @{" XDR library, number filters " Link "Number Filters"}          Number Filters
 @{" XDR library, opaque data " Link "Opaque Data"}             Opaque Data
 @{" XDR library, pointers " Link "Pointers"}                Pointers
 @{" XDR library, strings " Link "Strings"}                 Strings
 @{" XDR object " Link "The XDR Object"}                           The XDR Object
 @{" XDR opaque data, fixed length " Link "Fixed-length Opaque Data"}        Fixed-length Opaque Data
 @{" XDR opaque data, variable length " Link "Variable-length Opaque Data"}     Variable-length Opaque Data
 @{" XDR optional data " Link "Optional-data"}                    Optional-data
 @{" XDR protocol specification " Link "XDR Protocol Specification"}           XDR Protocol Specification
 @{" XDR protocol, introduction " Link "Introduction to XDR"}           Introduction to XDR
 @{" XDR RFC " Link "XDR Protocol Specification"}                              XDR Protocol Specification
 @{" XDR routines, generating " Link "Generating XDR Routines"}             Generating XDR Routines
 @{" XDR string " Link "String"}                           String
 @{" XDR Strings " Link "XDR Strings"}                          XDR Strings
 @{" XDR structure " Link "Structure"}                        Structure
 @{" XDR Technical Notes " Link "XDR Technical Notes"}                  XDR Technical Notes
 @{" XDR typedef " Link "Typedef (type definition)"}                          Typedef (type definition)
 @{" XDR union discriminated " Link "Discriminated Union"}              Discriminated Union
 @{" XDR unsigned integer " Link "Unsigned Integer"}                 Unsigned Integer
 @{" XDR variable-length array " Link "Variable-length Array"}            Variable-length Array
 @{" XDR variable-length data " Link "Why must Variable-Length Data be Padded with Zeros?"}             Why must Variable-Length Data be Padded with Zeros?
 @{" XDR variable-length opaque data " Link "Variable-length Opaque Data"}      Variable-length Opaque Data
 @{" XDR void " Link "Void"}                             Void
 @{" XDR, advanced topics " Link "Advanced Topics"}                 Advanced Topics
 @{" XDR, canonical standard " Link "A Canonical Standard"}              A Canonical Standard
 @{" XDR, library " Link "The XDR Library"}                         The XDR Library
 @{" XDR, library primitives " Link "XDR Library Primitives"}              XDR Library Primitives
 @{" XDR, linked lists " Link "Linked Lists"}                    Linked Lists
 @{" XDR, memory allocation " Link "Memory Allocation with XDR"}               Memory Allocation with XDR
 @{" XDR, memory streams " Link "Memory Streams"}                  Memory Streams
 @{" XDR, non-filter primitives " Link "Non-filter Primitives"}           Non-filter Primitives
 @{" XDR, operation directions " Link "XDR Operation Directions"}            XDR Operation Directions
 @{" XDR, overview " Link "Overview"}                        Overview
 @{" XDR, portable data " Link "Justification"}                   Justification
 @{" XDR, record (TCP/IP) streams " Link "Record (TCP-IP) Streams"}         Record (TCP-IP) Streams
 @{" XDR, standard I/O streams " Link "Standard I-O Streams"}            Standard I-O Streams
 @{" XDR, stream access " Link "XDR Stream Access"}                   XDR Stream Access
 @{" XDR, stream implementation " Link "XDR Stream Implementation"}           XDR Stream Implementation
 @{" XDR, Sun Technical Notes " Link "XDR Technical Notes"}             XDR Technical Notes
 @{" XDR, system routines " Link "Overview"}                 Overview
 @{" xdrstdio_create(), example " Link "The XDR Library"}           The XDR Library
 @{" xdr_double(), note " Link "About the Floating Point Format"}                   About the Floating Point Format
 @{" xdr_float(), note " Link "About the Floating Point Format"}                    About the Floating Point Format
 @{" xdr_reference() with NULL pointers " Link "Pointers"}   Pointers

@EndNode

